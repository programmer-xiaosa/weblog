/*
 Navicat Premium Data Transfer

 Source Server         : 47.98.119.250
 Source Server Type    : MySQL
 Source Server Version : 50736 (5.7.36)
 Source Host           : 47.98.119.250:3306
 Source Schema         : weblog

 Target Server Type    : MySQL
 Target Server Version : 50736 (5.7.36)
 File Encoding         : 65001

 Date: 24/04/2024 11:03:37
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文章标题',
  `cover` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文章封面',
  `summary` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '文章摘要',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '删除标志位：0：未删除 1：已删除',
  `read_num` int(11) UNSIGNED NOT NULL DEFAULT 1 COMMENT '被阅读次数',
  `weight` int(6) UNSIGNED NOT NULL DEFAULT 0 COMMENT '文章权重，用于是否置顶（0: 未置顶；>0: 参与置顶，权重值越高越靠前）',
  `type` tinyint(2) NOT NULL DEFAULT 1 COMMENT '文章类型 - 1：普通文章，2：收录于知识库',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (2, 'TypeScript文档', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/35d5a1d2-6ccc-4452-b747-ac0dadeeb67b.jpeg', 'TypeScript全套教程', '2024-03-22 16:02:00', '2024-03-25 23:13:19', 0, 18, 0, 2);
INSERT INTO `t_article` VALUES (7, '极客园PC', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/3075b737-b98e-4b78-83d6-c202b0ed7b02.png', '极客园PC1', '2024-03-22 19:21:07', '2024-03-26 15:33:08', 0, 42, 0, 2);
INSERT INTO `t_article` VALUES (10, 'Mac 多版本jdk安装与切换', 'https://img.arnasoft.site/weblog/1679bf5d88fa41ca9ebd360923e7e819.jpg', '现在已经安装了3个版本的jdk，但是怎么确定当前生效的是哪个版本呢？或者说怎么切换这两个版本呢？配置方法如下', '2024-03-26 17:47:17', '2024-03-26 18:03:21', 0, 32, 0, 2);
INSERT INTO `t_article` VALUES (11, 'idea Server URL 配置修改', 'https://img.arnasoft.site/weblog/dfb2a8767598412fad75adbabe67d89c.png', '在创建spring boot或者spring cloud项目时，idea默认使用https://start.spring.io作为脚手架，创建完成后手动去添加相关的jar包组合', '2024-03-26 17:56:23', '2024-03-26 17:56:23', 0, 22, 0, 2);
INSERT INTO `t_article` VALUES (12, '修改Docker容器内的MySQL服务密码，并成功完成可视化工具登录', 'https://img.arnasoft.site/weblog/bec855b8810c45c395eb71adf29829a8.jpeg', '今天突然发现自己的MySQL服务的密码有很多人知道，瞬间感觉不安全了 最初设想', '2024-04-03 10:44:38', '2024-04-03 11:10:41', 0, 37, 0, 2);
INSERT INTO `t_article` VALUES (13, 'Docker 安装 Jenkins（图文教程）', 'https://img.arnasoft.site/weblog/2dc8f83c633941e1b10d4789a42c57d5.jpeg', 'Jenkins 是一个开源的持续集成（Continuous Integration）工具，它的主要作用是帮助开发团队自动化构建、测试和部署软件项目', '2024-04-07 00:31:04', '2024-04-07 00:31:23', 0, 19, 0, 2);
INSERT INTO `t_article` VALUES (14, '常用网址大全', 'https://img.arnasoft.site/weblog/461fde1dde144a8fa2b89881be6f187e.jpeg', '常用的技术类网址大全，平时在开发和阅读文档时极其重要', '2024-04-08 00:20:02', '2024-04-16 23:20:47', 0, 8, 0, 1);
INSERT INTO `t_article` VALUES (15, 'mac 安装n进行node版本管理', 'https://img.arnasoft.site/weblog/9bdc4e15fa184ba6a185c08b0cf548d6.png', '如果最终显示的还是原来node的版本号则需要在管理员权限下运行: sudo n node版本号', '2024-04-09 23:24:32', '2024-04-09 23:24:32', 0, 10, 0, 2);
INSERT INTO `t_article` VALUES (16, 'Linux docker redis 设置密码并启动登录', 'https://img.arnasoft.site/weblog/f288cdb105c948a6ba037093595c4021.png', 'docker redis 设置密码并启动，贼大的坑，初学者留意！', '2024-04-11 11:11:08', '2024-04-11 11:13:40', 0, 17, 0, 2);
INSERT INTO `t_article` VALUES (17, 'Vue 项目中 Vconsole 的使用', 'https://img.arnasoft.site/weblog/f274d084d06c43198703c62245f85fac.png', '一个轻量、可拓展、针对手机网页的前端开发者调试面板', '2024-04-16 23:36:35', '2024-04-16 23:36:35', 0, 8, 0, 2);
INSERT INTO `t_article` VALUES (18, 'IDEA 创建SpringBoot项目没办法选择jdk8', 'https://img.arnasoft.site/weblog/d23296f2fe6e4eaca58af74bf96fd27e.png', '这里可以使用更便捷的方式，直接替换`server url`，这里推荐使用阿里的服务器`url`来创建项目', '2024-04-16 23:42:32', '2024-04-16 23:42:32', 0, 16, 0, 2);
INSERT INTO `t_article` VALUES (19, '使用 useDark(), 发现 transition 动画失效?', 'https://img.arnasoft.site/weblog/d6aa4b6ad7ee4baea829871e0f1951e0.png', '对于为什么用 useDark() 会导致过渡效果失效,一直找不到原因？', '2024-04-17 00:33:03', '2024-04-17 00:33:03', 0, 25, 0, 2);
INSERT INTO `t_article` VALUES (20, '如何把iconfont字体图标批量添加购物车？', 'https://img.arnasoft.site/weblog/60bc19d5a2134788997376afb0aee790.png', '平时搜某个图标后想批量导入到购物车，可惜阿里巴巴字体图标库目前还没加批量入库的功能', '2024-04-19 18:46:32', '2024-04-19 18:49:42', 0, 6, 0, 1);
INSERT INTO `t_article` VALUES (21, '2023前端面试题', 'https://img.arnasoft.site/weblog/35ec182951be496393584d89a19f58ee.jpg', 'HTML，CSS，JavaScript，Nodejs，Vue2，Vue3，微信小程序', '2024-04-23 18:58:17', '2024-04-23 19:02:28', 0, 5, 0, 1);

-- ----------------------------
-- Table structure for t_article_category_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_article_category_rel`;
CREATE TABLE `t_article_category_rel`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` bigint(20) UNSIGNED NOT NULL COMMENT '文章id',
  `category_id` bigint(20) UNSIGNED NOT NULL COMMENT '分类id',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uni_article_id`(`article_id`) USING BTREE,
  INDEX `idx_category_id`(`category_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 59 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章所属分类关联表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_category_rel
-- ----------------------------
INSERT INTO `t_article_category_rel` VALUES (22, 2, 9);
INSERT INTO `t_article_category_rel` VALUES (25, 7, 9);
INSERT INTO `t_article_category_rel` VALUES (33, 11, 18);
INSERT INTO `t_article_category_rel` VALUES (34, 10, 18);
INSERT INTO `t_article_category_rel` VALUES (38, 12, 2);
INSERT INTO `t_article_category_rel` VALUES (41, 13, 2);
INSERT INTO `t_article_category_rel` VALUES (43, 15, 7);
INSERT INTO `t_article_category_rel` VALUES (45, 16, 18);
INSERT INTO `t_article_category_rel` VALUES (47, 14, 18);
INSERT INTO `t_article_category_rel` VALUES (48, 17, 9);
INSERT INTO `t_article_category_rel` VALUES (49, 18, 2);
INSERT INTO `t_article_category_rel` VALUES (50, 19, 9);
INSERT INTO `t_article_category_rel` VALUES (55, 20, 9);
INSERT INTO `t_article_category_rel` VALUES (58, 21, 9);

-- ----------------------------
-- Table structure for t_article_content
-- ----------------------------
DROP TABLE IF EXISTS `t_article_content`;
CREATE TABLE `t_article_content`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章内容id',
  `article_id` bigint(20) NOT NULL COMMENT '文章id',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '教程正文',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章内容表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_content
-- ----------------------------
INSERT INTO `t_article_content` VALUES (2, 2, '# TypeScript文档\n\n[TS 官方文档](https://www.typescriptlang.org/)\n\n# TypeScript\n\n- TypeScript 介绍\n- TypeScript 初体验\n- TypeScript 常用类型\n- TypeScript 高级类型\n- TypeScript 类型声明文件\n- 在 React 中使用 TypeScript\n\n## TypeScript 介绍\n\n- [TS 官方文档](https://www.typescriptlang.org/)\n- [TS 中文参考 - 不再维护](https://www.tslang.cn/)\n\n![TS Logo](https://gitee.com/qarabala/docsify/raw/typescript/typescript/typescript/images/TS_logo.png)\n\n1. TypeScript 是什么\n2. TypeScript 为什么要为 JS 添加类型支持?\n3. TypeScript 相比 JS 的优势\n\n### TypeScript 是什么\n\n- **`TypeScript` 简称：TS，是 JavaScript 的超集**，简单来说就是：JS 有的 TS 都有\n\n![TS是JS的超集](https://qarabala.gitee.io/docsify/typescript/images/TS%E6%98%AFJS%E7%9A%84%E8%B6%85%E9%9B%86.png)\n\n- TypeScript = `Type` + JavaScript（在 JS 基础之上，**为 JS 添加了类型支持**）\n- TypeScript 是*微软*开发的开源编程语言，可以在任何运行 JavaScript 的地方运行\n\n![TS 和 JS 的对比](https://qarabala.gitee.io/docsify/typescript/images/TSvsJS.png)\n\n### TypeScript 为什么要为 JS 添加类型支持?\n\n- 背景：JS 的类型系统存在“先天缺陷”，JS 代码中绝大部分错误都是类型错误（Uncaught TypeError） \n- 这些经常出现的错误，导致了在使用 JS 进行项目开发时，增加了找 Bug、改 Bug 的时间，严重影响开发效率\n\n为什么会这样？\n\n- 从编程语言的动静来区分，**TypeScript 属于静态类型的编程语言**，**JavaScript 属于动态类型的编程语言**\n  - 静态类型：**编译**期做类型检查\n  - 动态类型：**执行**期做类型检查\n- 代码编译和代码执行的顺序：1 编译 2 执行\n\n- 对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚）\n- 对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早）\n\n并且，配合 VSCode 等开发工具，TS 可以提前到**在编写代码的同时就发现代码中的错误**，减少找 Bug、改 Bug 时间  \n\n对比：\n\n- 使用 JS：\n  1. 在 VSCode 里面写代码\n  2. 在浏览器中运行代码 --> 运行时，才会发现错误【晚】\n- 使用 TS：\n  1. 在 VSCode 里面写代码 --> 写代码的同时，就会发现错误【早】\n  2. 在浏览器中运行代码\n\n### TypeScript 相比 JS 的优势\n\n1. **更早（写代码的同时）发现错误**，减少找 Bug、改 Bug 时间，提升开发效率\n2. 程序中任何位置的代码都有**代码提示**，随时随地的安全感，增强了开发体验\n3. 强大的类型系统提升了代码的可维护性，使得**重构代码更加容易**\n4. 支持最新的 ECMAScript 语法，**优先体验最新的语法，让你走在前端技术的最前沿** \n5. TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了学习负担\n\n除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端 项目的首选编程语言\n\n目前，前端最新的开发技术栈：\n\n1. React： TS + Hooks\n2. Vue： TS + Vue3\n\n  - 注意： Vue2 对 TS 的支持不好~ \n\n---\n\n## TypeScript 初体验\n\n1. 安装编译 TS 的工具包\n2. 编译并运行 TS 代码\n3. 简化运行 TS 的步骤\n\n### 安装编译 TS 的工具包\n\n- 问题：为什么要安装编译 TS 的工具包?\n- 回答：Node.js/浏览器，只认识 JS 代码，不认识 TS 代码。需要先将 TS 代码转化为 JS 代码，然后才能运行\n- 安装命令：`npm i -g typescript`\n  - typescript 包：用来编译 TS 代码的包，提供了 `tsc` 命令，实现了 TS -> JS 的转化\n  - *注意：Mac 电脑安装全局包时，需要添加 `sudo` 获取权限：`sudo npm i -g typescript`*  yarn 全局安装：`sudo yarn global add typescript`\n- 验证是否安装成功：tsc –v(查看 typescript 的版本)\n\n![TS 编译](https://qarabala.gitee.io/docsify/typescript/images/TS编译.png)\n\n###  编译并运行 TS 代码\n\n1. 创建 hello.ts 文件（注意：**TS 文件的后缀名为 `.ts`**）\n2. 将 TS 编译为 JS：在终端中输入命令，`tsc hello.ts`（此时，在同级目录中会出现一个同名的 JS 文件）\n3. 执行 JS 代码：在终端中输入命令，`node hello.js`\n\n1 创建 ts 文件  ===>  2 编译 TS  ===>  3 执行 JS  \n\n- 说明：所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可\n- 注意：由 TS 编译生成的 JS 文件，代码中就没有类型信息了\n\n### 简化运行 TS 的步骤\n\n- 问题描述：每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐\n- 简化方式：使用 `ts-node` 包，直接在 Node.js 中执行 TS 代码\n- 安装命令：`npm i -g ts-node`\n  - ts-node 包提供了 `ts-node` 命令\n  - 使用方式：`ts-node hello.ts` 相当于：1 tsc 命令  2 node（注意：ts-node 不会生成 js 文件）\n\n解释：ts-node 命令在内部偷偷的将 TS -> JS，然后，再运行 JS 代码\n\n\n# TypeScript 常用类型\n\n- TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：**类型系统**\n  - 所有的 JS 代码都是 TS 代码\n  - **JS 有类型**（比如，number/string 等），但是 **JS 不会检查变量的类型是否发生变化**，而 TS 会检查\n- TypeScript 类型系统的主要优势：**可以显示标记出代码中的意外行为，从而降低了发生错误的可能性**\n\n1. 类型注解\n2. 常用基础类型\n\n## 类型注解\n\n示例代码:\n\n```ts\nlet age: number = 18\n```\n\n- 说明：代码中的 `: number` 就是**类型注解**\n- 作用：**为变量添加类型约束**。比如，上述代码中，约定变量 age 的类型为 number 类型\n- 解释：**约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错**\n\n- 错误演示：\n\n```ts\n// 错误代码：\n// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致\nlet age: number = \'18\'\n```\n\n## 常用基础类型\n\n可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型\n\n1. JS 已有类型\n  - 原始类型：`number/string/boolean/null/undefined/symbol`\n  - 对象类型：`object`（包括，数组、对象、函数等对象）\n2. TS 新增类型\n  - 联合类型、自定义类型(类型别名)、接口、元组、字面量类型、枚举、void、any 等\n\n- 注意：\n  1. *原始类型*在 TS 和 JS 中写法一致\n  2. *对象类型*在 TS 中更加细化，每个具体的对象（比如，数组、对象、函数）都有自己的类型语法\n\n### 原始类型\n\n- 原始类型：number/string/boolean/null/undefined/symbol\n- 特点：简单，这些类型，完全按照 JS 中类型的名称来书写\n\n```ts\nlet age: number = 18\nlet myName: string = \'老师\'\nlet isLoading: boolean = false\n\n// 等等...\n```\n\n###  数组类型\n\n- 数组类型的两种写法：\n  - 推荐使用 `number[]` 写法\n\n```ts\n// 写法一：\nlet numbers: number[] = [1, 3, 5]\n// 写法二：\nlet strings: Array<string> = [\'a\', \'b\', \'c\']\n```\n\n### 联合类型\n\n需求：数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?\n\n```ts\nlet arr: (number | string)[] = [1, \'a\', 3, \'b\']\n```\n\n- 解释：`|`（竖线）在 TS 中叫做**联合类型**，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种\n- 注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了\n\n### 类型别名\n\n- `类型别名（自定义类型）`：为任意类型起别名\n- 使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，**简化该类型的使用**\n\n```ts\ntype CustomArray = (number | string)[]\n\nlet arr1: CustomArray = [1, \'a\', 3, \'b\']\nlet arr2: CustomArray = [\'x\', \'y\', 6, 7]\n```\n\n- 解释:\n  1. 使用 `type` 关键字来创建自定义类型\n  2. 类型别名（比如，此处的 *CustomArray*）可以是任意合法的变量名称\n  3. 推荐使用大写字母开头\n  4. 创建类型别名后，直接使用该类型别名作为变量的类型注解即可\n\n### 函数类型\n\n- 函数的类型实际上指的是：`函数参数`和`返回值`的类型\n- 为函数指定类型的两种方式：\n  1. 单独指定参数、返回值的类型\n  2. 同时指定参数、返回值的类型\n\n1. 单独指定参数、返回值的类型：\n\n```ts\n// 函数声明\nfunction add(num1: number, num2: number): number {\n  return num1 + num2\n}\n\n// 箭头函数\nconst add = (num1: number, num2: number): number => {\n  return num1 + num2\n}\n```\n\n2. 同时指定参数、返回值的类型:\n\n```ts\ntype AddFn = (num1: number, num2: number) => number\n\nconst add: AddFn = (num1, num2) => {\n  return num1 + num2\n}\n```\n\n- 解释：当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型\n- 注意：这种形式只适用于函数表达式\n\n#### void 类型\n\n- 如果函数没有返回值，那么，函数返回值类型为：`void`\n\n```ts\nfunction greet(name: string): void {\n  console.log(\'Hello\', name)\n}\n```\n\n- 注意：\n  - 如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 `void` 类型\n\n```ts\n// 如果什么都不写，此时，add 函数的返回值类型为： void\nconst add = () => {}\n// 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同\nconst add = (): void => {}\n\n// 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以\nconst add = (): undefined => {\n  // 此处，返回的 undefined 是 JS 中的一个值\n  return undefined\n}\n```\n\n#### 函数可选参数\n\n- 使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到**可选参数**了\n- 比如，数组的 slice 方法，可以 `slice()` 也可以 `slice(1)` 还可以 `slice(1, 3)`\n\n```ts\nfunction mySlice(start?: number, end?: number): void {\n  console.log(\'起始索引：\', start, \'结束索引：\', end)\n}\n```\n\n- 可选参数：在可传可不传的参数名称后面添加 `?`（问号）\n- 注意：**可选参数只能出现在参数列表的最后**，也就是说可选参数后面不能再出现必选参数\n\n### 对象类型\n\n- JS 中的对象是由属性和方法构成的，而 **TS 对象的类型就是在描述对象的结构**（有什么类型的属性和方法）\n- 对象类型的写法:\n\n```ts\n// 空对象\nlet person: {} = {}\n\n// 有属性的对象\nlet person: { name: string } = {\n  name: \'同学\'\n}\n\n// 既有属性又有方法的对象\n// 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔\nlet person: { name: string; sayHi(): void } = {\n  name: \'jack\',\n  sayHi() {}\n}\n\n// 对象中如果有多个类型，可以换行写：\n// 通过换行来分隔多个属性类型，可以去掉 `;`\nlet person: {\n  name: string\n  sayHi(): void\n} = {\n  name: \'jack\',\n  sayHi() {}\n}\n```\n\n- 解释:\n  1. 使用 `{}` 来描述对象结构\n  2. 属性采用`属性名: 类型`的形式\n  3. 方法采用`方法名(): 返回值类型`的形式\n\n#### 使用类型别名\n\n- 注意：直接使用 `{}` 形式为对象添加类型，会降低代码的可读性（不好辨识类型和值）\n- 推荐：**使用类型别名为对象添加类型**\n\n```ts\n// 创建类型别名\ntype Person = {\n  name: string\n  sayHi(): void\n}\n\n// 使用类型别名作为对象的类型：\nlet person: Person = {\n  name: \'jack\',\n  sayHi() {}\n}\n```\n\n#### 带有参数的方法类型\n\n- 如果方法有参数，就在方法名后面的小括号中指定参数类型\n\n```ts\ntype Person = {\n  greet(name: string): void\n}\n\nlet person: Person = {\n  greet(name) {\n    console.log(name)\n  }\n}\n```\n\n#### 箭头函数形式的方法类型\n\n- 方法的类型也可以使用箭头函数形式\n\n```ts\ntype Person = {\n  greet: (name: string) => void\n}\n\nlet person: Person = {\n  greet(name) {\n    console.log(name)\n  }\n}\n```\n\n#### 对象可选属性\n\n- 对象的属性或方法，也可以是可选的，此时就用到**可选属性**了\n- 比如，我们在使用 `axios({ ... })` 时，如果发送 GET 请求，method 属性就可以省略\n- 可选属性的语法与函数可选参数的语法一致，都使用 `?` 来表示\n\n```ts\ntype Config = {\n  url: string\n  method?: string\n}\n\nfunction myAxios(config: Config) {\n  console.log(config)\n}\n```\n\n### 接口\n\n当一个对象类型被多次使用时，一般会使用接口（`interface`）来描述对象的类型，达到复用的目的\n\n- 解释：\n  1. 使用 `interface` 关键字来声明接口\n  2. 接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 `I` 开头\n  3. 声明接口后，直接使用接口名称作为变量的类型\n  4. 因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号)\n\n```ts\ninterface IPerson {\n  name: string\n  age: number\n  sayHi(): void\n}\n\nlet person: IPerson = {\n  name: \'jack\',\n  age: 19,\n  sayHi() {}\n}\n```\n\n#### interface vs type\n\n- interface（接口）和 type（类型别名）的对比：\n- 相同点：都可以给对象指定类型\n- 不同点:\n  - 接口，只能为对象指定类型\n  - 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名\n- 推荐：**能使用 type 就是用 type**\n\n```ts\ninterface IPerson {\n  name: string\n  age: number\n  sayHi(): void\n}\n\n// 为对象类型创建类型别名\ntype IPerson = {\n  name: string\n  age: number\n  sayHi(): void\n}\n\n// 为联合类型创建类型别名\ntype NumStr = number | string\n```\n\n#### 接口继承\n\n- 如果两个接口之间有相同的属性或方法，可以将**公共的属性或方法抽离出来，通过继承来实现复用**\n- 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐\n\n```ts\ninterface Point2D { x: number; y: number }\ninterface Point3D { x: number; y: number; z: number }\n```\n\n- 更好的方式:\n\n```ts\ninterface Point2D { x: number; y: number }\n// 继承 Point2D\ninterface Point3D extends Point2D {\n  z: number\n}\n```\n\n- 解释：\n  1. 使用 `extends`(继承)关键字实现了接口 Point3D 继承 Point2D\n  2. 继承后，Point3D 就有了 Point2D 的所有属性和方法(此时，Point3D 同时有 x、y、z 三个属性)\n\n### 元组\n\n- 场景：在地图中，使用经纬度坐标来标记位置信息\n- 可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型 number[]\n\n```ts\nlet position: number[] = [116.2317, 39.5427]\n```\n\n- 使用 number[] 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字\n- 更好的方式：`元组 Tuple`\n- 元组类型是另一种类型的数组，它确切地知道包含多少个元素，**以及特定索引对应的类型**\n\n```ts\nlet position: [number, number] = [39.5427, 116.2317]\n```\n\n- 解释：\n  1. 元组类型可以确切地标记出有多少个元素，以及每个元素的类型\n  2. 该示例中，元素有两个元素，每个元素的类型都是 number\n\n---\n\n### 类型推论\n\n- 在 TS 中，某些没有明确指出类型的地方，**TS 的类型推论机制会帮助提供类型**\n- 换句话说：由于类型推论的存在，这些地方，类型注解可以省略不写\n- 发生类型推论的 2 种常见场景:\n  1. 声明变量并初始化时\n  2. 决定函数返回值时\n\n```ts\n// 变量 age 的类型被自动推断为：number\nlet age = 18\n\n// 函数返回值的类型被自动推断为：number\nfunction add(num1: number, num2: number) {\n  return num1 + num2\n}\n```\n\n- 推荐：**能省略类型注解的地方就省略**（~~偷懒~~，充分利用TS类型推论的能力，提升开发效率）\n- 技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型\n- 推荐：在 VSCode 中写代码的时候，多看方法、属性的类型，养成写代码看类型的习惯\n\n```\nconsole.log()\ndocument.createElement()\n```\n\n\n\n### 字面量类型\n\n- 思考以下代码，两个变量的类型分别是什么?\n\n```ts\nlet str1 = \'Hello TS\'\nconst str2 = \'Hello TS\'\n```\n\n- 通过 TS 类型推论机制，可以得到答案：\n  1. 变量 str1 的类型为：string\n  2.  变量 str2 的类型为：\'Hello TS\'\n\n- 解释:\n1. str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string\n2. str2 是一个常量(const)，它的值不能变化只能是 \'Hello TS\'，所以，它的类型为:\'Hello TS\'\n\n- 注意：此处的 \'Hello TS\'，就是一个**字面量类型**，也就是说某个特定的字符串也可以作为 TS 中的类型\n- 任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用\n  - 字面量：`{ name: \'jack\' }` `[]` `18` `20` `\'abc\'` `false` `function() {}`\n\n```jsx\nlet str1 = \'Hello TS\'\nconst str2 = \'Hello TS123\'\n\nstr1 = str2\n\n// str2 = str1 不行\n\n```\n\n\n\n#### 使用模式和场景\n\n- 使用模式：**字面量类型配合联合类型一起使用**\n- 使用场景：用来表示一组明确的可选值列表\n- 比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个\n\n```ts\n// 使用自定义类型:\ntype Direction = \'up\' | \'down\' | \'left\' | \'right\'\n\nfunction changeDirection(direction: Direction) {\n  console.log(direction)\n}\n\n// 调用函数时，会有类型提示：\nchangeDirection(\'up\')\n```\n\n- 解释：参数 direction 的值只能是 up/down/left/right 中的任意一个\n- 优势：相比于 string 类型，使用字面量类型更加精确、严谨\n\n### 【了解】枚举\n\n- 枚举的功能类似于**字面量类型+联合类型组合**的功能，也可以表示一组明确的可选值\n- 枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个\n\n```ts\n// 创建枚举\nenum Direction { Up, Down, Left, Right }\n\n// 使用枚举类型\nfunction changeDirection(direction: Direction) {\n  console.log(direction)\n}\n\n// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个\n// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员\nchangeDirection(Direction.Up)\n```\n\n- 解释:\n  1. 使用 `enum` 关键字定义枚举\n  2. 约定枚举名称以大写字母开头\n  3. 枚举中的多个值之间通过 `,`（逗号）分隔\n  4. 定义好枚举后，直接使用枚举名称作为类型注解\n\n#### 数字枚举\n\n- 问题：我们把枚举成员作为了函数的实参，它的值是什么呢?\n- 解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0\n- 注意：枚举成员是有值的，默认为：从 0 开始自增的数值\n- 我们把，枚举成员的值为数字的枚举，称为：`数字枚举`\n- 当然，也可以给枚举中的成员初始化值\n\n```ts\n// Down -> 11、Left -> 12、Right -> 13\nenum Direction { Up = 10, Down, Left, Right }\n\nenum Direction { Up = 2, Down = 4, Left = 8, Right = 16 }\n```\n\n#### 字符串枚举\n\n- 字符串枚举：枚举成员的值是字符串\n- 注意：字符串枚举没有自增长行为，因此，**字符串枚举的每个成员必须有初始值**\n\n```ts\nenum Direction {\n  Up = \'UP\',\n  Down = \'DOWN\',\n  Left = \'LEFT\',\n  Right = \'RIGHT\'\n}\n```\n\n#### 枚举实现原理\n\n- 枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一\n- 因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)\n- 也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，**枚举类型会被编译为 JS 代码**\n\n```ts\nenum Direction {\n  Up = \'UP\',\n  Down = \'DOWN\',\n  Left = \'LEFT\',\n  Right = \'RIGHT\'\n}\n\n// 会被编译为以下 JS 代码：\nvar Direction;\n\n(function (Direction) {\n  Direction[\'Up\'] = \'UP\'\n  Direction[\'Down\'] = \'DOWN\'\n  Direction[\'Left\'] = \'LEFT\'\n  Direction[\'Right\'] = \'RIGHT\'\n})(Direction || Direction = {})\n```\n\n- 说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表\n- 一般情况下，**推荐使用字面量类型+联合类型组合的方式**，因为相比枚举，这种方式更加直观、简洁、高效\n\n### any 类型\n\n- **原则:不推荐使用 any**!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)\n- 因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示\n\n```ts\nlet obj: any = { x: 0 }\n\nobj.bar = 100\nobj()\nconst n: number = obj\n```\n\n- 解释:以上操作都不会有任何类型错误提示，即使可能存在错误\n- 尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型\n- 其他隐式具有 any 类型的情况\n  1. 声明变量不提供类型也不提供默认值\n  2. 函数参数不加类型\n- 注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型\n\n在项目开发中，尽量少用any类型\n\n---\n\n### 类型断言\n\n有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，\n\n```ts\nconst aLink = document.getElementById(\'link\')\n```\n\n- 注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性\n- 因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法\n- 解决方式：这种情况下就需要**使用类型断言指定更加具体的类型**\n- 使用类型断言：\n\n```ts\nconst aLink = document.getElementById(\'link\') as HTMLAnchorElement\n```\n\n- 解释:\n  1. 使用 `as` 关键字实现类型断言\n  2. 关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）\n  3. 通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了\n\n- 另一种语法，使用 `<>` 语法，这种语法形式不常用知道即可:\n\n```ts\n// 该语法，知道即可：在react的jsx中使用会报错\nconst aLink = <HTMLAnchorElement>document.getElementById(\'link\')\n```\n\n*技巧：在浏览器控制台，通过 `__proto__` 获取 DOM 元素的类型*\n\n### typeof\n\n- 众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型\n\n```js\nconsole.log(typeof \'Hello world\') // ?\n```\n\n- 实际上，TS 也提供了 typeof 操作符：可以在*类型上下文*中引用变量或属性的类型（类型查询）\n- 使用场景:根据已有变量的值，获取该值的类型，来简化类型书写\n\n```ts\nlet p = { x: 1, y: 2 }\nfunction formatPoint(point: { x: number; y: number }) {}\nformatPoint(p)\n\nfunction formatPoint(point: typeof p) {}\n```\n\n- 解释:\n  1. 使用 `typeof` 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同\n  2. typeof 出现在**类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文**(区别于 JS 代码)\n  3. 注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）\n\n\n# TypeScript 高级类型\n\nTS 中的高级类型有很多，重点学习以下高级类型：\n\n1. 泛型 和 keyof\n2. 索引签名类型 和 索引查询类型\n3. 映射类型\n\n## 泛型\n\n- **泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用**，常用于：函数、接口、class 中\n- 需求：创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同)\n\n```ts\nfunction id(value: number): number { return value }\n```\n\n- 比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型\n- 为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全\n\n```ts\nfunction id(value: any): any { return value }\n```\n\n- **泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用**\n- 实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一\n\n### 创建泛型函数\n\n```ts\nfunction id<Type>(value: Type): Type { return value }\n\nfunction id<T>(value: T): T { return value }\n```\n\n- 解释:\n  1. 语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中添加类型变量**，比如此处的 Type\n  2. **类型变量 Type，是一种特殊类型的变量，它处理类型而不是值**\n  3. **该类型变量相当于一个类型容器**，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定)\n  4. 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型\n  5. 类型变量 Type，可以是任意合法的变量名称\n\n### 调用泛型函数\n\n```ts\nconst num = id<number>(10)\nconst str = id<string>(\'a\')\n```\n\n- 解释：\n  1. 语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中指定具体的类型**，比如，此处的 number\n  2. 当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到\n  3. 此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number\n\n- 同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string\n- 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，**实现了复用的同时保证了类型安全**\n\n### 简化泛型函数调用\n\n```ts\n// 省略 <number> 调用函数\nlet num = id(10)\nlet str = id(\'a\')\n```\n\n- 解释:\n  1. 在调用泛型函数时，**可以省略 `<类型>` 来简化泛型函数的调用**\n  2. 此时，TS 内部会采用一种叫做**类型参数推断**的机制，来根据传入的实参自动推断出类型变量 Type 的类型\n  3. 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型\n\n- 推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读\n- 说明：**当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数**\n\n### 泛型约束\n\n- 默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性\n- 比如，id(\'a\') 调用函数时获取参数的长度：\n\n```ts\nfunction id<Type>(value: Type): Type {\n  console.log(value.length)\n  return value\n}\n\nid(\'a\')\n```\n\n- 解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length\n- 此时，就需要**为泛型添加约束来`收缩类型`(缩窄类型取值范围)**\n- 添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型  2 添加约束\n\n#### 指定更加具体的类型\n\n比如，将类型修改为 `Type[]`(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了\n\n```ts\nfunction id<Type>(value: Type[]): Type[] {\n  console.log(value.length)\n  return value\n}\n```\n\n#### 添加约束\n\n```ts\n// 创建一个接口\ninterface ILength { length: number }\n\n// Type extends ILength 添加泛型约束\n// 解释：表示传入的 类型 必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性\nfunction id<Type extends ILength>(value: Type): Type {\n  console.log(value.length)\n  return value\n}\n```\n\n- 解释:\n  1. 创建描述约束的接口 ILength，该接口要求提供 length 属性\n  2. 通过 `extends` 关键字使用该接口，为泛型(类型变量)添加约束\n  3. 该约束表示：**传入的类型必须具有 length 属性**\n- 注意:传入的实参(比如，数组)只要有 length 属性即可（类型兼容性)\n\n### 多个类型变量\n\n泛型的类型变量可以有多个，并且**类型变量之间还可以约束**(比如，第二个类型变量受第一个类型变量约束)\n比如，创建一个函数来获取对象中属性的值：\n\n```ts\nfunction getProp<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key]\n}\nlet person = { name: \'jack\', age: 18 }\ngetProp(person, \'name\')\n```\n\n- 解释:\n  1. 添加了第二个类型变量 Key，两个类型变量之间使用 `,` 逗号分隔。\n  2. **keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型**。\n  3. 本示例中 `keyof Type` 实际上获取的是 person 对象所有键的联合类型，也就是：`\'name\' | \'age\'`\n  4. 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性\n\n```ts\n// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错\n// 如果要用到 对象 类型，应该用 object ，而不是 Object\nfunction getProperty<Type extends object, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key]\n}\n```\n\n---\n\n### 泛型接口\n\n泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性\n\n```ts\ninterface IdFunc<Type> {\n  id: (value: Type) => Type\n  ids: () => Type[]\n}\n\nlet obj: IdFunc<number> = {\n  id(value) { return value },\n  ids() { return [1, 3, 5] }\n}\n```\n\n- 解释:\n  1. 在接口名称的后面添加 `<类型变量>`，那么，这个接口就变成了泛型接口。\n  2. 接口的类型变量，对接口中所有其他成员可见，也就是**接口中所有成员都可以使用类型变量**。\n  3. 使用泛型接口时，**需要显式指定具体的类型**(比如，此处的 IdFunc<nunber>)。\n  4. 此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。\n\n#### JS 中的泛型接口\n\n实际上，JS 中的数组在 TS 中就是一个泛型接口。\n\n```ts\nconst strs = [\'a\', \'b\', \'c\']\n// 鼠标放在 forEach 上查看类型\nstrs.forEach\n\nconst nums = [1, 3, 5]\n// 鼠标放在 forEach 上查看类型\nnums.forEach\n```\n\n![image-20210917002203414](images/image-20210917002203414.png)\n\n- 解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型\n- 技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息\n\n### 泛型工具类型\n\n- 泛型工具类型:TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作\n- 说明:它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:\n\n1. `Partial<Type>`\n2. `Readonly<Type>`\n3. `Pick<Type, Keys>`\n4. `Omit<Type>`\n\n#### Partial\n\n- Partial<Type> 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。\n\n```ts\ntype Props =  {\n  id: string\n  children: number[]\n}\n\ntype PartialProps = Partial<Props>\n```\n\n- 解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。\n\n#### Readonly\n\n- Readonly<Type> 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。\n\n```ts\ntype Props =  {\n  id: string\n  children: number[]\n}\n\ntype ReadonlyProps = Readonly<Props>\n```\n\n- 解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。\n\n```ts\nlet props: ReadonlyProps = { id: \'1\', children: [] }\n// 错误演示\nprops.id = \'2\'\n```\n\n- 当我们想重新给 id 属性赋值时，就会报错:无法分配到 \"id\" ，因为它是只读属性。\n\n#### Pick\n\n- Pick<Type, Keys> 从 Type 中选择一组属性来构造新类型。\n\n```ts\ninterface Props {\n  id: string\n  title: string\n  children: number[]\n}\ntype PickProps = Pick<Props, \'id\' | \'title\'>\n```\n\n- 解释:\n  1. Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。 2. 其中第二个类型变量，如果只选择一个则只传入该属性名即可。\n  2. 第二个类型变量传入的属性只能是第一个类型变量中存在的属性。\n  3. 构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。\n\n#### Omit\n\nOmit<K,T>类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：\n\nK：是对象类型名称，T：是剔除K类型中的属性名称\n\n![image-20210917003456128](images/image-20210917003456128.png)\n\n\n\n\n\n\n\n\n\n## 索引签名类型\n\n绝大多数情况下，我们都可以在使用对象前就确定对象的结构，并为对象添加准确的类型。\n使用场景:**当无法确定对象中有哪些属性**(或者说对象中可以出现任意多个属性)，此时，就用到**索引签名类型**了。\n\n```ts\ninterface AnyObject {\n  [key: string]: number\n}\nlet obj: AnyObject = {\n  a: 1,\n  b: 2,\n}\n```\n\n- 解释:\n  1. 使用 `[key: string]` 来约束该接口中允许出现的属性名称。表示只要是 string 类型的属性名称，都可以出现在对象中。\n  2. 这样，对象 obj 中就可以出现任意多个属性(比如，a、b 等)。\n  3. `key 只是一个占位符`，可以换成任意合法的变量名称。\n  4. 隐藏的前置知识:`JS 中对象({})的键是 string 类型的`。\n\n### 数组索引类型签名\n\n- 在 JS 中数组是一类特殊的对象，特殊在数组的键(索引)是数值类型\n- 并且，数组也可以出现任意多个元素。所以，在数组对应的泛型接口中，也用到了索引签名类型。\n\n```ts\ninterface MyArray<T> {\n  [n: number]: T\n}\nlet arr: MyArray<number> = [1, 3, 5]\n```\n\n- 解释:\n    1. MyArray 接口模拟原生的数组接口，并使用 `[n: number]` 来作为索引签名类型。\n  2. 该索引签名类型表示:只要是 number 类型的键(索引)都可以出现在数组中，或者说数组中可以有任意多个元素。\n  3. 同时也符合数组索引是 number 类型这一前提。\n\n## 映射类型\n\n- 映射类型:**基于旧类型创建新类型(对象类型**)，减少重复、提升开发效率。\n比如，类型 PropKeys 有 x/y/z，另一个类型 Type1 中也有 x/y/z，并且 Type1 中 x/y/z 的类型相同:\n\n```ts\ntype PropKeys = \'x\' | \'y\' | \'z\'\ntype Type1 = { x: number; y: number; z: number }\n```\n\n- 这样书写没错，但 x/y/z 重复书写了两次。像这种情况，就可以使用映射类型来进行简化。\n\n```ts\ntype PropKeys = \'x\' | \'y\' | \'z\'\ntype Type2 = { [Key in PropKeys]: number }\n```\n\n- 解释:\n  1. 映射类型是基于索引签名类型的，所以，该语法类似于索引签名类型，也使用了 []。\n  2. `Key in PropKeys` 表示 Key 可以是 PropKeys 联合类型中的任意一个，类似于 forin(let k in obj)。\n  3. 使用映射类型创建的新对象类型 Type2 和类型 Type1 结构完全相同。\n  4. 注意:**映射类型只能在类型别名中使用，不能在接口中使用**。\n\n### 根据对象创建\n\n映射类型除了根据联合类型创建新类型外，还可以根据对象类型来创建:\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\ntype Type3 = { [key in keyof Props]: number }\n```\n\n- 解释:\n  1. 首先，先执行 `keyof Props` 获取到对象类型 Props 中所有键的联合类型即，\'a\' | \'b\' | \'c\'。\n  2. 然后，`Key in ...` 就表示 Key 可以是 Props 中所有的键名称中的任意一个。\n\n### 内置映射类型实现分析\n\n- 实际上，前面讲到的**泛型工具类型**(比如，Partial<Type>)都是基于映射类型实现的。 \n- 比如，Partial<Type> 的实现:\n\n```ts\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Props = { a: number; b: string; c: boolean }\ntype PartialProps = Partial<Props>\n```\n\n- 解释:\n  1. `keyof T` 即 keyof Props 表示获取 Props 的所有键，也就是:\'a\' | \'b\' | \'c\'。\n  2. 在 [] 后面添加 `?`(问号)，表示将这些属性变为`可选`的，以此来实现 Partial 的功能。\n  3. 冒号后面的 `T[P] 表示获取 T 中每个键对应的类型`。比如，如果是 \'a\' 则类型是 number;如果是 \'b\' 则类型是 string。\n  4. 最终，新类型 PartialProps 和旧类型 Props 结构完全相同，只是让所有类型都变为可选了。\n\n### 索引访问类型\n\n- 刚刚用到的 `T[P]` 语法，在 TS 中叫做`索引访问类型`\n- 作用:**用来查询属性的类型**。\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\ntype TypeA = Props[\'a\']\n```\n\n- 解释:`Props[\'a\']` 表示查询类型 Props 中属性 \'a\' 对应的类型 number。所以，TypeA 的类型为 number\n- 注意:**[] 中的属性必须存在于被查询类型中**，否则就会报错。\n\n#### 同时查询多个索引的类型\n\n- 索引查询类型的其他使用方式:同时查询多个索引的类型\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\n\ntype TypeA = Props[\'a\' | \'b\'] // string | number\n```\n\n- 解释:使用字符串字面量的联合类型，获取属性 a 和 b 对应的类型，结果为: string | number。\n\n```ts\ntype TypeA = Props[keyof Props] // string | number | boolean\n```\n\n- 解释:使用 keyof 操作符获取 Props 中所有键对应的类型，结果为: string | number | boolean。 \n\n\n\n# 在 React 项目中使用 TS\n\n1. 创建新项目\n2. 在现有项目中添加 TS\n\n## 创建新项目\n\n- 命令：`npx create-react-app my-app --template typescript`\n- 说明：在命令行中，添加 `--template typescript` 表示创建支持 TS 的项目\n\n- 项目目录的变化：\n  1. 在项目根目录中多了一个文件：`tsconfig.json`\n     - TS 的配置文件\n  2. 在 src 目录中，文件的后缀有变化，由原来的 .js 变为 `.ts` 或 `.tsx`\n     - `.ts` ts 文件的后缀名\n     - `.tsx` 是在 TS 中使用 React 组件时，需要使用该后缀\n  3. 在 src 目录中，多了 `react-app-env.d.ts` 文件\n     - `.d.ts` 类型声明文件，用来指定类型\n\n## tsconfig的介绍\n\n+ tsconfig.json是typescript项目的配置文件，用于配置typescript\n+ tsconfig.json配置文件可以通过 `tsc --init` 生成\n\n- 说明：所有的配置项都可以通过鼠标移入的方式，来查看配置项的解释说明。\n- [tsconfig 文档链接](https://www.typescriptlang.org/tsconfig)\n\n```json\n{\n  // 编译选项\n  \"compilerOptions\": {\n    // 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码\n    // 命令行： tsc --target es5 11-测试TS配置文件.ts\n    \"target\": \"es5\",\n    // 指定要包含在编译中的 library\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    // 允许 ts 编译器编译 js 文件\n    \"allowJs\": true,\n    // 跳过类型声明文件的类型检查\n    \"skipLibCheck\": true,\n    // es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异\n    \"esModuleInterop\": true,\n    // 允许通过 import x from \'y\' 即使模块没有显式指定 default 导出\n    \"allowSyntheticDefaultImports\": true,\n    // 开启严格模式\n    \"strict\": true,\n    // 对文件名称强制区分大小写\n    \"forceConsistentCasingInFileNames\": true,\n    // 为 switch 语句启用错误报告\n    \"noFallthroughCasesInSwitch\": true,\n    // 生成代码的模块化标准\n    \"module\": \"esnext\",\n    // 模块解析（查找）策略\n    \"moduleResolution\": \"node\",\n    // 允许导入扩展名为.json的模块\n    \"resolveJsonModule\": true,\n    // 是否将没有 import/export 的文件视为旧（全局而非模块化）脚本文件\n    \"isolatedModules\": true,\n    // 编译时不生成任何文件（只进行类型检查）\n    \"noEmit\": true,\n    // 指定将 JSX 编译成什么形式\n    \"jsx\": \"react-jsx\"\n  },\n  // 指定允许 ts 处理的目录\n  \"include\": [\"src\"]\n}\n```\n\n# typescript声明文件\n\n今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。\n\n这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。\n\n我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。 \n\n但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢? `类型声明文件`\n\n- **类型声明文件：用来为已存在的 JS 库提供类型信息**\n\n这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。\n\n1. TS 的两种文件类型\n2. 类型声明文件的使用说明\n\n## TS 中的两种文件类型\n\n- TS 中有两种文件类型：1 `.ts` 文件 2 `.d.ts` 文件\n- .ts 文件:\n  1. `既包含类型信息又可执行代码`\n  2. 可以被编译为 .js 文件，然后，执行代码\n  3. 用途：编写程序代码的地方\n- .d.ts 文件:\n  1. `只包含类型信息`的类型声明文件\n  2. **不会生成 .js 文件，仅用于提供类型信息,在.d.ts文件中不允许出现可执行的代码，只用于提供类型**\n  3. 用途：为 JS 提供类型信息\n\n- 总结：.ts 是 `implementation`(代码实现文件)；**.d.ts 是 declaration(类型声明文件)**\n- 如果要为 JS 库提供类型信息，要使用 `.d.ts` 文件\n\n## 类型声明文件的使用说明\n\n- 在使用 TS 开发项目时，类型声明文件的使用包括以下两种方式: \n  1. 使用已有的类型声明文件\n  2. 创建自己的类型声明文件\n\n使用已有的类型声明文件\n\n1. 内置类型声明文件\n2. 第三方库的类型声明文件\n3. 自己提供的\n\n## 内置类型声明文件\n\n- TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件\n- 比如，在使用数组时，数组所有方法都会有相应的代码提示以及类型信息:\n\n```ts\nconst strs = [\'a\', \'b\', \'c\']\n// 鼠标放在 forEach 上查看类型\nstrs.forEach\n```\n\n- 实际上这都是 TS 提供的内置类型声明文件\n- 可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看内置类型声明文件内容\n- 比如，查看 forEach 方法的类型声明，在 VSCode 中会自动跳转到 `lib.es5.d.ts` 类型声明文件中\n- 当然，像 window、document 等 BOM、DOM API 也都有相应的类型声明(`lib.dom.d.ts`)\n\n## 第三方库的类型声明文件 \n\n- 目前，几乎所有常用的第三方库都有相应的类型声明文件\n- 第三方库的类型声明文件有两种存在形式:1 库自带类型声明文件 2 由 DefinitelyTyped 提供。 \n\n1. 库自带类型声明文件：比如，axios\n\n  - 查看 `node_modules/axios` 目录\n\n解释：这种情况下，正常导入该库，**TS 就会自动加载库自己的类型声明文件**，以提供该库的类型声明。\n\n2. 由 DefinitelyTyped 提供\n\n- DefinitelyTyped 是一个 github 仓库，用来提供高质量 TypeScript 类型声明\n- [DefinitelyTyped 链接](https://github.com/DefinitelyTyped/DefinitelyTyped/)\n- 可以通过 npm/yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为:`@types/*`\n- 比如，@types/react、@types/lodash 等\n- 说明：在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示\n\n```ts\nimport _ from \'lodash\'\n\n// 在 VSCode 中，查看 \'lodash\' 前面的提示\n```\n\n- 解释：当安装 `@types/*` 类型声明包后，**TS 也会自动加载该类声明包**，以提供该库的类型声明\n- 补充：TS 官方文档提供了一个页面，可以来查询 @types/* 库\n- [@types/* 库](https://www.typescriptlang.org/dt)\n\n## 创建自己的类型声明文件\n\n1. 项目内共享类型\n2. 为已有 JS 文件提供类型声明\n\n### 项目内共享类型\n\n- 如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享。\n- 操作步骤:\n  1. 创建 index.d.ts 类型声明文件。\n  2. 创建需要共享的类型，并使用 export 导出(TS 中的类型也可以使用 import/export 实现模块化功能)。\n  3. 在需要使用共享类型的 .ts 文件中，通过 import 导入即可(.d.ts 后缀导入时，直接省略)。\n\n### 为已有 JS 文件提供类型声明\n\n1. 在将 JS 项目迁移到 TS 项目时，为了让已有的 .js 文件有类型声明。 \n2. 成为库作者，创建库给其他人使用。\n\n- 注意:类型声明文件的编写与模块化方式相关，不同的模块化方式有不同的写法。但由于历史原因，JS 模块化的发展 经历过多种变化(AMD、CommonJS、UMD、ESModule 等)，而 TS 支持各种模块化形式的类型声明。这就导致 ，类型声明文件相关内容又多又杂。\n- 演示:基于最新的 ESModule(import/export)来为已有 .js 文件，创建类型声明文件。 \n\n### 类型声明文件的使用说明\n\n- 说明:TS 项目中也可以使用 .js 文件。\n- 说明:在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明。\n- declare 关键字:用于类型声明，为其他地方(比如，.js 文件)已存在的变量声明类型，而不是创建一个新的变量。\n  1. 对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。\n  2. 对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指定此处用于类型声明。\n\n\n\n```jsx\nlet count = 10\nlet songName = \'痴心绝对\'\nlet position = {\n  x: 0,\n  y: 0\n}\n\nfunction add(x, y) {\n  return x + y\n}\n\nfunction changeDirection(direction) {\n  console.log(direction)\n}\n\nconst fomartPoint = point => {\n  console.log(\'当前坐标：\', point)\n}\n\nexport { count, songName, position, add, changeDirection, fomartPoint }\n\n```\n\n定义类型声明文件\n\n```jsx\ndeclare let count:number\n\ndeclare let songName: string\n\ninterface Position {\n  x: number,\n  y: number\n}\n\ndeclare let position: Position\n\ndeclare function add (x :number, y: number) : number\n\ntype Direction = \'left\' | \'right\' | \'top\' | \'bottom\'\n\ndeclare function changeDirection (direction: Direction): void\n\ntype FomartPoint = (point: Position) => void\n\ndeclare const fomartPoint: FomartPoint\n\nexport {\n  count, songName, position, add, changeDirection, FomartPoint, fomartPoint\n}\n```\n\n\n\n# 在现有项目中添加 TS\n\n- [CRA 添加 ts 文档](https://create-react-app.dev/docs/adding-typescript)\n- 如果要在现有的 JS 项目中，添加 TS，需要以下操作：\n\n1. 安装包：`yarn add typescript @types/node @types/react @types/react-dom @types/jest`\n2. 把 `jsconfig.json`改成 path.tsconfig.json\n4. 将原来通过 React 脚手架创建的 TS 项目中的 tsconfig.json 中的配置，拷贝到咱们自己的项目中\n5. 创建 `path.tsconfig.json` 文件，将原来 `jsconfig.json` 文件中的内容拿过来\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@scss/*\": [\"src/assets/styles/*\"]\n    }\n  }\n}\n\n```\n\n5. 在 `tsconfig.json` 中，添加以下配置：\n\n```json\n{\n  // 添加这一句\n  \"extends\": \"./path.tsconfig.json\",\n\n  \"compilerOptions\": {\n    ...\n  }\n}\n```\n\n6. 将通过 React 脚手架创建的 TS 项目中的 `src/react-app-env.d.ts` 拷贝到咱们自己项目的 src 目录下\n7. 重启项目\n\n## 说明\n\n1. 项目中使用 TS 时，既可以包含 js 文件，又可以包含 ts 文件\n  - `.js`、`.jsx`（使用 JS 时，React 组件对应的文件后缀）\n  - `.ts`、`.tsx`（使用 TS 时，React 组件对应的文件后缀）、`.d.ts`\n2. 在已有项目中，添加 TS 时的推荐模式\n  - 新的功能用 TS\n  - 已实现的功能，可以继续保持 JS 文件，慢慢修改为 TS 即可\n3. React 组件对应的文件后缀，修改为：`.tsx`\n4. 工具函数对应的文件后缀，修改为：`.ts` 或者为其添加类型声明文件 `.d.ts`\n\n\n\n# 项目改造\n\n## 改造建议\n\n1. 项目中使用 TS 时，既可以包含 js 文件，又可以包含 ts 文件\n\n  - `.js`、`.jsx`（使用 JS 时，React 组件对应的文件后缀）\n  - `.ts`、`.tsx`（使用 TS 时，React 组件对应的文件后缀）、`.d.ts`\n\n2. 在已有项目中，添加 TS 时的推荐模式\n\n  - 新的功能用 TS\n  - 已实现的功能，可以继续保持 JS 文件，慢慢修改为 TS 即可\n\n3. React 组件对应的文件后缀，修改为：`.tsx`\n4. 工具函数对应的文件后缀，修改为：`.ts` 或者为其添加类型声明文件 `.d.ts`\n\n## 修改入口文件\n\n### index.ts\n\n- 直接将文件后缀修改为 index.tsx 即可\n- 需要重启项目\n\n## 修改App.js\n\n+ 讲App.js 改成app.tsx即可\n+ 需要安装react-router-dom的类型\n\n```tsx\nyarn add @types/react-router-dom\n```\n\n+ 重启\n\n# utils工具函数改造\n\n## history.js\n\n不需要改造，直接把js改成ts即可\n\n## storage.js\n\n+ 讲js改成ts\n+ 修改getTokenInfo\n\n```jsx\n/**\n * 从本地缓存中获取 Token 信息\n * JSON.parse() 要求参数必须是字符串\n * localStorage.getItem() 返回值可能是字符串，也可能是null，所以会报错\n */\nexport const getTokenInfo = () => {\n  return JSON.parse(localStorage.getItem(TOKEN_KEY) || \'{}\')\n}\n```\n\n### 非空断言\n\n[Non-null assertion operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator)\n\n- TS 中提供一个运算符：`!` `非空断言`\n  - 如果一个值，它的类型可能是 null 或 undefined，但是，我们在使用时又很确定它的值一定不是 null 或 unde，此时，就可以通过 `非空断言` 来告诉 TS 听哥的，哥很确定它的不是 null 或 undefined\n- 注意：**这个操作是风险的**，非空断言，仅仅是让 TS 中的类型检查不再校验 null 或 undefined，但是，如果它的值真的是 null 或 undefined，代码会在运行时报错！！！\n\n### 整体修改\n\n```jsx\n// 用户 Token 的本地缓存键名\nconst TOKEN_KEY = \'geek-itcast-21\'\nconst CHANNEL_KEY = \'geek-itcast-21-channels\'\ntype Token = {\n  token: string\n  refresh_token: string\n}\ntype Channels = {\n  id: number\n  name: string\n}[]\n/**\n * 从本地缓存中获取 Token 信息\n * JSON.parse() 要求参数必须是字符串\n * localStorage.getItem() 返回值可能是字符串，也可能是null，所以会报错\n */\nexport const getTokenInfo = (): Token => {\n  return JSON.parse(localStorage.getItem(TOKEN_KEY)!) || {}\n}\n\n/**\n * 将 Token 信息存入缓存\n * @param {Object} tokenInfo 从后端获取到的 Token 信息\n */\nexport const setTokenInfo = (tokenInfo: Token): void => {\n  localStorage.setItem(TOKEN_KEY, JSON.stringify(tokenInfo))\n}\n\n/**\n * 删除本地缓存中的 Token 信息\n */\nexport const removeTokenInfo = () => {\n  localStorage.removeItem(TOKEN_KEY)\n}\n\n/**\n * 判断本地缓存中是否存在 Token 信息\n */\nexport const hasToken = (): boolean => {\n  return !!getTokenInfo().token\n}\n\n/**\n * 保存频道数据到本地\n * @param {*} channels\n */\nexport const setLocalChannels = (channels: Channels): void => {\n  localStorage.setItem(CHANNEL_KEY, JSON.stringify(channels))\n}\n\n/**\n * 获取本地的频道数据，，，，，，，如果没有数据，不要默认为空数组\n * @returns\n */\nexport const getLocalChannels = (): Channels => {\n  return JSON.parse(localStorage.getItem(CHANNEL_KEY)!)\n}\n\n/**\n * 删除本地的频道数据\n */\nexport const removeLocalChannels = (): void => {\n  localStorage.removeItem(CHANNEL_KEY)\n}\n\n```\n\n## request.js改造\n\n讲js改成ts即可\n\n```tsx\nasync (err: AxiosError<{ message: string }>) => {\n    // 如果因为网络原因，response没有，给提示消息\n    if (!err.response) {\n      Toast.info(\'网络繁忙，请稍后重试\')\n      return Promise.reject(err)\n    }\n\n```\n\n\n\n# 通用组件改造\n\n## Icon组件修改\n\n```jsx\nimport React from \'react\'\nimport classNames from \'classnames\'\n\ntype Props = {\n  type: string\n  className?: string\n  onClick?: () => void\n}\nfunction Icon({ type, className, ...rest }: Props) {\n  return (\n    <svg {...rest} className={classNames(\'icon\', className)} aria-hidden=\"true\">\n      <use xlinkHref={`#${type}`}></use>\n    </svg>\n  )\n}\n\nexport default Icon\n\n```\n\n## typescript中ref的使用\n\n```jsx\nconst imgRef = useRef<HTMLImageElement>(null)\n\nconst current = imgRef.current!\n```\n\n## Img懒加载组件修改\n\n```jsx\nimport classnames from \'classnames\'\nimport { useEffect, useRef, useState } from \'react\'\nimport Icon from \'../Icon\'\nimport styles from \'./index.module.scss\'\ntype Props = {\n  src: string\n  className?: string\n  alt?: string\n}\nconst Image = ({ className, src, alt }: Props) => {\n  const imgRef = useRef<HTMLImageElement>(null)\n  // 控制是否在加载\n  const [loading, setLoading] = useState(true)\n  // 控制是否加载失败\n  const [error, setError] = useState(false)\n\n  // 加载成功\n  const onLoad = () => {\n    setError(false)\n    setLoading(false)\n  }\n  const onError = () => {\n    setLoading(false)\n    setError(true)\n  }\n  useEffect(() => {\n    // 监听图片\n    const observer = new IntersectionObserver(([{ isIntersecting }]) => {\n      if (isIntersecting) {\n        // 图片在可视区\n        const current = imgRef.current!\n        current.src = current.dataset.src!\n        // 取消监听\n        observer.unobserve(current)\n      }\n    })\n    observer.observe(imgRef.current!)\n  }, [])\n  return (\n    <div className={classnames(styles.root, className)}>\n      {/* 加载中 */}\n      {loading && (\n        <div className=\"image-icon\">\n          <Icon type=\"iconphoto\" />\n        </div>\n      )}\n\n      {/* 加载出错时显示的内容 */}\n      {error && (\n        <div className=\"image-icon\">\n          <Icon type=\"iconphoto-fail\" />\n        </div>\n      )}\n\n      <img\n        alt={alt}\n        ref={imgRef}\n        data-src={src}\n        onLoad={onLoad}\n        onError={onError}\n      />\n    </div>\n  )\n}\n\nexport default Image\n\n```\n\n## Input组件修改\n\n+ 基本改造\n\n```jsx\nimport React, { useEffect, useRef } from \'react\'\nimport styles from \'./index.module.scss\'\nimport classNames from \'classnames\'\ninterface Props {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n}\nexport default function Input({\n  extra,\n  onExtraClick,\n  className,\n  autoFocus,\n  ...rest\n}: Props) {\n  // focus\n  const inputRef = useRef<HTMLInputElement>(null)\n  useEffect(() => {\n    if (autoFocus) {\n      inputRef.current?.focus()\n    }\n  }, [autoFocus])\n  return (\n    <div className={styles.root}>\n      <input\n        ref={inputRef}\n        className={classNames(\'input\', className)}\n        {...rest}\n      />\n      {extra ? (\n        <div className=\"extra\" onClick={onExtraClick}>\n          {extra}\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\n```\n\n+ 剩余参数的支持\n\n> InputHTMLAttributes中包含了Input框所有能够支持的属性\n\n```jsx\ninterface Props extends InputHTMLAttributes<HTMLInputElement> {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n}\n```\n\n+ 使用type替代interface\n\n```jsx\ntype Props = {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n  type?: \'input\' | \'password\'\n} & InputHTMLAttributes<HTMLInputElement>\n```\n\nTS 中的 &（交叉类型）\n\nhttps://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types\n\n- 交叉类型：`&`\n  - 作用：可以理解为取多个类型的并集\n- 联想到了，另一个类型：`|` 联合类型\n\n```ts\n// | 在 TS 中表示： number 和 string 两者中出现哪一个都行\ntype NumStr = number | string\n\ntype InputProps = {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  dom?: React.RefObject<HTMLInputElement>\n}\n\n// & 在 TS 中表示： 最终的类型两者都有\ntype Props = InputProps & InputHTMLAttributes<HTMLInputElement>\n```\n\n交叉类型需要注意的地方：同名的属性容易冲突\n\n使用omit优化\n\n```tsx\ntype Props = Omit<\n  InputHTMLAttributes<HTMLInputElement>,\n  \'type\' | \'autoFocus\'\n> & {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n  type?: \'text\' | \'password\'\n}\n```\n\n## Textarea组件改造\n\n```jsx\nimport classNames from \'classnames\'\nimport { TextareaHTMLAttributes } from \'hoist-non-react-statics/node_modules/@types/react\'\nimport React, { useEffect, useRef, useState } from \'react\'\nimport styles from \'./index.module.scss\'\ntype Props = Omit<\n  TextareaHTMLAttributes<HTMLTextAreaElement>,\n  \'maxLength\' | \'value\' | \'onChange\'\n> & {\n  maxLength?: number\n  className?: string\n  value: string\n  onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\nexport default function Textarea({\n  maxLength = 100,\n  className,\n  value,\n  onChange,\n  ...rest\n}: Props) {\n  const [content, setContent] = useState(value || \'\')\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setContent(e.target.value)\n\n    onChange && onChange(e)\n  }\n  const textRef = useRef<HTMLTextAreaElement>(null)\n  useEffect(() => {\n    textRef.current!.focus()\n    textRef.current!.setSelectionRange(-1, -1)\n  }, [])\n  return (\n    <div className={styles.root}>\n      {/* 文本输入框 */}\n      <textarea\n        {...rest}\n        className={classNames(\'textarea\', className)}\n        maxLength={maxLength}\n        value={value}\n        onChange={handleChange}\n        ref={textRef}\n      />\n\n      {/* 当前字数/最大允许字数 */}\n      <div className=\"count\">\n        {content.length}/{maxLength}\n      </div>\n    </div>\n  )\n}\n\n```\n\n## NavBar组件改造\n\n```jsx\nimport Icon from \'@/components/Icon\'\nimport styles from \'./index.module.scss\'\nimport { useHistory } from \'react-router\'\nimport classNames from \'classnames\'\nimport { ReactNode } from \'react\'\n// import { withRouter } from \'react-router-dom\'\n// 1. withRouter的使用\n// history match location: 这个组件必须是通过路由配置的  <Route></Route>\n// 自己渲染的组件，无法获取到路由信息  <NavBar></NavBar>\n\n// 2. 路由提供了几个和路由相关的hook\n// useHistory  useLocation  useParams\ntype Props = {\n  children: string | ReactNode\n  extra?: string\n  onLeftClick?: () => void\n  className?: string\n}\nfunction NavBar({ children, extra, onLeftClick, className }: Props) {\n  const history = useHistory()\n  const back = () => {\n    console.log(\'123\')\n    // 跳回上一页\n    if (onLeftClick) {\n      onLeftClick()\n    } else {\n      history.go(-1)\n    }\n  }\n  return (\n    <div className={classNames(styles.root, className)}>\n      {/* 后退按钮 */}\n      <div className=\"left\">\n        <Icon type=\"iconfanhui\" onClick={back} />\n      </div>\n      {/* 居中标题 */}\n      <div className=\"title\">{children}</div>\n\n      {/* 右侧内容 */}\n      <div className=\"right\">{extra}</div>\n    </div>\n  )\n}\n\nexport default NavBar\n\n```\n\n## AuthRoute组件改造\n\nhttps://stackoverflow.com/questions/53104165/implement-react-router-privateroute-in-typescript-project/53111155#\n\n```jsx\nimport { hasToken } from \'@/utils/storage\'\nimport { Route, Redirect, useLocation, RouteProps } from \'react-router-dom\'\ninterface PrivateRouteProps extends RouteProps {\n  component: React.ComponentType<any>\n}\nexport default function AuthRoute(props: PrivateRouteProps) {\n  const { component: Component, ...rest } = props\n  const location = useLocation()\n  // console.log(location)\n  return (\n    <Route\n      {...rest}\n      render={() => {\n        if (hasToken()) {\n          return <Component></Component>\n        } else {\n          return (\n            <Redirect\n              to={{\n                pathname: \'/login\',\n                state: {\n                  // 从哪儿来的\n                  from: location.pathname,\n                },\n              }}\n            ></Redirect>\n          )\n        }\n      }}\n    ></Route>\n  )\n}\n\n```\n\n# 页面改造\n\n## Layout组件\n\n直接把js改成tsx\n\n# Login组件\n\n### location的处理\n\n![image-20210917205318957](images/image-20210917205318957.png)\n\n+ 关于useLocation的使用\n\n```jsx\ntype LocationState = {\n  from: string\n}\n\nconst location = useLocation<LocationState>()\n```\n\nhttps://stackoverflow.com/questions/61668623/react-typescript-correct-type-for-uselocation-from-react-router-dom\n\n### redux-action修改\n\n+ 修改action/login.js\n\n```jsx\nimport request from \'@/utils/request\'\nimport { setTokenInfo, removeTokenInfo } from \'@/utils/storage\'\nimport { Dispatch } from \'redux\'\ntype Token = {\n  token: string\n  refresh_token: string\n}\nexport const sendCode = (mobile: string) => {\n  return async () => {\n    // 发送请求\n    await request({\n      url: \'/sms/codes/\' + mobile,\n      method: \'get\',\n    })\n  }\n}\n\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n\n/**\n * 登录功能\n * @param {*} data\n * @returns\n */\n\nexport const login = (data: { mobile: string; code: string }) => {\n  return async (dispatch: Dispatch) => {\n    const res = await request({\n      method: \'post\',\n      url: \'/authorizations\',\n      data,\n    })\n    // 保存token到redux中\n    dispatch(saveToken(res.data))\n    // 保存到本地\n    setTokenInfo(res.data)\n  }\n}\n\n/**\n * 退出\n * @returns\n */\nexport const logout = () => {\n  return (dispatch: Dispatch) => {\n    removeTokenInfo()\n    dispatch({\n      type: \'login/logout\',\n    })\n  }\n}\n\n```\n\n+ Dispatch的分析\n\n索引签名\n\n- [索引签名](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)\n- 语法：`[key: string]: any`\n- 应用场景：我要使用一个对象类型，但是，我不确定对象中有什么属性，此时，就可以使用索引签名类型了\n\n```ts\n// 可以将这个内容分为两部分，\n//  冒号前面 `[extraProps: string]` 表示对象中的属性类型 - 键\n//  冒号后面 `any` 表示属性值的类型 - 值\n\n// [extraProps: string] 表示：\n//  extraProps 是一个任意合法属性名称，比如，可以叫：k 或 key\n//  : string 表示对象属性的类型是 字符串 类型\n\n// 注意：一个对象，它的属性类型可以是： string | number | symbol\ninterface AnyAction {\n  [extraProps: string]: any\n}\n\nexport interface AnyAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: any\n}\n```\n\n\n\n### redux-reducer修改\n\n```jsx\ntype Token = {\n  token: string\n  refresh_token: string\n}\ntype ActionType = {\n  type: \'login/token\' | \'login/logout\'\n  payload: Token\n}\nconst initValue: Token = {\n  token: \'\',\n  refresh_token: \'\',\n}\nexport default function reducer(state = initValue, action: ActionType) {\n  const { type, payload } = action\n  if (type === \'login/token\') {\n    return payload\n  }\n  if (type === \'login/logout\') {\n    return {}\n  }\n  return state\n}\n```\n\n### 类型提取\n\n+ types.d.ts\n\n```jsx\n/**\n * token的类型\n */\nexport type Token = {\n  token: string\n  refresh_token: string\n}\n\n```\n\n\n\n\n\n# Profile组件改造\n\n## 修改redux-reducer\n\n```jsx\ntype User = {\n  id: string\n  name: string\n  photo: string\n  art_count: number\n  follow_count: number\n  fans_count: number\n  like_count: number\n}\n\ntype Profile = {\n  id: string\n  photo: string\n  name: string\n  mobile: string\n  gender: number\n  birthday: string\n}\n\ntype InitType = {\n  user: User\n  profile: Profile\n}\n\ntype ProfileAction =\n  | {\n      type: \'profile/user\'\n      payload: User\n    }\n  | {\n      type: \'profile/profile\'\n      payload: Profile\n    }\n\nconst initValue: InitType = {\n  user: {},\n  profile: {},\n} as InitType\n\n/**\n * 处理个人信息的reducer\n * @param {*} state\n * @param {*} action\n * @returns\n */\nexport default function reducer(state = initValue, action: ProfileAction) {\n  // const { type, payload } = action\n  if (action.type === \'profile/user\') {\n    return {\n      ...state,\n      user: action.payload,\n    }\n  }\n  if (action.type === \'profile/profile\') {\n    return {\n      ...state,\n      profile: action.payload,\n    }\n  }\n  return state\n}\n\n```\n\n\n\n## 修改redux-action的修改\n\n```jsx\nimport http from \'@/utils/request\'\nimport { User, Profile, ProfileAction } from \'../reducers/profile\'\nimport { Dispatch } from \'redux\'\n/**\n * 保存用户信息\n * @param {*} payload\n * @returns\n */\n// actionCreator: 创建action  必须要符合 ProfileAction类型\nexport const saveUser = (payload: User): ProfileAction => {\n  return {\n    type: \'profile/user\',\n    payload: payload,\n  }\n}\n\n/**\n * 获取用户信息\n * @returns Promise\n */\nexport const getUser = () => {\n  return async (dispatch: Dispatch) => {\n    const res = await http.get(\'/user\')\n    dispatch(saveUser(res.data))\n  }\n}\n\nexport const saveProfile = (payload: Profile): ProfileAction => {\n  return {\n    type: \'profile/profile\',\n    payload,\n  }\n}\n\nexport const getProfile = () => {\n  return async (dispatch: Dispatch) => {\n    const res = await http.get(\'/user/profile\')\n    dispatch(saveProfile(res.data))\n  }\n}\n\n// 返回一个全部属性变成可选的类型\ntype PartialProfile = Partial<Profile>\n// 修改用户的信息\n// dispatch: Dispatch类型，，，参数必须符合Action类型 {type: T}\nexport const updateProfile = (data: PartialProfile) => {\n  return async (dispatch: any) => {\n    await http.patch(\'/user/profile\', data)\n    dispatch(getProfile())\n  }\n}\n\nexport const updatePhoto = (fd: FormData) => {\n  return async (dispatch: any) => {\n    await http.patch(\'/user/photo\', fd)\n    dispatch(getProfile())\n  }\n}\n\n```\n\n\n\n## 泛型工具类型 - ReturnType\n\nhttps://stackoverflow.com/questions/57472105/react-redux-useselector-typescript-type-for-state/57472389\n\n- 泛型：\n\n```ts\nfunction id<Type>(value: Type): Type {\n  return value\n}\n\n// 尖括号中出现的是 类型\nid<number>(1)\nid<string>(1)\n```\n\n- ReturnType\n  - 作用：**用来获取函数返回值的类型**\n\n```ts\nconst fn = () => 10\n\n// typeof fn 的结果： () => number\n// R1 => number\ntype R1 = ReturnType<typeof fn>\n// type R1 = ReturnType<() => number>\n```\n\n## 获取redux状态的类型\n\nhttps://redux.js.org/usage/usage-with-typescript\n\n+ 讲store/index.js修改为store/index.ts\n\n```jsx\n// 参数1：reducer\n// 参数2：指定store的初始值\n// 参数3：指定中间件\nconst store = createStore(\n  reducer,\n  {\n    login: getTokenInfo(),\n  },\n  composeWithDevTools(applyMiddleware(thunk))\n)\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n## useSelector 的类型\n\n```ts\n// 在 TS 中 useSelector 是一个泛型函数，并且它有两个泛型变量，分别是：\n// 1 整个Redux应用的状态类型\n// 2 当前要获取的状态类型\n// 因此，在使用的时候，需要传入两个 泛型变量：\n// 比如，以下代码中，\n// 第一个传入了 AppState 也就是整个 Redux 应用的状态类型\n// 第二个传入了 AppState[\'profile\'] 也就是当前要获取的 profile 状态的类型\n\nconst user = useSelector<RootState, RootState[\'profile\'][\'user\']>(\n  (state) => state.profile.user\n)\n\n\n// 泛型参数1：指定state的类型\n// 泛型参数2：指定返回值的类型\nconst user = useSelector((state: RootState) => state.profile.user)\n```\n\n\n\n## TS 中的索引查询类型\n\n- 语法：`对象类型[键]`\n- 作用：查询 对象类型 中某个属性对应的类型\n\n```ts\ntype A = {\n  name: string\n}\n\n// NameType => string\ntype NameTyep = A[\'name\']\n```\n\n\n\n# Home组件的修改\n\n## 修改home组件-reducer\n\n```jsx\nimport {\n  SAVE_ALL_CHANNELS,\n  SAVE_ARTICLE_LIST,\n  SAVE_CHANNELS,\n  SAVE_MORE_ARTICLE_LIST,\n} from \'../action_types/home\'\n\ntype Channel = {\n  id: number\n  name: string\n}\n\ntype MoreAction = {\n  visible: boolean\n  articleId: string\n  channelId: string\n}\n\ntype Ariticle = {\n  art_id: string\n  title: string\n  aut_id: string\n  aut_name: string\n  comm_count: string\n  pubdate: string\n  cover: {\n    type: string\n    images: string[]\n  }\n}\n\ntype Articles = {\n  [index: number]: {\n    timestamp: string\n    list: Ariticle[]\n  }\n}\ntype HomeType = {\n  userChannels: Channel[]\n  allChannels: Channel[]\n  moreAction: MoreAction\n  articles: Articles\n}\n\nconst initValue: HomeType = {\n  userChannels: [],\n  allChannels: [],\n  // 存储所有的文章列表\n  articles: {},\n  moreAction: {\n    visible: false,\n    articleId: \'\',\n    channelId: \'\',\n  },\n} as HomeType\nexport default function reducer(state = initValue, action) {}\n```\n\n## 修改home组件-reducer的修改-完成\n\n```jsx\nimport {\n  SAVE_ALL_CHANNELS,\n  SAVE_ARTICLE_LIST,\n  SAVE_CHANNELS,\n  SAVE_MORE_ARTICLE_LIST,\n} from \'../action_types/home\'\n\ntype Channel = {\n  id: number\n  name: string\n}\n\ntype MoreAction = {\n  visible: boolean\n  articleId: string\n  channelId: number\n}\n\ntype Ariticle = {\n  art_id: string\n  title: string\n  aut_id: string\n  aut_name: string\n  comm_count: string\n  pubdate: string\n  cover: {\n    type: string\n    images: string[]\n  }\n}\n\ntype Articles = {\n  [index: number]: {\n    timestamp: string\n    list: Ariticle[]\n  }\n}\ntype HomeType = {\n  userChannels: Channel[]\n  allChannels: Channel[]\n  moreAction: MoreAction\n  articles: Articles\n}\n\nconst initValue: HomeType = {\n  userChannels: [],\n  allChannels: [],\n  // 存储所有的文章列表\n  articles: {},\n  moreAction: {\n    visible: false,\n    articleId: \'\',\n    channelId: -1,\n  },\n} as HomeType\n\ntype ActionType =\n  | {\n      type: \'home/saveChannels\'\n      payload: Channel[]\n    }\n  | {\n      type: \'home/saveAllChannels\'\n      payload: Channel[]\n    }\n  | {\n      type: \'home/saveArticleList\'\n      payload: {\n        channelId: number\n        timestamp: string\n        list: Ariticle[]\n      }\n    }\n  | {\n      type: \'home/saveMoreArticleList\'\n      payload: {\n        channelId: number\n        timestamp: string\n        list: Ariticle[]\n      }\n    }\n  | {\n      type: \'home/setMoreAction\'\n      payload: MoreAction\n    }\nexport default function reducer(state = initValue, action: ActionType) {\n  // const { type, payload } = action\n  switch (action.type) {\n    case \'home/saveChannels\':\n      return {\n        ...state,\n        userChannels: action.payload,\n      }\n    case \'home/saveAllChannels\':\n      return {\n        ...state,\n        allChannels: action.payload,\n      }\n    case \'home/saveArticleList\':\n      const { list, timestamp, channelId } = action.payload\n\n      return {\n        ...state,\n        articles: {\n          ...state.articles,\n          [channelId]: {\n            timestamp: timestamp,\n            // 如果是loadMore，追加数据，否则，覆盖数据\n            list: list,\n          },\n        },\n      }\n    case \'home/saveMoreArticleList\':\n      // const oldList = state.articles[action.payload.channelId].list\n      return {\n        ...state,\n        articles: {\n          ...state.articles,\n          [action.payload.channelId]: {\n            timestamp: action.payload.timestamp,\n            list: [\n              ...state.articles[action.payload.channelId].list,\n              ...action.payload.list,\n            ],\n          },\n        },\n      }\n    case \'home/setMoreAction\': {\n      return {\n        ...state,\n        moreAction: action.payload,\n      }\n    }\n    default:\n      return state\n  }\n}\n\n```\n\n## 解决问题：request中dispatch的问题\n\n原因： saveToken没有指定返回值类型，\n\n```jsx\n\n// actionCreator\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n```\n\n把type推断为string类型   string类型无法常量类型赋值，所以报错了\n\n解决方案：\n\n```js\n// actionCreator\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\' as const,\n    payload,\n  }\n}\n```\n\n方案2：\n\n```jsx\n// actionCreator\nexport const saveToken = (payload: Token): LoginAction => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n\n```\n\n## 解决问题：logout的错误\n\n原因：store.dispatch的参数必须是一个对象，且要有type属性\n\n```jsx\n/**\n * 退出\n * @returns\n */\nexport const logout = (payload: Token) => {\n  return {\n    type: \'login/logout\' as const,\n    payload,\n  }\n}\n\n\n// 移除本地的token\nremoveTokenInfo()\nstore.dispatch(\n  logout({\n    token: \'\',\n    refresh_token: \'\',\n  })\n)\n```\n\n## RootThunkAction的使用\n\nhttps://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks\n\n场景：\n\n 我们如果需要使用redux-thunk的action，需要指定两个参数的类型，dispatch和getState的类型。\n\nredux-thunk中间件帮助我们提供了一个thunkAction的类型。\n\n```jsx\n// 获取RootState的类型‘\n// typeof: 获取store.getState的类型\n// ReturnType 获取返回值的类型\nexport type RootState = ReturnType<typeof store.getState>\n\n// R：thunk的action的返回类型  void Promise<void>\n// S: 需要指定个getState的返回类型  RootState\n// E: extra: 额外的参数 any\n// A: 需要指定Action的类型 Action AnyAction [extraProps: string]: any\n// ThunkAction<R, S, E, A>\nexport type RootThunkAction = ThunkAction<\n  Promise<void>,\n  RootState,\n  unknown,\n  AnyAction\n>\n\n```\n\n\n\n以后，只要是redux-thunk的action的类型，我们只需要指定返回类型为RootThunkAction类型即可，不需要指定dispatch和getState的类型\n\n```jsx\n/**\n * 获取用户的频道\n * @returns\n */\nexport const getUserChannels = (): RootThunkAction => {\n  return async (dispatch) => {\n    // 1. 判断用户是否登录\n    if (hasToken()) {\n      const res = await request.get(\'/user/channels\')\n      dispatch(saveUserChannels(res.data.channels))\n    } else {\n      // 2. 没有token,从本地获取频道数据\n      const channels = getLocalChannels()\n      if (channels) {\n        // 没有token，但本地有channels数据\n        dispatch(saveUserChannels(channels))\n      } else {\n        // 没有token, 且本地没有channels数据\n        const res = await request.get(\'/user/channels\')\n        dispatch(saveUserChannels(res.data.channels))\n        // 保存到本地\n        setLocalChannels(res.data.channels)\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n');
INSERT INTO `t_article_content` VALUES (7, 7, '# 极客园PC\n\n## 项目介绍\n\n### 资料\n\n- 短信接收&M端演示：http://geek.itheima.net/\n- PC 端接口文档：http://geek.itheima.net/api-pc.html\n\n### 项目介绍\n\n>「极客园」对标`CSDN`、`博客园`等竞品，致力成为更加贴近年轻 IT 从业者（学员）的科技资讯类应用  \n> 产品关键词：IT、极客、活力、科技、技术分享、前沿动态、内容社交  \n> 用户特点：年轻有活力，对IT领域前言科技信息充满探索欲和学习热情\n\n- 极客园 PC 端项目：个人自媒体管理端\n- 项目演示\n- 项目功能，包括\n  - 登录\n  - 首页\n  - 内容（文章）管理\n    - 文章列表\n    - 发布文章\n    - 修改文章\n- 技术栈：\n  - `react` v17.0.2 / `react-dom` v17.0.2\n  - ajax请求库：`axios`\n  - 路由：`react-router-dom` 以及 `history`\n  - 富文本编辑器：`react-quill`\n  - CSS 预编译器：`sass`\n  - UI 组件库：`antd` v4\n  - 项目搭建：React 官方脚手架 `create-react-app`\n\n## 项目搭建\n\n### 创建项目\n\n1. 使用 React CLI 搭建项目：`npx create-react-app geek-pc-21`\n2. 进入项目根目录：`cd geek-pc-21`\n3. 启动项目：`yarn start`\n4. 调整项目目录结构：\n\n```\n/src\n  /assets         项目资源文件，比如，图片 等\n  /components     通用组件\n  /pages          页面\n  /utils          工具，比如，token、axios 的封装等、\n  /api            封装接口\n  \n  App.js          根组件\n  index.css       全局样式\n  index.js        项目入口\n```\n\n### 使用git管理项目\n\nhttps://gitee.com/hucongcong/geek-pc-hz21/tree/master\n\n### 配置基础路由\n\n+ 安装路由：`yarn add react-router-dom`\n\n+ 在 pages 目录中创建两个页面：Login、Layout\n\n`src/pages/Layout/index.js`\n\n```jsx\nimport { Component } from \'react\'\n\nclass Layout extends Component {\n  render() {\n    return <div className=\"layout\">首页布局</div>\n  }\n}\n\nexport default Layout\n\n```\n\n`src/pages/Login/index.js`\n\n```jsx\nimport { Component } from \'react\'\n\nclass Login extends Component {\n  render() {\n    return <div className=\"login\">登录页</div>\n  }\n}\n\nexport default Login\n\n```\n\n+ 在 App 组件中，导入路由组件以及两个页面组件，配置路由规则\n\n```js\n// 导入路由\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from \'react-router-dom\'\n\n// 导入页面组件\nimport Login from \'./pages/Login\'\nimport Layout from \'./pages/Layout\'\n\n// 配置路由规则\nfunction App() {\n  return (\n    <Router>\n      <div className=\"App\">\n        {/* 路由规则 */}\n        <Switch>\n          <Redirect exact from=\"/\" to=\"/home\"></Redirect>\n          <Route path=\"/home\" component={Layout}></Route>\n          <Route path=\"/login\" component={Login}></Route>\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default App\n```\n\n+ 点击http://localhost:3000/login测试\n\n### 组件库 - antd\n\n[Ant Design](https://ant.design/index-cn)\n\n[antd PC 端组件库文档](https://ant.design/docs/react/introduce-cn)\n\n> `antd` 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\n>\n> **开箱即用**\n\n1. 安装：`yarn add antd`\n2. 使用：\n\n```js\n// 1 在 index.js 中导入 antd 的样式文件\nimport \'antd/dist/antd.css\'\n\n// 2 在 Login 页面组件中，使用 antd 的 Button 组件\nimport { Button } from \'antd\'\n\nconst Login = () => (\n  <div>\n    <Button type=\"primary\">Button</Button>\n  </div>\n)\n```\n\n\n## 项目功能 - 登录  \n\n功能如下：\n\n1. 搭建登录页面结构\n2. 登录表单校验\n3. 登录逻辑\n4. 封装处理 token、axios 的工具函数\n5. 登录访问控制\n\n![image-20210824155646620](https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/images/image-20210824155646620.png)\n\n### 创建git分支\n\n### 基本结构\n\n+ Card组件的使用\n\n```jsx\nimport { Card } from \'antd\'\n\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n          <p>Card content</p>\n          <p>Card content</p>\n          <p>Card content</p>\n        </Card>\n      </div>\n    )\n  }\n}\n\n```\n\n+ 准备样式`src/pages/Login/index.css`\n\n```css\n.login {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  background-image: url(../../assets/login.png);\n}\n\n.login-container {\n  width: 440px;\n  height: 360px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n\n```\n\n+ 准备logo\n\n```diff\n+ import logo from \'../../assets/logo.png\'\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n+          <img className=\"login-logo\" src={logo} alt=\"\" />\n        </Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 准备logo的样式\n\n```css\n.login-logo {\n  width: 200px;\n  height: 60px;\n  display: block;\n  margin: 0 auto 20px;\n}\n```\n\n### 绝对路径的使用\n\n+ 官网文档：<https://facebook.github.io/create-react-app/docs/importing-a-component#absolute-imports>\n+ 在根目录新建`jsconfig.json`文件\n+ 配置以下内容\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n+ 使用绝对路径\n\n```js\nimport logo from \'assets/logo.png\'\n\n相当于\n\'src/assets/logo.png\'\n```\n\n+ `重启项目`\n\n### sass的使用\n\n在react脚手架中已经有了sass的配置，因此只需要安装sass的依赖包，就可以直接使用sass了\n\n+ 安装sass依赖包\n\n```js\nyarn add sass -D\n```\n\n+ 把`index.css`改成`index.scss`\n+ 导入`index.scss`文件\n\n**注意：如果使用了scss，scss中使用图片的绝对路径的时候需要加上~**\n\n```css\nbackground-image: url(~assets/login.png);\n```\n\n### 登录表单的使用\n\n> 根据antd的表单组件进行修改https://ant.design/components/form-cn/#API\n\n```jsx\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n          <img className=\"login-logo\" src={logo} alt=\"\" />\n          {/* 表单 */}\n          <Form name=\"basic\">\n            <Form.Item name=\"username\">\n              <Input placeholder=\"请输入手机号\" />\n            </Form.Item>\n\n            <Form.Item name=\"password\">\n              <Input placeholder=\"请输入验证码\" />\n            </Form.Item>\n\n            <Form.Item name=\"remember\" valuePropName=\"checked\">\n              <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n            </Form.Item>\n\n            <Form.Item>\n              <Button type=\"primary\" htmlType=\"submit\" block>\n                登录\n              </Button>\n            </Form.Item>\n          </Form>\n        </Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 调整表单控件的大小\n\n```jsx\n<Form name=\"basic\" size=\"large\">\n```\n\n+ 设置选中后的样式\n\n```css\n.ant-checkbox-wrapper-checked span {\n  color: #1890ff;\n}\n\n```\n\n### 登录表单校验\n\n```js\n<Form.Item\n  name=\"username\"\n  rules={[\n    {\n      pattern: /^1[3-9]\\d{9}$/,\n      message: \'手机号码格式不对\',\n    },\n    { required: true, message: \'请输入手机号\' },\n  ]}\n>\n  <Input placeholder=\"请输入手机号\" />\n</Form.Item>\n\n<Form.Item\n  name=\"password\"\n  rules={[\n    {\n      pattern: /^\\d{6}$/,\n      message: \'验证码格式不对\',\n    },\n    { required: true, message: \'请输入验证码\' },\n  ]}\n>\n  <Input placeholder=\"请输入验证码\" />\n</Form.Item>\n\n<Form.Item\n  name=\"remember\"\n  valuePropName=\"checked\"\n  rules={[{ required: true, message: \'请阅读协议\' }]}\n>\n  <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n</Form.Item>\n\n```\n\n### 收集表单数据\n\n+ 给表单注册事件\n\n```jsx\n<Form\n  size=\"large\"\n  validateTrigger={[\'onChange\', \'onBlur\']}\n  onFinish={this.onFinish}\n>\n```\n\n+ 提供事件处理函数\n\n```jsx\nonFinish = (values) => {\n  console.log(values)\n}\n```\n\n+ 修改name属性\n\n```diff\n<Form.Item\n+  name=\"mobile\"\n  rules={[\n    {\n      pattern: /^1[3-9]\\d{9}$/,\n      message: \'手机号码格式不对\',\n    },\n    { required: true, message: \'请输入手机号\' },\n  ]}\n>\n  <Input placeholder=\"请输入手机号\" />\n</Form.Item>\n\n<Form.Item\n+  name=\"code\"\n  rules={[\n    {\n      pattern: /^\\d{6}$/,\n      message: \'验证码格式不对\',\n    },\n    { required: true, message: \'请输入验证码\' },\n  ]}\n>\n  <Input placeholder=\"请输入验证码\" />\n</Form.Item>\n\n<Form.Item\n+  name=\"agree\"\n  valuePropName=\"checked\"\n  rules={[{ required: true, message: \'请阅读协议\' }]}\n>\n  <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n</Form.Item>\n```\n\n### 设置 默认值\n\n```jsx\n<Form\n  name=\"basic\"\n  size=\"large\"\n  onFinish={this.login}\n  initialValues={{\n    agree: true,\n    mobile: \'13811111111\',\n    code: \'246810\',\n  }}\n>\n```\n\n### 封装axios 的工具函数\n\n+ 安装axios\n\n```jsx\nyarn add axios\n```\n\n+ 新建文件`utils/request.js`\n\n```jsx\nimport axios from \'axios\'\n\nconst instance = axios.create({\n  baseURL: \'http://geek.itheima.net/\',\n  timeout: 5000,\n})\n\n// 请求拦截器\ninstance.interceptors.request.use(\n  function (config) {\n    return config\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n\nexport default instance\n\n```\n\n+ 测试\n\n### api封装\n\n+ 新建文件 `src/api/user.js`\n\n```js\nimport request from \'utils/request\'\n\n/**\n * 登录请求，用于用户登录\n * @param {string} mobile 手机号\n * @param {string} code 验证码\n * @returns Promise\n */\nexport const login = (mobile, code) => {\n  return request({\n    method: \'POST\',\n    url: \'/authorizations\',\n    data: {\n      mobile,\n      code,\n    },\n  })\n}\n```\n\n+ 发送请求进行登录\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    // 跳转到首页\n    this.props.history.push(\'/home\')\n    alert(\'登录成功\')\n  } catch (err) {\n    alert(err.response.data.message)\n  }\n}\n```\n\n### 消息提示组件的使用\n\n```jsx\n// 表单提交\nsubmit = async values => {\n    this.setState({\n        loading: true\n    })\n\n    const { mobile, code } = values\n    try {\n        const { data } = await login(mobile, code)\n        message.success(\'登录成功\', 1, () => {\n            // 存储token\n            localStorage.setItem(\'itcast_geek_pc\', data.token)\n            // 跳转到首页\n            this.props.history.push(\'/home\')\n        })\n    } catch (err) {\n        message.warning(err.response.data.message, 1, () => {\n            this.setState({\n                loading: false\n            })\n        })\n    }\n}\n```\n\n\n## react样式冲突 \n\n### 组件样式覆盖问题\n\n+ 在Layout组件的`index.scss`中添加样式\n\n```css\n.navBar {\n  background-color: pink;\n}\n```\n\n+ 在`Home`组件中的样式也跟着发生了改变，说明组件中的样式是相互影响的。\n+ 原因：在配置路由时，Layout和 Home 组件都被导入到项目中，那么组件的样式也就被导入到项目中了。如果组件之间样式名称相同，那么一个组件中的样式就会在另一个组件中也生效，从而造成组件之间样式相互覆盖的问题。\n+ 结论：默认，只要导入了组件，不管组件有没有显示在页面中，组件的样式就会生效。\n+ 解决方案\n  + 手动处理 （起不同的类名）\n  + `CSS IN JS` ： 以js的方式来处理css   \n  + css不是一门编程语言，css没有所有的局部作用域全局作用域这样的区分。。。css只有全局作用域\n\n###  CSS IN JS\n\n+ CSS IN JS：是使用 JavaScript 编写 CSS 的统称，用来解决 CSS 样式冲突、覆盖等问题\n+ [CSS IN JS](<https://github.com/MicheleBertoli/css-in-js>) 的具体实现有 50 多种，比如：CSS Modules、[styled-components](<https://www.styled-components.com/>) 等\n\n+ 推荐使用：[CSS Modules](<https://github.com/css-modules/css-modules>) （React脚手架已集成，可直接使用）\n\n### CSS Modules 的说明 \n\n+ CSS Modules 通过对 CSS 类名重命名，保证每个类名的唯一性，从而避免样式冲突的问题 \n+ 换句话说：所有类名都具有“局部作用域”，只在当前组件内部生效\n+ 在 React 脚手架中：文件名、类名、hash（随机）三部分，只需要指定类名即可  BEM\n+ `xxxx.module.css`\n\n```js\n/* 自动生成的类名，我们只需要提供 classname 即可 */\n[filename]_[classname]_[hash]\n```\n\n```css\n// 类名\n.error {}  .red{}\n// 生成的类名为：\n.NavHeader_error__ax7yz   .NavHead_red_abcdc\n```\n\n### 在项目中使用css Modules\n\n+ 创建名为 `[name].module.css` 的样式文件（React脚手架中的约定，与普通 CSS 作区分）\n\n```js\n// 在 CityList 组件中创建的样式文件名称：\nindex.module.css\n```\n\n+ 组件中导入该样式文件（注意语法）\n\n```js\n// 在 CityList 组件中导入样式文件：\nimport styles from \'./index.module.css\'\n```\n\n+ 通过 styles 对象访问对象中的样式名来设置样式\n\n```js\n<div className={styles.test}></div>\n```\n\n### css module的注意点\n\n+ 类名最好使用驼峰命名，因为最终类名会生成`styles`的一个属性\n\n```js\n.tabBar {}\n\nstyles.tabBar\n```\n\n+ 如果没有使用驼峰命名，对于不合法的命名，需要使用[]语法 \n\n```js\n.tab-bar {}\n\nstyles[\'tab-bar\']\n```\n\n+ 如果是全局的类名，应该使用`:global(.类名)`的方式，不然会把全局类名给修改掉 \n\n```js\n:global(.icon-map) {   }\n\n这样css modules就不会修改掉类名了\n```\n\n### css module配合sass\n\n+ css moudule也可以配合sass来使用，创建名为`[name].module.scss`\n\n```css\n.father {\n  .son {\n    font-size: 30px;\n  }\n\n  :global {\n    .son2 {\n      font-size: 20px;\n    }\n  }\n}\n```\n\n+ 使用css modules解决Login组件样式冲突问题\n\n\n\n### css modules的使用步骤\n\n1. 把`index.scss`改成`index.module.scss`\n\n```scss\n.list {\n  background-color: pink;\n  color: red;\n    :global {\n        xxxx\n    }\n}\n\n```\n\n2. 导入样式的时候进行修改\n\n```diff\n- import \'./index.scss\'\n\n+ import styles from \'./index.module.scss\'\n```\n\n\n\n3. 使用的时候需要修改\n\n```diff\n- <div className=\"list\">文章列表组件</div>\n\n+ <div className={styles.list}>文章列表组件</div>\n```\n\n\n\n## 项目功能 - 首页\n\n![image-20210825144229158](https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/images/image-20210825144229158.png)\n\n### 搭建布局组件结构\n\n+ 准备基本结构\n\n```jsx\n<div className=\"layout\">\n  <Layout>\n    <Header className=\"header\">\n      <div className=\"logo\" />\n    </Header>\n    <Layout>\n      <Sider width={200} className=\"site-layout-background\">\n        <Menu\n          mode=\"inline\"\n          defaultSelectedKeys={[\'1\']}\n          defaultOpenKeys={[\'sub1\']}\n          style={{ height: \'100%\', borderRight: 0 }}\n        >\n          <Menu.Item key=\"1\">option1</Menu.Item>\n          <Menu.Item key=\"2\">option2</Menu.Item>\n          <Menu.Item key=\"3\">option3</Menu.Item>\n        </Menu>\n      </Sider>\n      <Layout style={{ padding: \'0 24px 24px\' }}>\n        <Content\n          className=\"site-layout-background\"\n          style={{\n            padding: 24,\n            margin: 0,\n            minHeight: 280,\n          }}\n        >\n          Content\n        </Content>\n      </Layout>\n    </Layout>\n  </Layout>\n</div>\n```\n\n+ 提供样式文件`index.scss`\n\n```scss\n.layout {\n  .logo {\n    float: left;\n    width: 120px;\n    height: 31px;\n    margin: 16px 24px 16px 0;\n    background: rgba(255, 255, 255, 0.3);\n  }\n\n  .ant-row-rtl .logo {\n    float: right;\n    margin: 16px 0 16px 24px;\n  }\n\n  .site-layout-background {\n    background: #fff;\n  }\n}\n\n```\n\n### 头部结构与样式\n\n+ 头部结构\n\n```jsx\n<Header className=\"header\">\n  <div className=\"logo\" />\n  <div className=\"profile\">\n    <span>黑马先锋</span>\n    <span>\n      <LogoutOutlined></LogoutOutlined>\n      {\'  \'}退出\n    </span>\n  </div>\n</Header>\n```\n\n+ 头部样式\n\n```css\n.layout {\n  .profile {\n    position: absolute;\n    right: 20px;\n    color: #fff;\n    font-weight: 700;\n    span + span {\n      margin-left: 20px;\n      cursor: pointer;\n    }\n  }\n}\n\n```\n\n### 左侧菜单\n\n+ 导入图标\n\n```jsx\nimport {\n  LogoutOutlined,\n  HomeOutlined,\n  DiffOutlined,\n  EditOutlined,\n} from \'@ant-design/icons\'\n```\n\n+ 展示图标\n\n```jsx\n<Menu.Item key=\"1\" icon={<HomeOutlined />}>\n  数据概览\n</Menu.Item>\n<Menu.Item key=\"2\" icon={<DiffOutlined />}>\n  内容管理\n</Menu.Item>\n<Menu.Item key=\"3\" icon={<EditOutlined />}>\n  发布文章\n</Menu.Item>\n```\n\n### 整体样式处理\n\n+ 样式\n\n```scss\n.layout {\n  height: 100vh;\n  .ant-layout {\n    height: 100%;\n  }\n}\n```\n\n+ 内容样式修改\n\n```jsx\n<Layout style={{ padding: \'24px\' }}>\n```\n\n### 嵌套路由的配置\n\n+ 新增组件 `Home/index.js`  `ArticleList/index.js`   `ArticlePublish/index.js`\n\n```jsx\nimport React, { Component } from \'react\'\n\nexport default class Home extends Component {\n  render() {\n    return <div className=\"home\">Home首页</div>\n  }\n}\n\n```\n\n+ 增加配置  layout/index.js组件中\n\n```jsx\n\nimport Home from \'../Home\'\nimport ArticleList from \'../ArticleList\'\nimport ArticlePublish from \'../ArticlePublish\'\n\n<Route exact path=\"/home\" component={Home}></Route>\n<Route path=\"/home/list\" component={ArticleList}></Route>\n<Route path=\"/home/publish\" component={ArticlePublish}></Route>\n```\n\n### 退出功能\n\n+ 结构\n\n```jsx\nimport { Layout, Menu, Popconfirm } from \'antd\'\n\n<Popconfirm\n  title=\"你确定要退出本系统么？\"\n  okText=\"确定\"\n  cancelText=\"取消\"\n  onConfirm={this.onConfirm}\n>\n  <span>\n    <LogoutOutlined></LogoutOutlined>\n    {\'  \'}退出\n  </span>\n</Popconfirm>\n```\n\n+ 功能\n\n```jsx\nonConfirm = () => {\n  // 点击了确定\n  localStorage.removeItem(\'itcast_geek_pc\')\n  // 跳转到登录页\n  this.props.history.push(\'/login\')\n  // 提示消息\n  message.success(\'退出成功\')\n}\n```\n\n### 本地存储操作的封装\n\n+ 封装token操作 `utils/storage.js`\n\n```jsx\nconst TOKEN_KEY = \'itcast-geek-token\'\n\nconst setToken = (token) => {\n  localStorage.setItem(TOKEN_KEY, token)\n}\n\nconst removeToken = () => {\n  localStorage.removeItem(TOKEN_KEY)\n}\n\nconst getToken = () => {\n  return localStorage.getItem(TOKEN_KEY)\n}\n\nexport { setToken, getToken, removeToken }\n\n```\n\n+ 修改登录代码\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    // localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    setToken(res.data.token)\n    // 跳转到首页\n    this.props.history.push(\'/home\')\n    message.success(\'登录成功\', 1)\n  } catch (err) {\n    message.warning(err.response.data.message, 1)\n  }\n}\n```\n\n+ 修改退出功能\n\n```jsx\nonConfirm = () => {\n  // 点击了确定\n  // localStorage.removeItem(\'itcast_geek_pc\')\n  removeToken()\n  // 跳转到登录页\n  this.props.history.push(\'/login\')\n  // 提示消息\n  message.success(\'退出成功\')\n}\n```\n\n### 登录访问控制 - 鉴权\n\n对于极客园 PC 端项目来说，\n\n- 有的页面*不需要登录*就可以访问，比如，登录页\n- 有的页面*需要登录*后才能访问，比如，项目后台首页、内容管理等（除了登录页面，其他页面需要登录才能访问）\n\n因此，就需要对项目进行登录访问控制，让需要登录才能访问的页面，必须在登录后才能访问。\n在没有登录时，直接跳转到登录页面，让用户进行登录。\n\n- 如何实现登录访问控制呢？\n  - 分析：不管哪个页面都是通过**路由**来访问的，因此，需要从路由角度来进行控制\n  - 思路：创建 `AuthRoute` 组件，判断是否登录，1 登录直接显示要访问的页面 2 没有登录跳转到登录页面\n\n**难点：react中没有导航守卫，需要自己封装**\n\n#### 分析 AuthRoute 鉴权路由组件\n\n+ 场景：限制某个页面只能在登录的情况下访问。\n+ 说明：在 React 路由中并没有直接提供该组件，需要手动封装，来实现登录访问控制（类似于 Vue 路由的导航守卫）。\n+ 如何封装？参考 react-router-dom 文档中提供的鉴权示例 。\n+ 如何使用？使用 AuthRoute 组件代替默认的 Route 组件，来配置路由规则。\n+ AuthRoute 组件实际上就是对原来的 Route 组件做了一次包装，来实现了一些额外的功能。\n+ `<Route  path component render>`   render 方法，指定该路由要渲染的组件内容（类似于 component 属性）。\n+ Redirect 组件：重定向组件，通过 to 属性，指定要跳转到的路由信息。\n+ state 属性：表示给路由附加一些额外信息，此处，用于指定登录成功后要进入的页面地址。\n\n```js\n// 使用方式：\n<AuthRoute path=\"/rent/add\" component={Rent} />\n```\n\n#### 实现自己的AuthRoute组件\n\n+ 新增hasToken方法\n\n```jsx\nconst hasToken = () => !!getToken()\n\nexport { setToken, getToken, removeToken, hasToken }\n```\n\n+ 权限判断\n\n```js\nimport React from \"react\"\nimport { Route, Redirect } from \"react-router-dom\"\nimport { hasToken } from \'utils/storage\'\nfunction AuthRouter({ component: Component, ...rest }) {\n  return (\n    <Route\n      {...rest}\n      render={(props) => {\n        // console.log(\"props\", props)\n        if (hasToken()) {\n          return <Component {...props}></Component>\n        } else {\n          return (\n            <Redirect\n              to={{ pathname: \"/login\", state: { from: props.location } }}\n            ></Redirect>\n          )\n        }\n      }}\n    ></Route>\n  )\n}\n\nexport default AuthRouter\n\n```\n\n+ 使用AuthRoute\n\n```jsx\n{/* 路由规则 */}\n<Switch>\n  <Redirect exact from=\"/\" to=\"/home\"></Redirect>\n  <AuthRoute path=\"/home\" component={Layout}></AuthRoute>\n  <Route path=\"/login\" component={Login}></Route>\n</Switch>\n```\n\n+ 登录成功处理\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  console.log(this.props)\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    // localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    setToken(res.data.token)\n    // 跳转到首页\n    const { state } = this.props.location\n    if (state) {\n      this.props.history.push(state.from.pathname)\n    } else {\n      this.props.history.push(\'/home\')\n    }\n    message.success(\'登录成功\', 1)\n  } catch (err) {\n    message.warning(err.response.data.message, 1)\n  }\n}\n```\n\n#### route组件的作用\n\n```jsx\n<Route path=\"/home\" component={Home}></Route>\n<Route path=\"/login\" component={Login}></Route>\n```\n\nRoute组件会根据当前地址中的地址 和 Route的path进行匹配，，，如果路径一直，那么这个对应的组件就会被渲染出来\n\nRoute没有判断用户是否登录的能力，只会根据path判断是否要渲染对应的组件。\n\n**需求：让Route组件能够有逻辑，能够判断用户是否登录，，，，需要通过Route组件的render属性**\n\n\n\n### 获取个人信息\n\n+ 拦截器添加token\n\n```jsx\n// 请求拦截器\ninstance.interceptors.request.use(\n  function (config) {\n    const token = getToken()\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`\n    }\n    return config\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n```\n\n+ 封装接口，获取用户信息\n\n```jsx\n/**\n * 获取用户信息\n * @returns Promise\n */\nexport const getUserInfo = () => {\n  return request({\n    url: \'/user/profile\',\n    method: \'get\',\n  })\n}\n\n```\n\n+ 发送请求进行登录\n\n```jsx\nstate = {\n  profile: {},\n}\n\nasync componentDidMount() {\n  const res = await getUserProfile()\n  console.log(res)\n  this.setState({\n    profile: res.data,\n  })\n}\n```\n\n+ 渲染\n\n```jsx\n<div className=\"profile\">\n  <span>{this.state.profile.name}</span>\n  <Popconfirm\n    title=\"你确定要退出本系统么？\"\n    okText=\"确定\"\n    cancelText=\"取消\"\n    onConfirm={this.onConfirm}\n  >\n    <span>\n      <LogoutOutlined></LogoutOutlined>\n      {\'  \'}退出\n    </span>\n  </Popconfirm>\n</div>\n```\n\n### 处理token过期\n\n> 使用响应拦截器拦截未登录的用户\n>\n> 难点：react-router-dom 如何在非组件中实现路由跳转\n\n+ 响应拦截器处理\n\n```jsx\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    console.log(error.response)\n    if (error.response.status === 401) {\n      // token过期\n      removeToken()\n      window.location.href = \'/login\'\n    }\n    return Promise.reject(error)\n  }\n)\n```\n\n缺点：window.localtion会导致页面刷新\n\n+ history处理 `utils/history.js`\n\n```\nimport { createHashHistory } from \'history\'\n\nconst history = createHashHistory()\n\nexport default history\n\n```\n\n+ App.js修改\n\n```jsx\nimport history from \'utils/history\'\n\n<Router history={history}>\n</Router>\n```\n\n\n\n+ 修改响应拦截器\n\n```jsx\nimport history from \'./history\'\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    console.log(error.response)\n    if (error.response.status === 401) {\n      // token过期\n      removeToken()\n      // 跳转到登录页\n      history.push(\'/login\')\n      message.warning(\'用户信息已过期\')\n    }\n    return Promise.reject(error)\n  }\n)\n```\n\n### 左侧菜单与高亮\n\n```jsx\n<Menu\n  theme=\"dark\"\n  mode=\"inline\"\n  defaultSelectedKeys={[this.props.location.pathname]}\n  style={{ height: \'100%\', borderRight: 0 }}\n>\n  <Menu.Item key=\"/home\" icon={<HomeOutlined />}>\n    <Link to=\"/home\">首页</Link>\n  </Menu.Item>\n  <Menu.Item key=\"/home/list\" icon={<DiffOutlined />}>\n    <Link to=\"/home/list\">内容管理</Link>\n  </Menu.Item>\n  <Menu.Item key=\"/home/publish\" icon={<EditOutlined />}>\n    <Link to=\"/home/publish\">发布文章</Link>\n  </Menu.Item>\n</Menu>\n```\n\n\n## 文章列表功能\n\n\n### card组件与面包屑导航\n\n+ card组件，文档：https://ant.design/components/card-cn/\n\n```jsx\nimport { Card } from \'antd\'\nexport default class ArticleList extends Component {\n  render() {\n    return (\n      <div className=\"articleList\">\n        <Card title=\"面包屑导航\">我是内容</Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 面包屑导航的使用\n\n```jsx\nimport React, { Component } from \'react\'\nimport { Card, Breadcrumb } from \'antd\'\nimport { Link } from \'react-router-dom\'\n\nrender() {\n    return (\n      <div className=\"articleList\">\n        <Card\n          title={\n            <Breadcrumb separator=\"/\">\n              <Breadcrumb.Item>\n                <Link to=\"/home\">首页</Link>\n              </Breadcrumb.Item>\n              <Breadcrumb.Item>文章列表</Breadcrumb.Item>\n            </Breadcrumb>\n          }\n        >\n          我是内容\n        </Card>\n      </div>\n    )\n  }\n```\n\n### 搜索表单基本结构\n\n+ 复制表单的基本结构到组件中\n+ 修改表单结构\n\n```jsx\n<Card\n  title={\n    <Breadcrumb separator=\"/\">\n      <Breadcrumb.Item>\n        <Link to=\"/home\">首页</Link>\n      </Breadcrumb.Item>\n      <Breadcrumb.Item>文章列表</Breadcrumb.Item>\n    </Breadcrumb>\n  }\n>\n  <Form>\n    <Form.Item label=\"状态\" name=\"username\">\n      <Input />\n    </Form.Item>\n\n    <Form.Item label=\"频道\" name=\"password\">\n      <Input.Password />\n    </Form.Item>\n\n    <Form.Item label=\"日期\" name=\"password\">\n      <Input.Password />\n    </Form.Item>\n\n    <Form.Item>\n      <Button type=\"primary\" htmlType=\"submit\">\n        筛选\n      </Button>\n    </Form.Item>\n  </Form>\n</Card>\n```\n\n+ 状态的基本结构\n\n```jsx\n<Form initialValues={{ status: null }}>\n  <Form.Item label=\"状态\" name=\"status\">\n    <Radio.Group>\n      <Radio value={null}>全部</Radio>\n      <Radio value={0}>草稿</Radio>\n      <Radio value={1}>待审核</Radio>\n      <Radio value={2}>审核通过</Radio>\n      <Radio value={3}>审核失败</Radio>\n    </Radio.Group>\n  </Form.Item>\n```\n\n+ 下拉框结构\n\n```jsx\n<Form.Item label=\"频道\" name=\"password\">\n  <Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n    <Option value=\"jack\">Jack</Option>\n    <Option value=\"lucy\">Lucy</Option>\n    <Option value=\"Yiminghe\">yiminghe</Option>\n  </Select>\n</Form.Item>\n```\n\n+ 日期选择基本结构\n\n```jsx\nimport { Card, Breadcrumb, Form, Button, Radio, Select, DatePicker } from \'antd\'\nconst { RangePicker } = DatePicker\n\n<Form.Item label=\"日期\" name=\"password\">\n  <RangePicker />\n</Form.Item>\n```\n\n### 日期中文处理\n\n> https://ant-design.gitee.io/components/date-picker-cn/\n\n在index.js中\n\n```jsx\nimport React from \'react\'\nimport ReactDOM from \'react-dom\'\n// 在 index.js 中导入 antd 的样式文件\nimport \'antd/dist/antd.css\'\n\nimport \'./index.css\'\nimport { ConfigProvider } from \'antd\'\nimport \'moment/locale/zh-cn\'\nimport locale from \'antd/lib/locale/zh_CN\'\n\nimport App from \'./App\'\n\nReactDOM.render(\n  <ConfigProvider locale={locale}>\n    <App />\n  </ConfigProvider>,\n  document.getElementById(\'root\')\n)\n\n```\n\n### 频道数据管理\n\n+ 封装接口\n\n```jsx\nimport request from \'utils/request\'\n\n/*\n  获取所有的频道\n*/\nexport const getChannels = () => {\n  return request.get(\'/channels\')\n}\n\n```\n\n+ 发送请求获取数据\n\n```jsx\nimport { getChannels } from \'api/channel\'\n\nstate = {\n  channels: [],\n}\nasync getChannelList() {\n  const res = await getChannels()\n  this.setState({\n    channels: res.data.channels,\n  })\n}\n\ncomponentDidMount() {\n  this.getChannelList()\n}\n```\n\n+ 渲染频道数据\n\n```jsx\n<Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n  {this.state.channels.map((item) => (\n    <Option value={item.id} key={item.id}>\n      {item.name}\n    </Option>\n  ))}\n</Select>\n```\n\n### 表格基本结构\n\n+ 基本结构\n\n```jsx\nimport {\n  Card,\n  Breadcrumb,\n  Form,\n  Button,\n  Radio,\n  Select,\n  DatePicker,\n  Table,\n  Tag,\n  Space,\n} from \'antd\'\n\nrender() {\n  const columns = [\n    {\n      title: \'Name\',\n      dataIndex: \'name\',\n      key: \'name\',\n      render: (text) => <a>{text}</a>,\n    },\n    {\n      title: \'Age\',\n      dataIndex: \'age\',\n      key: \'age\',\n    },\n    {\n      title: \'Address\',\n      dataIndex: \'address\',\n      key: \'address\',\n    },\n    {\n      title: \'Tags\',\n      key: \'tags\',\n      dataIndex: \'tags\',\n      render: (tags) => (\n        <>\n          {tags.map((tag) => {\n            let color = tag.length > 5 ? \'geekblue\' : \'green\'\n            if (tag === \'loser\') {\n              color = \'volcano\'\n            }\n            return (\n              <Tag color={color} key={tag}>\n                {tag.toUpperCase()}\n              </Tag>\n            )\n          })}\n        </>\n      ),\n    },\n    {\n      title: \'Action\',\n      key: \'action\',\n      render: (text, record) => (\n        <Space size=\"middle\">\n          <a>Invite {record.name}</a>\n          <a>Delete</a>\n        </Space>\n      ),\n    },\n  ]\n\n  const data = [\n    {\n      key: \'1\',\n      name: \'John Brown\',\n      age: 32,\n      address: \'New York No. 1 Lake Park\',\n      tags: [\'nice\', \'developer\'],\n    },\n    {\n      key: \'2\',\n      name: \'Jim Green\',\n      age: 42,\n      address: \'London No. 1 Lake Park\',\n      tags: [\'loser\'],\n    },\n    {\n      key: \'3\',\n      name: \'Joe Black\',\n      age: 32,\n      address: \'Sidney No. 1 Lake Park\',\n      tags: [\'cool\', \'teacher\'],\n    },\n  ]\n\n  return (\n    <div className=\"articleList\">\n      <Card title={`根据筛选条件共查询到${0}条数据`}>\n        <Table dataSource={data} columns={columns} />\n      </Card>\n    </div>\n  )\n}\n```\n\n### 获取文章列表数据\n\n+ 封装接口\n\n```jsx\nimport request from \'utils/request\'\n\n/**\n * 获取文章列表\n * @param {*} params\n * @returns\n */\nexport const getArticles = (params) => {\n  return request({\n    url: \'/mp/articles\',\n    method: \'get\',\n    params,\n  })\n}\n\n```\n\n+ 发送请求获取文章列表数据\n\n```jsx\n  state = {\n    channels: [],\n    articles: [],\n    total: 0,\n  }\n  async getChannelList() {\n    const res = await getChannels()\n    this.setState({\n      channels: res.data.channels,\n    })\n  }\n\n  async getArticleList() {\n    const res = await getArticles()\n    this.setState({\n      articles: res.data.results,\n      total: res.data.total_count,\n    })\n  }\n\n  componentDidMount() {\n    this.getChannelList()\n    this.getArticleList()\n  }\n\n```\n\n### 渲染表格数据\n\n+ 修改columns\n\n```jsx\nconst columns = [\n  {\n    title: \'封面\',\n    dataIndex: \'name\',\n  },\n  {\n    title: \'标题\',\n    dataIndex: \'title\',\n  },\n  {\n    title: \'状态\',\n    dataIndex: \'status\',\n  },\n  {\n    title: \'发布时间\',\n    dataIndex: \'pubdate\',\n  },\n  {\n    title: \'阅读数\',\n    dataIndex: \'read_count\',\n  },\n  {\n    title: \'评论数\',\n    dataIndex: \'comment_count\',\n  },\n  {\n    title: \'点赞数\',\n    dataIndex: \'like_count\',\n  },\n  {\n    title: \'操作\',\n  },\n]\n```\n\n+ 封面处理\n\n```jsx\n{\n  title: \'封面\',\n  dataIndex: \'cover\',\n  render(data) {\n    const { images, type } = data\n    if (type === 0) {\n      return (\n        <Image width={200} preview={false} height={150} src={defaultImg} />\n      )\n    }\n    return (\n      <Image width={200} height={150} src={images[0]} fallback={defaultImg} />\n    )\n  },\n},\n```\n\n+ 状态处理\n\n```jsx\n// 通过对象来优化if/switch\n// 使用方式：articleStatus[0] => { text: \'草稿\', color: \'\' }\nconst articleStatus = {\n  0: { text: \'草稿\', color: \'gold\' },\n  1: { text: \'待审核\', color: \'lime\' },\n  2: { text: \'审核通过\', color: \'green\' },\n  3: { text: \'审核失败\', color: \'red\' },\n}\n\n{\n  title: \'状态\',\n  dataIndex: \'status\',\n  render: (data) => {\n    const tagObj = articleStatus[data]\n    return <Tag color={tagObj.color}>{tagObj.text}</Tag>\n  },\n},\n```\n\n+ 操作功能\n\n```jsx\n{\n    title: \'操作\',\n    render() {\n      return (\n        <Space>\n          <Button\n            type=\"primary\"\n            shape=\"circle\"\n            icon={<EditOutlined />}\n          ></Button>\n          <Button\n            type=\"primary\"\n            shape=\"circle\"\n            danger\n            icon={<DeleteOutlined />}\n          ></Button>\n        </Space>\n      )\n    },\n},\n```\n\n### key属性处理\n\n```jsx\n<Card title={`根据筛选条件共查询到${this.state.total}条数据`}>\n  <Table\n    rowKey=\"id\"\n    dataSource={this.state.articles}\n    columns={columns}\n  />\n</Card>\n```\n\n### 分页功能\n\n+ 使用分页组件\n\n```jsx\n<Card title={`根据筛选条件共查询到${this.state.total_count}条数据`}>\n  <Table\n    rowKey=\"id\"\n    dataSource={results}\n    columns={columns}\n    pagination={{\n      position: [\'bottomCenter\'],\n      current: page,\n      pageSize: per_page,\n      total: total_count,\n      // 每页大小 或者 页码 改变时，触发的事件\n      onChange: this.changePage,\n    }}\n  />\n</Card>\n```\n\n+ 提供changePage事件\n\n```jsx\nchangePage = async (page, pageSize) => {\n  console.log(page)\n  const res = await getArticles({\n    page,\n    per_page: this.state.articles.per_page,\n  })\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 获取表单的值进行筛选\n\n+ 给表单注册事件\n\n```jsx\n<Form initialValues={{ status: -1 }} onFinish={this.onFinish}>\n```\n\n+ 给表单元素提供name属性\n\n```jsx\n<Form.Item label=\"状态\" name=\"status\">\n  <Radio.Group>\n    <Radio value={-1}>全部</Radio>\n    <Radio value={0}>草稿</Radio>\n    <Radio value={1}>待审核</Radio>\n    <Radio value={2}>审核通过</Radio>\n    <Radio value={3}>审核失败</Radio>\n  </Radio.Group>\n</Form.Item>\n\n<Form.Item label=\"频道\" name=\"channel_id\">\n  <Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n    {this.state.channels.map((item) => (\n      <Option value={item.id} key={item.id}>\n        {item.name}\n      </Option>\n    ))}\n  </Select>\n</Form.Item>\n\n<Form.Item label=\"日期\" name=\"date\">\n  <RangePicker />\n</Form.Item>\n```\n\n+ 发送请求，获取数据\n\n```jsx\nonFinish = async (values) => {\n  console.log(values)\n  // 发送请求，获取数据\n  const params = {}\n  // 处理状态\n  if (values.status !== -1) {\n    params.status = values.status\n  }\n  // 处理频道\n  if (values.channel_id) {\n    params.channel_id = values.channel_id\n  }\n  // 处理日期\n  if (values.date) {\n    params.begin_pubdate = values.date[0].format(\'YYYY-MM-DD\')\n    params.end_pubdate = values.date[1].format(\'YYYY-MM-DD\')\n  }\n  params.page = 1\n  const res = await getArticles(params)\n  console.log(res.data)\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 时间的优化\n\n```jsx\n// 处理日期\nif (values.date) {\n  params.begin_pubdate = values.date[0]\n    .startOf(\'day\')\n    .format(\'YYYY-MM-DD HH:mm:ss\')\n  params.end_pubdate = values.date[1]\n    .endOf(\'day\')\n    .format(\'YYYY-MM-DD HH:mm:ss\')\n}\n```\n\n### 修改分页bug\n\n```jsx\nchangePage = async (page, pageSize) => {\n  const res = await getArticles({\n    ...this.params,\n    page,\n    per_page: this.state.articles.per_page,\n  })\n  this.setState({\n    articles: res.data,\n  })\n}\nonFinish = async (values) => {\n  console.log(values)\n  // 发送请求，获取数据\n  const params = {}\n  // 处理状态\n  if (values.status !== -1) {\n    params.status = values.status\n  }\n  // 处理频道\n  if (values.channel_id) {\n    params.channel_id = values.channel_id\n  }\n  // 处理日期\n  if (values.date) {\n    params.begin_pubdate = values.date[0]\n      .startOf(\'day\')\n      .format(\'YYYY-MM-DD HH:mm:ss\')\n    params.end_pubdate = values.date[1]\n      .endOf(\'day\')\n      .format(\'YYYY-MM-DD HH:mm:ss\')\n  }\n  params.page = 1\n  this.params = params\n  const res = await getArticles(params)\n  console.log(res.data)\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 删除功能\n\n+ 注册点击事件\n\n```jsx\n<Button\n  type=\"primary\"\n  shape=\"circle\"\n  danger\n  icon={<DeleteOutlined />}\n  onClick={() => this.handleDelete(data.id)}\n></Button>\n```\n\n+ 准备弹窗\n\n```jsx\nhandleDelete = (id) => {\n  confirm({\n    title: \'温馨提示？\',\n    icon: <ExclamationCircleOutlined />,\n    content: \'你确定要删除文章吗\',\n    onOk() {\n      // 发送请求进行删除\n    },\n  })\n}\n```\n\n+ 封装接口进行删除\n\n```jsx\n/**\n * 删除文章\n * @param {*} id\n * @returns\n */\nexport const delArticle = (id) => {\n  return request({\n    url: `/mp/articles/${id}`,\n    method: \'delete\',\n  })\n}\n\n```\n\n+ 删除功能完成\n\n```js\nhandleDelete = (id) => {\n  confirm({\n    title: \'温馨提示？\',\n    icon: <ExclamationCircleOutlined />,\n    content: \'你确定要删除文章吗\',\n    onOk: async () => {\n      // 发送请求进行删除\n      await delArticle(id)\n      this.getArticleList(this.params)\n    },\n  })\n}\n```\n\n## 发布文章\n\n### 基本结构准备\n\n+ 面包屑\n\n```jsx\nimport React, { Component } from \'react\'\nimport { Card, Breadcrumb } from \'antd\'\nimport { Link } from \'react-router-dom\'\nexport default class ArticleList extends Component {\n  render() {\n    return (\n      <div className=\"ArticleList\">\n        <Card\n          title={\n            <Breadcrumb separator=\">\">\n              <Breadcrumb.Item>\n                <Link to=\"/home\">首页</Link>\n              </Breadcrumb.Item>\n              <Breadcrumb.Item>发布文章</Breadcrumb.Item>\n            </Breadcrumb>\n          }\n        ></Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 表单\n\n```jsx\nimport { Card, Breadcrumb, Form, Input, Radio, Space, Button } from \'antd\'\n\n<Form labelCol={{ span: 4 }} initialValues={{ type: 0 }}>\n  <Form.Item label=\"标题\" name=\"title\">\n    <Input placeholder=\"请输入文章标题\" style={{ width: 400 }} />\n  </Form.Item>\n  <Form.Item label=\"频道\" name=\"channel_id\">\n    频道组件\n  </Form.Item>\n  <Form.Item label=\"封面\">\n    <Form.Item name=\"type\">\n      <Radio.Group onChange={this.changeImageType}>\n        <Radio value={0}>无图</Radio>\n        <Radio value={1}>单图</Radio>\n        <Radio value={3}>三图</Radio>\n        {/* <Radio value={-1}>自动</Radio> */}\n      </Radio.Group>\n    </Form.Item>\n    图片上传组件\n  </Form.Item>\n  <Form.Item label=\"内容\" name=\"content\">\n    文章内容\n  </Form.Item>\n  <Form.Item wrapperCol={{ offset: 4 }}>\n    <Space>\n      <Button size=\"large\" type=\"primary\" htmlType=\"submit\">\n        发布文章\n      </Button>\n      <Button size=\"large\">存入草稿</Button>\n    </Space>\n  </Form.Item>\n</Form>\n```\n\n+ 给表单注册事件\n\n```jsx\n<Form\n  labelCol={{ span: 4 }}\n  initialValues={{ type: 0 }}\n  onFinish={this.onFinish}\n>\n\n\nonFinish = (values) => {\n  console.log(values)\n}\n```\n\n### 频道组件封装\n\n+ 基础封装\n\n```jsx\nimport { Component } from \'react\'\nimport { Select } from \'antd\'\nimport { getChannels } from \'api/channel\'\n\nconst { Option } = Select\n\nclass Channel extends Component {\n  state = {\n    channels: [],\n  }\n\n  componentDidMount() {\n    this.getChannles()\n  }\n\n  // 获取频道列表数据的方法\n  async getChannles() {\n    const res = await getChannels()\n    this.setState({\n      channels: res.data.channels,\n    })\n  }\n\n  render() {\n    const { channels } = this.state\n\n    return (\n      <Select placeholder=\"请选择文章频道\">\n        {channels.map((item) => (\n          <Option key={item.id} value={item.id}>\n            {item.name}\n          </Option>\n        ))}\n      </Select>\n    )\n  }\n}\n\nexport default Channel\n\n```\n\n+ 使用频道组件\n\n```jsx\nimport Channel from \'components/Channel\'\n\n<Form.Item label=\"频道\" name=\"channel_id\">\n  <Channel></Channel>\n</Form.Item>\n```\n\n+ 让频道组件受控\n\n> 参考文档：https://ant-design.gitee.io/components/form-cn/#components-form-demo-customized-form-controls\n\n```jsx\nrender() {\n  const { channels } = this.state\n  const { value, onChange } = this.props\n  return (\n    <Select\n      placeholder=\"请选择文章频道\"\n      style={{ width: 200 }}\n      value={value}\n      onChange={onChange}\n    >\n      {channels.map((item) => (\n        <Option key={item.id} value={item.id}>\n          {item.name}\n        </Option>\n      ))}\n    </Select>\n  )\n}\n```\n\n### 文章内容处理\n\n+ 使用react-quill富文本编辑器 	https://github.com/zenoamaro/react-quill\n\n```jsx\nimport ReactQuill from \'react-quill\';\nimport \'react-quill/dist/quill.snow.css\';\n\n<Form.Item label=\"内容\" name=\"content\">\n  <ReactQuill\n    theme=\"snow\"\n    placeholder=\"请输入文章内容...\"\n  ></ReactQuill>\n</Form.Item>\n```\n\n+ 注意：**必须提供默认值，不然会报错**\n+ 提供样式\n\n```scss\n.publish {\n  :global {\n    .ql-editor {\n      min-height: 300px;\n    }\n  }\n}\n\n```\n\n### 图片上传组件\n\n+ 基本结构\n\n```jsx\nimport {\n  Card,\n  Breadcrumb,\n  Form,\n  Input,\n  Radio,\n  Space,\n  Button,\n  Upload,\n} from \'antd\'\nimport { PlusOutlined } from \'@ant-design/icons\'\n\n<Upload listType=\"picture-card\">\n  <PlusOutlined></PlusOutlined>\n</Upload>\n```\n\n+ 设置图片默认显示\n\n```jsx\n<Upload\n  listType=\"picture-card\"\n  name=\"image\"\n  fileList={this.state.fileList}\n>\n  <PlusOutlined></PlusOutlined>\n</Upload>\n\n\nstate = {\n  // 存放上传的文件列表\n  fileList: [\n    {\n      url: \'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png\',\n    },\n    {\n      url: \'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png\',\n    },\n  ],\n}\n\n```\n\n+ 图片上传功能， 需要提供name和action参数\n\n```jsx\n<Upload\n  listType=\"picture-card\"\n  name=\"image\"\n  action={`${baseURL}upload`}\n  onChange={this.uploadImages}\n  fileList={this.state.fileList}\n>\n  <PlusOutlined></PlusOutlined>\n</Upload>\n```\n\n+ 获取上传成功的图片地址\n\n```jsx\nuploadImages = ({ file, fileList }) => {\n  this.setState({\n    fileList,\n  })\n}\n```\n\n### 控制图片的上传数量\n\n+ 控制type的切换\n\n```jsx\nstate = {\n  // 存放上传的文件列表\n  fileList: [],\n  type: 0,\n}\n\n<Radio.Group onChange={this.changeImageType}>\n  <Radio value={0}>无图</Radio>\n  <Radio value={1}>单图</Radio>\n  <Radio value={3}>三图</Radio>\n</Radio.Group>\n\n\nchangeImageType = (e) => {\n  this.setState({\n    type: e.target.value,\n  })\n}\n```\n\n+ 根据type控制图片的显示\n\n```jsx\n{this.state.type !== 0 && (\n  <Upload\n    listType=\"picture-card\"\n    name=\"image\"\n    action={`${baseURL}upload`}\n    onChange={this.uploadImages}\n    fileList={this.state.fileList}\n  >\n    <PlusOutlined></PlusOutlined>\n  </Upload>\n)}\n```\n\n+ 控制图片的上传数据\n\n```jsx\n{this.state.type !== 0 && (\n  <Upload\n    listType=\"picture-card\"\n    name=\"image\"\n    action={`${baseURL}upload`}\n    onChange={this.uploadImages}\n    fileList={this.state.fileList}\n  >\n    {this.state.fileList.length < this.state.type && (\n      <PlusOutlined></PlusOutlined>\n    )}\n  </Upload>\n)}\n```\n\n### 图片预览功能\n\n### 图片格式校验\n\n### 表单校验功能\n\n+ 表单基本校验\n\n```jsx\n<Form.Item\n  label=\"标题\"\n  name=\"title\"\n  rules={[{ required: true, message: \'请输入文章标题\' }]}\n>\n  <Input placeholder=\"请输入文章标题\" style={{ width: 400 }} />\n</Form.Item>\n<Form.Item\n  label=\"频道\"\n  name=\"channel_id\"\n  rules={[{ required: true, message: \'请选择文章频道\' }]}\n>\n  <Channel></Channel>\n</Form.Item>\n<Form.Item label=\"封面\">\n  <Form.Item name=\"type\">\n    <Radio.Group onChange={this.changeImageType}>\n      <Radio value={1}>单图</Radio>\n      <Radio value={3}>三图</Radio>\n      <Radio value={0}>无图</Radio>\n      {/* <Radio value={-1}>自动</Radio> */}\n    </Radio.Group>\n  </Form.Item>\n  <div className=\"upload-list\">\n    {this.state.type !== 0 && (\n      <Upload\n        listType=\"picture-card\"\n        name=\"image\"\n        action={`${baseURL}upload`}\n        onChange={this.uploadImages}\n        fileList={this.state.fileList}\n      >\n        {this.state.fileList.length < this.state.type && (\n          <PlusOutlined></PlusOutlined>\n        )}\n      </Upload>\n    )}\n  </div>\n</Form.Item>\n<Form.Item\n  label=\"内容\"\n  name=\"content\"\n  rules={[{ required: true, message: \'请输入文章内容\' }]}\n>\n  <ReactQuill\n    theme=\"snow\"\n    placeholder=\"请输入文章内容...\"\n  ></ReactQuill>\n</Form.Item>\n```\n\n+ 图片长度的校验\n\n```jsx\nonFinish = async (values) => {\n  // 图片校验\n  if (this.state.type !== this.state.fileList.length) {\n    return message.warn(\'上传的图片数量不对\')\n  }\n}\n```\n\n### 发送请求-添加文章\n\n+ 封装接口\n\n```jsx\n/**\n * 发送请求添加文章\n * @param {*} data\n * @returns\n */\nexport const addArticle = (data) => {\n  return request({\n    url: \'/mp/articles\',\n    method: \'post\',\n    data,\n  })\n}\n\n```\n\n+ 发送请求-处理数据并且添加文章\n\n```jsx\nonFinish = async (values) => {\n  console.log(values)\n  // 处理数据，添加文章\n  const images = this.state.fileList.map((item) => {\n    if (item.url) {\n      return item.url\n    }\n    return item.response.data.url\n  })\n  const res = await addArticle({\n    ...values,\n    cover: {\n      type: values.type,\n      images,\n    },\n  })\n  message.success(\'添加文章成功\')\n  this.props.history.push(\'/home/list\')\n}\n```\n\n### 存入草稿功能\n\n+ 修改接口\n\n```jsx\n/**\n * 发送请求添加文章\n * @param {*} data\n * @returns\n */\nexport const addArticle = (data, draft = false) => {\n  return request({\n    url: \'/mp/articles?draft=\' + draft,\n    method: \'post\',\n    data,\n  })\n}\n```\n\n+ 注册点击事件\n\n```jsx\n<Button size=\"large\" onClick={this.addDraft}>\n  存入草稿\n</Button>\n```\n\n+ 提供事件\n\n```jsx\n  onFinish = async (values) => {\n    this.save(values, false)\n  }\n  save = async (values, draft) => {\n    // 图片校验\n    if (this.state.type !== this.state.fileList.length) {\n      return message.warn(\'上传的图片数量不对\')\n    }\n    // 处理数据，添加文章\n    const images = this.state.fileList.map((item) => {\n      if (item.url) {\n        return item.url\n      }\n      return item.response.data.url\n    })\n    await addArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n    this.props.history.push(\'/home/list\')\n  }\n  addDraft = async () => {\n    // 获取表单的数据\n    const values = await this.formRef.current.validateFields()\n    this.save(values, true)\n  }\n```\n\n## 修改功能\n\n### 文字处理\n\n+ 提供状态\n\n```jsx\nstate = {\n  // 存放上传的文件列表\n  fileList: [],\n  type: 1,\n  isEdit: !!this.props.match.params.id,\n}\n```\n\n+ 控制渲染\n\n```jsx\n{this.state.isEdit ? \'修改文章\' : \'发布文章\'}\n```\n\n### 数据回显\n\n+ 路由跳转\n\n```jsx\n<Route\n  path=\"/home/publish\"\n  key=\"add\"\n  component={ArticlePublish}\n  exact\n></Route>\n<Route\n  key=\"edit\"\n  path=\"/home/publish/:id\"\n  component={ArticlePublish}\n></Route>\n```\n\n+ 注册点击事件\n\n```jsx\n<Button\n  type=\"primary\"\n  shape=\"circle\"\n  icon={<EditOutlined />}\n  onClick={() =>\n    this.props.history.push(`/home/publish/${data.id}`)\n  }\n></Button>\n```\n\n+ 封装接口，获取文章数据\n\n```jsx\n/**\n * 根据id获取文章详情\n * @param {*} id\n * @returns\n */\nexport const getArticle = (id) => {\n  return request({\n    url: `/mp/articles/${id}`,\n    method: \'get\',\n  })\n}\n```\n\n+ 数据回显\n\n```jsx\nasync componentDidMount() {\n  // 如果有id，发送请求获取详情\n  const id = this.props.match.params.id\n  if (id) {\n    const res = await getArticle(id)\n    console.log(res)\n    const type = res.data.cover.type\n    const images = res.data.cover.images.map((url) => ({ url }))\n    const values = {\n      ...res.data,\n      type,\n    }\n    this.formRef.current.setFieldsValue(values)\n    this.setState({\n      type,\n      fileList: images,\n    })\n  }\n}\n```\n\n### 修改功能完成\n\n+ 封装接口\n\n```jsx\n/**\n * 发送请求修改文章\n * @param {*} data\n * @returns\n */\nexport const editArticle = (data, draft = false) => {\n  return request({\n    url: `/mp/articles/${data.id}?draft=${draft}`,\n    method: \'put\',\n    data,\n  })\n}\n```\n\n+ 判断\n\n```jsx\nsave = async (values, draft) => {\n  // 图片校验\n  if (this.state.type !== this.state.fileList.length) {\n    return message.warn(\'上传的图片数量不对\')\n  }\n  // 处理数据，添加文章\n  const images = this.state.fileList.map((item) => {\n    if (item.url) {\n      return item.url\n    }\n    return item.response.data.url\n  })\n  if (this.state.isEdit) {\n    await editArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n        id: this.props.match.params.id,\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n  } else {\n    await addArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n  }\n  this.props.history.push(\'/home/list\')\n}\n```');
INSERT INTO `t_article_content` VALUES (10, 10, '## 1.下载jdk\n\n在Oracle官网上下载不同版本的jdk：[jdk下载](www.oracle.com/java/technologies/downloads/)\n\n![在Oracle官网上下载不同版本的jdk](https://pic3.zhimg.com/80/v2-bb59b02be55da25e32eb20eb58a4b2a2_720w.webp)\n\n下载Java11版本链接 : [jdk11](www.oracle.com/java/technologies/javase-jdk11-downloads.html)\n\n![下载Java11版本链接](https://pic4.zhimg.com/80/v2-9481b994931cbfebef6a275e6186db0b_720w.webp)\n\n## 2.安装jdk\n\n运行此安装包，进行安装。安装后会发现jdk被分别安装在如下目录：\n\n```java\n/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk\n/Users/Kevin/development/tools/jdk-11.0.16.1.jdk\n/Users/Kevin/development/tools/jdk-17.0.4.1.jdk\n```\n\n## 3.配置jdk\n\n现在已经安装了3个版本的jdk，但是怎么确定当前生效的是哪个版本呢？或者说怎么切换这两个版本呢？配置方法如下：\n\n如果当前使用的shell是zsh就编辑.zshrc文件，如果是bash就编辑.bash_profile文件。\n\n在上述配置文件中添加如下配置：\n\n```\nJAVA_HOME_8=/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home\nJAVA_HOME_11=/Users/Kevin/development/tools/jdk-11.0.16.1.jdk/Contents/Home\nJAVA_HOME_17=/Users/Kevin/development/tools/jdk-17.0.4.1.jdk/Contents/Home\nJRE_HOME=$JAVA_HOME/jre\nPATH=$PATH:$JAVA_HOME/bin\nCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.\nexport JAVA_HOME=$JAVA_HOME_8\nexport JRE_HOME\nexport PATH\nexport CLASSPATH\n \nalias jdk8=\"export JAVA_HOME=$JAVA_HOME_8\"\nalias jdk11=\"export JAVA_HOME=$JAVA_HOME_11\"\nalias jdk17=\"export JAVA_HOME=$JAVA_HOME_17\"\n```\n\n\n然后执行一下此rc文件，终端中执行命令：\n\n```\nsource ~/.bash_profile 或者 source ~/.zshrc\n```\n\n## 4.切换jdk\n\n我们定义了别名：jdk8和jdk11和jdk17。\n\n\n默认配置的是jdk8\n\n![默认配置的是jdk8](https://pic1.zhimg.com/80/v2-74721da129bc41b5d68c63a4f2000d24_720w.webp)\n\n如果要切换jdk11，则在终端中执行命令：jdk11。如果要切换回jdk8，则执行命令：jdk8。\n\n![](https://pic4.zhimg.com/80/v2-a2fb7aa3b118ee389c5a4ac902725b3b_720w.webp)\n\n如果要切换jdk17，则在终端中执行命令：jdk17。如果要切换回jdk8，则执行命令：jdk8。\n\n![](https://pic3.zhimg.com/80/v2-0f4935c193d27bded69db9b30c39e8ae_720w.webp)\n\n```\nJAVA_HOME_8=/Library/Java/JavaVirtualMachines/jdk1.8.0_341.jdk/Contents/Home\nJAVA_HOME_16=/Library/Java/JavaVirtualMachines/jdk-16.0.2.jdk/Contents/Home\nJRE_HOME=$JAVA_HOME/jre\nPATH=$PATH:$JAVA_HOME/bin\nCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.\nexport JAVA_HOME=$JAVA_HOME_8\nexport JRE_HOME\nexport PATH\nexport CLASSPATH\n\nalias jdk8=\"export JAVA_HOME=$JAVA_HOME_8\"\nalias jdk11=\"export JAVA_HOME=$JAVA_HOME_16\"\n```\n');
INSERT INTO `t_article_content` VALUES (11, 11, '在创建spring boot或者spring cloud项目时，idea默认使用https://start.spring.io作为脚手架，创建完成后手动去添加相关的jar包组合。\n\n通过https://start.aliyun.com 可以直接勾选ali相关的jar包，快速的引入集成。\n\n修改如下位置：如下图：\n\n![](https://img.arnasoft.site/weblog/e9d5f97963ce46139103e954ab2d625f.png)\n\n使用 `使用https://start.spring.io` 时如下图：\n\n![](https://img.arnasoft.site/weblog/50635fd3a05d4d61bfaa05057f697dfb.png)\n\n使用 时如下图：\n![](https://img.arnasoft.site/weblog/5e3c88ee233d4a15b846b94551a20f54.png)');
INSERT INTO `t_article_content` VALUES (12, 12, '今天突然发现自己的MySQL服务的密码有很多人知道，瞬间感觉不安全了 最初设想：\n\n1. 将[数据库](https://cloud.tencent.com/solution/database?from_column=20065&from=20065)内部所有库都导出来进行保存\n2. [容器](https://cloud.tencent.com/product/tke?from_column=20065&from=20065)删除\n3. 重新启一个服务并设置新的密码\n4. 将库导入\n\n好麻烦，并且最大缺点就是，如果当前有服务正在使用，这样那个服务不就要崩溃一段时间了吗？如果流量大的时候还会造成严重损失\n\n所以我决定找到可以直接修改MySQL密码的文章，找到了很多在本地修改MySQL密码的，也找到了容器上修改密码的。\n\n**然而一看可行，操作就废！** 最终东拼西凑，多次尝试终于有一个成功完成了，并且决心**写出傻瓜式操作的文章**，争取很多小伙伴使用的时候可以少浪费时间。\n\n接下来我将从部署到修改密码完整步骤展示出来。\n\n## \n\n## **1. 向 docker hub 拉去进行镜像到宿主机**\n\ndocker hub ：https://hub.docker.com/_/mysql?tab=tags\n\n拉取mysql镜像命令\n\n```javascript\ndocker pull mysql:8.0.28\n```\n\n复制\n\n或者不指定镜像版本（**这里以指定版本为例**）\n\n```javascript\ndocker pull mysql\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/88b18c61bb77c3328212a9ae6308d13f.jpeg)\n\n操作展示\n\n## **2. 查看镜像是否拉取成功**\n\n查看所有镜像命令\n\n```javascript\ndocker images\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/7b1358ade6a8d4c8560b93b52a67a8cd.jpeg)\n\n操作展示\n\n## **3. 创建mysql服务**\n\n```javascript\ndocker run -itd --name mysql8.0 -p 3306:3306 --restart=always -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.28\n```\n\n复制\n\n具体关键字内容可以单个查询这里不做过多介绍\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/e897308cf494dc56185e095c257c68ea.jpeg)\n\n操作展示\n\n## **4. 进入mysql容器**\n\n```javascript\ndocker exec -it mysql8.0 /bash \n```\n\n复制\n\n或者\n\n```javascript\ndocker exec -it mysql8.0 /bin/bash\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/9f5d4afac8e4b7a68ce818f5940dfcfc.jpeg)\n\n操作展示\n\n## **5.使用数据库**\n\n```javascript\nuse mysql;\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/4942eb3101d6f20b9ccfa6a2d6f39a16.jpeg)\n\n操作展示\n\n## **6. 查看数据库密码信息**\n\n```javascript\nselect host, user, authentication_string, plugin from user;\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/96d94426b4d1007a3a56c4cae672b22e.jpeg)\n\n操作展示\n\n## **7. 修改root密码**\n\n```javascript\nALTER USER \'root\'@\'%\' IDENTIFIED BY \'密码\' PASSWORD EXPIRE NEVER;\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/a8ac42974bf8bcd2410ce26da4eeb9ee.jpeg)\n\n操作展示\n\n### **7.1 查看是否有变动**\n\n```javascript\nselect host, user, authentication_string, plugin from user;\n```\n\n复制\n\n## **8. 修改本地密码**\n\n```javascript\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'lc123456\';\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/19c555d4de2d5d8047e66759f27c9be0.jpeg)\n\n操作展示\n\n### **8.1 查看是否有变动**\n\n```javascript\nselect host, user, authentication_string, plugin from user;\n```\n\n复制\n\n## **9. 退出Mysql和容器**\n\n两次exit\n\n```javascript\nexit\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/e961681e1b254cdd349741b8e30f5695.jpeg)\n\n操作展示\n\n## **10. 重启服务**\n\n```javascript\ndocker restart mysql8.0\n```\n\n复制\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/3644fd5a33e1435e31d5b348292a1038.jpeg)\n\n操作展示\n\n## **11. 验证是否成功**\n\n![img](//images.weserv.nl/?url=https://ask.qcloudimg.com/http-save/yehe-9978966/d7e56730c214daaaeb40979e11e1eab8.jpeg)');
INSERT INTO `t_article_content` VALUES (13, 13, '## 1. 什么是 Jenkins ?\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471707103654)\n\n> Jenkins 是**一个开源的持续集成（Continuous Integration）工具，它的主要作用是帮助开发团队自动化构建、测试和部署软件项目**。通俗来说，Jenkins 可以在每次代码变更时，帮助我们自动进行一系列的操作，例如编译代码、运行测试、生成文档，甚至是将应用程序部署到服务器上。\n\n## 2. 为什么要使用 Jenkins 呢？\n\n- **自动化构建和测试：** Jenkins 可以监视版本控制系统（如 Git）中的代码变更，一旦有新的提交，就触发自动构建和测试流程。这有助于发现潜在的问题，确保代码的质量。\n- **持续集成：** Jenkins 支持持续集成，即频繁地将小的代码变更合并到主干，并通过自动构建和测试来验证这些变更。这有助于减少集成问题，提高团队的协作效率。\n- **自动化部署：** Jenkins 可以自动化部署应用程序到测试环境、预生产环境甚至生产环境。通过定义部署流程，可以减少人为错误，确保部署的一致性。\n- **插件生态系统：** Jenkins 拥有丰富的插件生态系统，支持各种开发工具、构建工具和部署目标。这意味着你可以很容易地将 Jenkins 集成到你的开发工作流中。\n- **可扩展性：** Jenkins 是开源的，并且具有强大的可扩展性。你可以根据团队的需求定制自己的构建和部署流程，满足特定项目的要求。\n\n## 3. 拉取镜像\n\n打开命令行工具 `PowerShell` , 执行搜索命令，如下:\n\n```\ndocker search jenkins\n```\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471134398158)\n\n注意，从搜索结果中，你会看到官方提供的 `jenkins` 镜像描述，提示我们该镜像已经过期，不再维护了。浏览器访问 [DockerHub](https://hub.docker.com/r/jenkins/jenkins) , 搜索关键字 *jenkins* , 找到目前正在维护的版本，如下图所示，提示我们通过如下命令，来下载最新的 `LTS` 长期支持版本：\n\n```\ndocker pull jenkins/jenkins:lts-jdk17\n```\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471142307926)\n\n镜像下载成功后，通过 `docker images` 命令来检查一下镜像是否下载成功：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471148754819)\n\n## 4. 运行容器\n\n接着，执行如下命令来运行 `jenkins` 容器：\n\n```\ndocker run -d -u root -p 8080:8080 -p 50000:50000 -v E:\\docker\\jenkins2\\jenkins_home:/var/jenkins_home --name jenkins2 jenkins/jenkins:lts-jdk17\n```\n\n> 解释一下每个参数的含义：\n>\n> - **docker run:** 运行 Docker 容器的命令。\n>\n> - **-d:** 在后台运行容器，即“detached”模式。\n>\n> - **-u root:** 以 root 用户身份运行容器。这通常用于确保容器内的进程具有足够的权限执行需要的操作。\n>\n> - **-p 8080:8080:** 将容器内部的 8080 端口映射到宿主机的 8080 端口。Jenkins 服务通常在 8080 端口上运行。\n>\n> - **-p 50000:50000:** 将容器内部的 50000 端口映射到宿主机的 50000 端口。这是 Jenkins 使用的用于构建和执行任务的端口。\n>\n> - **-v E:\\docker\\jenkins2\\jenkins_home:/var/jenkins_home:** 将宿主机上的目录（E:\\docker\\jenkins2\\jenkins_home）挂载到容器内的 /var/jenkins_home 目录。这样可以确保 Jenkins 数据和配置持久化，即使容器被删除，数据仍然保存在宿主机上。\n>\n> - **--name jenkins2:** 为容器指定一个名称，即 \"jenkins2\"。\n>\n>   > TIP : 因为我本地之前测试的时候，已经命名了一个容器名为 jenkins , 这里演示为了防止冲突，命名的 jenkins2 。\n>\n> - **jenkins/jenkins:lts-jdk17:** 指定要运行的 Docker 镜像的名称和版本。在这里，使用的是 Jenkins 的 LTS 版本，内部使用的 JDK 17。\n\n命令执行后，执行 `docker ps` 命令来查看正在运行的容器，确认一下容器是否运行成功：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471177995761)\n\n## 5. 访问 Jenkins\n\n然后，打开浏览器访问 [http://localhost:8080](http://localhost:8080/) , 首次访问可能速度较慢，请耐心等待一会，会出现如下页面：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471193501174)\n\n需要你提供**管理员密码** ， 密码可以通过如下命令，来查看 `jenkins2` 容器的启动日志：\n\n```\ndocker logs jenkins2\n```\n\n在日志中，可以看到该密码，如下图所示，将其复制粘贴到输入框中，点击*继续*按钮：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471188631014)\n\n## 6. 安装插件\n\n接着，进入到如下页面，点击左边的*安装推荐的插件* ：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471198343894)\n\n开始安装 `jenkins` 需要的常用插件，过程比较慢，等待其全部安装完毕：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471214984133)\n\n## 7. 配置管理员用户\n\n插件安装完毕后，开始配置管理员用户：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471650265585)\n\n> **注意**： 后续再次登录 `jenkins` 后台需要，务必记住登录用户名和密码。\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471654746992)\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471450544577)\n\n点击*开始使用 Jenkins* 按钮，进入到 `Jenkins` 后台首页，如下图所示，至此，`Jenkins` 就安装好啦，是不是很简单：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471659718399)\n\n');
INSERT INTO `t_article_content` VALUES (14, 14, '## npm常用网址\n\n- [npmmirror 镜像站](https://npmmirror.com/)');
INSERT INTO `t_article_content` VALUES (15, 15, '1. 清除node缓存:`sudo npm cache clean -f`\n2. 安装 n 执行:`npm install n -g`\n   - 注意：如果报错如:code EACCES errno -13,表示你没有权限安装，使用管理员身份安装：`sudo npm i n -g`\n3. 查看n是否安装成功：`n -V`\n4. 使用n管理node\n   - 查看node可以使用的列表`n ls`\n   - 安装制定版本node\n     - 查看官方node版本 `npm view node versions` 或者 [node官网](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fzh-cn%2Fdownload%2Freleases%2F)\n     - 安装指定的node版本: `n node版本号` 如:`n 17.2.0`\n     - 注意：如果最终显示的还是原来node的版本号则需要在管理员权限下运行: `sudo n node版本号`\n5. 切换node版本\n   - 首先执行`n`，通过上下键进行切换选择，最后使用enter键选中版本。\n   - 如果选中后还是原来版本，则使用 `sudo n`，后再通过上下键进行切换选择，最后使用enter键选中版本。\n6. 删除指定版本node 运行命令 `n rm node版本号`或者运行` sudo n rm 10.13.1`\n7. 卸载 n 执行 `npm uninstall n -g`或`sudo npm uninstall n -g`\n8. node版本展示\n   - 列出最新的node版本 `n ls-remote`\n   - 列出11X的版本 `n ls-remote 11`\n9. 安装版本\n   - 安装最新正式发布版本 `sudo n latest`\n   - 安装最新的长期支持正式发布版本 `sudo n lts`\n   - 安装指定版本 `sudo n 14.14.0`\n  \n- [原链接](https://juejin.cn/post/7065701236925792293)');
INSERT INTO `t_article_content` VALUES (16, 16, '## docker redis 设置密码并启动\n```\ndocker run --name redis -p 6379:6379 -id redis --requirepass \"1234\"\n```\n\n## 登录 redis\n```\ndocker run -it redis redis-cli -h 172.17.0.1\n```\n\n## 查进程\n\n`docker ps`\n\n![查进程](https://img.arnasoft.site/weblog/16d8cc46d682484e861eee5eb03a77de.png)\n\n[docker 启动redis并设置密码与修改密码](https://juejin.cn/post/6951205777009410085)');
INSERT INTO `t_article_content` VALUES (17, 17, '## 一、Vconsole 简介\n\n一个轻量、可拓展、针对手机网页的前端开发者调试面板\n\n## 二、功能特性\n\n查看`console.log|info|...`日志、网络请求、HTML结构、本地存储等，在移动端网页调试非常方便。\n\n## 三、在Vue2中的使用\n\n1、安装\n\n```\n复制代码npm install vconsole -D\n```\n\n2、在 `main.js` 中引入\n\n```javascript\njavascript\n// 引入 Vconsole\nimport Vconsole from \'vconsole\'\n\n// 所有环境均使用\nnew Vconsole()\n\n// 在 test 环境才使用\nprocess.NODE_ENV === \'test\' ? new Vconsole : \'\'\n```\n\n## 四、在Vue3中使用\n\n1、安装\n\n```\n复制代码npm install vconsole vite-plugin-vconsole -D\n```\n\n2、`main.js`中引入\n\n```javascript\njavascript\nimport { createApp } from \'vue\'\nimport Vconsole from \'vconsole\'\n\nconst app = createApp(App)\napp.use(new Vconsole())\n```\n\n3、`vite.config.js`配置\n\n```javascript\njavascript\nimport { defineConfig, loadEnv } from \'vite\'\nimport path from \'path\'\nimport { viteVConsole } from \'vite-plugin-vconsole\'\n\nexport default ({ mode }) => {\n  return defineConfig({\n    // 需要用到的插件数组\n    plugins: [\n      vue(),\n      // VConsole 调试工具配置，若没有此配置，则调试工具控制台不会打印日志\n      viteVConsole({\n        entry: path.resolve(\'src/main.js\'), // 入口文件，或者可以使用这个配置: [path.resolve(\'src/main.ts\')]\n        localEnabled: false, // 本地是否启用\n        enabled: mode === \'test\', // 是否启用\n        config: {\n          maxLogNumber: 1000,\n          // theme: \'dark\' // 主题颜色\n        }\n      })\n    ],\n  })\n}\n```\n\n> 值得注意的是，在vue3项目中，可以直接在vite.config.js中配置完以后，不需要在main.js中再次引入就能够使用。');
INSERT INTO `t_article_content` VALUES (18, 18, '# IDEA 创建SpringBoot项目没办法选择jdk8\n\n由于在2023年11月27日更新后，`spring.io`默认不再支持创建`jdk1.8`的项目（算是强制性要求咱们用高版本的jdk吧），现在没办法直接通过`start.spring.io`来创建项目，看了网上的方法都是创建了项目后换`jdk`换`spring`版本之类的，实在是不太方便\n\n![](https://img.arnasoft.site/weblog/416d8c683c444806b7b30cfe1d53a180.png)\n\n这里可以使用更便捷的方式，直接替换`server url`，这里推荐使用阿里的服务器`url`来创建项目，地址如下：\n\n```\nhttps://start.aliyun.com/\n```\n![](https://img.arnasoft.site/weblog/2d25d4ff46094e3a93e8641b2b9c0466.png)\n');
INSERT INTO `t_article_content` VALUES (19, 19, '![useDark深色模式](https://img.arnasoft.site/weblog/8ac9804adcca4c98adf598dc1937f656.png)\n\n对于为什么用 useDark() 会导致过渡效果失效,一直找不到原因？\n```\nconst isDark = useDark()\nconst toggleDark = useToggle(isDark)\n```\n\n查看源码发现useDark（默认行为）会临时插入一个style并禁用transition，之后再移除，导致你的过渡失效了，你可以通过加上important解决，当然这个disableTransition也是可以传入useDark({disableTransition: false})这样也可以解决问题。\n```\nconst isDark = useDark({disableTransition: false})\nconst toggleDark = useToggle(isDark)\n```\n\n**相关网址**\n- [VueUse](https://vueuse.org/)\n- [使用 useDark(), 发现 transition 动画失效?](https://segmentfault.com/q/1010000043785052)');
INSERT INTO `t_article_content` VALUES (20, 20, '前段时间开发某个项目刚好需要引入字体用阿里巴巴的字体图标库 [](https://www.iconfont.cn/) ，平时搜某个图标后想批量导入到购物车，可惜阿里巴巴字体图标库目前还没加批量入库的功能，只能一个个点，这多麻烦。。。在这里给大家推荐一个方法，可以批量导入。\n1. 首先打开字体图标库 [iconfont](https://www.iconfont.cn/)\n2. 搜索 `java` 相关的图标，结果如下：\n   \n![](https://img.arnasoft.site/weblog/eb2ce362b4c64e25a7601ab0ddf702db.png)\n\n3. 如需要批量导入按F12打开控制台 `console`面板执行以下代码\n```js\ndocument.querySelectorAll(\'li:not(.selected) [title=添加入库]\').forEach(i=>i.click())\n```\n![](https://img.arnasoft.site/weblog/22e8d4739c8b4417af797bd19b4e9690.png)\n');
INSERT INTO `t_article_content` VALUES (21, 21, '## HTML\n\n### DOCTYPE有什么作用？\n\nDOCTYPE是一种指示浏览器以何种HTML或XHTML规范来解析文档的声明。它能够告知浏览器网页文档使用的标记语言的类型以及版本，从而确保浏览器能够正确地展示网页内容。DOCTYPE声明通常位于HTML文档的开头，是HTML文档的必须部分。\n\n\n\n### img标签的title和alt属性有什么区别\n\n`alt`属性用于为图像提供替代文本，即使图像无法加载，也可以描述图像内容，提高网页的可访问性和可用性。`title`属性则提供有关图像的额外信息，可以通过鼠标悬停或使用辅助技术来查看。它通常用于提供更多的上下文或补充描述，但并不是必需的。\n\n\n\n###  简述一下src与href的区别\n\n在 HTML 中，`src` 属性是用来指定外部资源的 URL，如图像、脚本或嵌入式对象的位置。例如，`<img>` 标签中的 `src` 属性指定图像的 URL。\n\n而 `href` 属性则用来指定超文本链接的目标资源的位置，如超链接或 `link` 标记中的外部样式表。例如，`<a>` 标签中的 `href` 属性指定了链接目标的 URL。\n\n\n\n### iframe有哪些优缺点？\n\n`iframe`（内联框架）是一种 HTML 元素，它允许在当前文档中嵌入另一个独立的 HTML 文档。`iframe` 有一些优点和缺点：\n\n优点：\n\n1. **内容隔离**：`iframe` 可以将不同来源的内容隔离开来，使得它们在不同的上下文中运行。这有助于保护当前文档免受潜在的安全风险，并确保不同来源的内容不会互相干扰。\n2. **异步加载**：`iframe` 中的内容可以异步加载，这意味着页面主体内容可以在 `iframe` 加载完成之前呈现。这有助于提高页面加载速度。\n3. **独立滚动**：`iframe` 内的内容可以独立滚动，而不会影响主页面的滚动。这有助于在需要展示大量内容的情况下，提高用户体验。\n4. **跨域资源访问**：在一定程度上，`iframe` 可以用于访问跨域资源，例如嵌入来自其他域的网页或应用。\n\n缺点：\n\n1. **性能影响**：`iframe` 的使用可能会导致性能下降，因为它需要浏览器加载额外的文档资源。每个嵌入的 `iframe` 都需要额外的 HTTP 请求，这可能会延长页面加载时间。\n2. **复杂性增加**：`iframe` 的使用可能会使页面结构更加复杂，导致维护困难。而且，在 `iframe` 和主页面之间进行通信可能会涉及到跨域问题，这会增加开发难度。\n3. **SEO 不友好**：搜索引擎可能无法完全索引 `iframe` 中的内容，这会影响到网页的搜索引擎优化（SEO）。\n4. **可访问性问题**：`iframe` 在某些情况下可能导致可访问性问题。例如，屏幕阅读器可能无法正确解析 `iframe` 中的内容，导致部分用户无法访问这些内容。\n\n综上所述，`iframe` 有一些优点，如内容隔离、异步加载和独立滚动等。然而，它也有一些缺点，如性能影响、复杂性增加、SEO 不友好和可访问性问题等。在使用 `iframe` 时，需要权衡这些优缺点，确保它适用于你的需求。\n\n\n\n### 常用的meta标签有哪些？\n\n`meta` 标签提供了有关 HTML 文档的元数据，如描述、关键词、作者等。以下是一些常用的 `meta` 标签：\n\n1. **字符集声明**：声明文档使用的字符编码，通常为 UTF-8。\n\n   ```html\n   <meta charset=\"UTF-8\">\n   ```\n\n2. **视口设置**：控制页面在移动设备上的显示方式，如缩放级别和页面宽度。\n\n   ```html\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   ```\n\n3. **页面描述**：提供页面的简短描述，有助于搜索引擎了解页面内容。\n\n   ```html\n   <meta name=\"description\" content=\"A brief description of the page.\">\n   ```\n\n4. **关键词**：设置页面关键词，有助于搜索引擎优化（SEO）。但请注意，大多数现代搜索引擎不再使用此标签。\n\n   ```html\n   <meta name=\"keywords\" content=\"keyword1, keyword2, keyword3\">\n   ```\n\n5. **作者**：指定页面作者。\n\n   ```html\n   <meta name=\"author\" content=\"Author Name\">\n   ```\n\n6. **禁止缓存**：告诉浏览器不要缓存页面。\n\n   ```html\n   <meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\">\n   <meta http-equiv=\"Pragma\" content=\"no-cache\">\n   <meta http-equiv=\"Expires\" content=\"0\">\n   ```\n\n7. **自动刷新**：设置页面在特定时间间隔后自动刷新。\n\n   ```html\n   <meta http-equiv=\"refresh\" content=\"30\">\n   ```\n\n8. **跳转到其他页面**：在指定的时间间隔后，自动将用户重定向到其他页面。\n\n   ```html\n   <meta http-equiv=\"refresh\" content=\"5; URL=https://example.com/new-page.html\">\n   ```\n\n9. **兼容模式**：指定浏览器（如 Internet Explorer）使用特定的渲染模式。\n\n   ```html\n   <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   ```\n\n10. **搜索引擎索引控制**：指示搜索引擎是否应索引页面和跟踪链接。\n\n    ```html\n    <meta name=\"robots\" content=\"index, follow\">\n    ```\n\n这些常用的 `meta` 标签可以帮助你控制页面的显示、搜索引擎优化和其他功能。根据页面需求，可以根据需要添加更多的 `meta` 标签。\n\n\n\n### H5和H4有什么不同？\n\n- 语义化标签: `header`、`footer`、`nav`、`section`、`article`、`aside` 等\n- 增强型表单：`date`(从一个日期选择器选择一个日期) 、`email`(包含 e-mail 地址的输入域) 、`number`(数值的输入域) 、`range`(一定范围内数字值的输入域) 、`search`(用于搜索域) 、`tel`(定义输入电话号码字段) 等\n- 视频和音频：`audio`、`video`\n- `Canvas`绘图、 `SVG`绘图\n- 地理定位：`Geolocation`\n- 拖放API：`drag`\n- `web worker`：是运行在后台的 `JavaScript`，独立于其他脚本，不会影响页面的性能\n- `web storage`: `localStorage`、`sessionStorage`\n- `WebSocket`: `HTML5` 开始提供的一种在单个 `TCP` 连接上进行全双工通讯的协议\n\n\n\n### SVG和CANVAS的区别？\n\nSVG和Canvas都是用于在web上绘制图形的技术，但它们有几个主要区别:\n\n1. SVG是基于矢量图的，而Canvas是基于像素图的。\n2. 在SVG中，每个绘制的元素都是一个独立的DOM对象，并且可以轻松地与JavaScript交互。 在Canvas中，所有绘制都被放置在一个画布中，并且只能与像素级别进行交互。\n3. SVG通常适用于静态图形，而Canvas适用于动态图形，例如游戏和数据可视化。\n\n简而言之，SVG适用于需要与DOM交互并具有复杂动画和交互的情况，而Canvas则适用于创建大量图形对象和复杂动画。\n\n\n\n### defer 和 async 的区别 ?\n\ndefer 和 async 都是用于脚本加载和执行的关键字，两者的主要区别如下：\n\n1. defer 脚本会在 HTML 文档解析完成后执行，而 async 脚本会在下载完毕后立即执行。\n2. defer 脚本会按照它们在文档中的顺序执行，而 async 脚本是在下载完成后尽快执行，可能会打乱它们在文档中的顺序。\n3. defer 脚本会在 DOMContentLoaded 事件之后运行，而 async 脚本则不一定。\n\n因此，如果需要按顺序执行脚本并且不想阻塞 DOM 的解析，可以使用 defer。如果脚本的执行不依赖于其他脚本或 DOM，可以使用 async 加快加载速度。\n\n\n\n### style标签prefetch和preload区别？\n\n`<style>`标签的`prefetch`和`preload`属性都用于优化CSS资源的加载，但它们有不同的行为和目的：\n\n- `prefetch`属性告诉浏览器这个CSS资源可能在未来的某个时刻需要被加载，但并不需要立即加载。浏览器会在空闲时间异步加载这个资源，以便在需要时能够立即使用。`prefetch`适用于那些当前不需要但是可能在未来会需要使用的资源。\n- `preload`属性则告诉浏览器这个CSS资源在当前页面中必须被使用，因此应该立即加载和执行。浏览器会在主HTML文档下载和解析完成之前加载这个资源。`preload`适用于那些当前需要使用的资源。\n\n\n\n<hr />\n\n## CSS\n\n### CSS 属性是否区分大小写？\n\nCSS 属性名和属性值在大多数情况下是不区分大小写的，但也有少数例外情况，如 font-variant 和 text-decoration 等属性与其值中的某些字母是区分大小写的。建议在编写 CSS 代码时还是严格遵守大小写以避免不必要的错误。\n\n\n\n### CSS的盒模型?\n\nCSS 盒模型包括标准盒模型和IE盒模型。其中标准盒模型（box-sizing: content-box;）的宽度和高度只包括内容的宽度和高度；而IE盒模型（box-sizing: border-box;）的宽度和高度则包括了内容、内边距和边框的宽度和高度。这两种盒模型的主要区别在于计算元素宽度和高度时所涉及的内容不同。\n\n\n\n### link与@import的区别\n\n`<link>`和`@import`都可以用来引入外部资源，如CSS文件，但是它们之间有以下区别：\n\n1. 引入方式：`<link>`是HTML标签，`@import`是CSS提供的一种方式。\n2. 加载顺序和性能：`<link>`在页面载入时同时加载，`@import`在页面载入完成后加载。\n3. 定义方式：`<link>`可以在文档头部定义，也可以在文档中任何地方定义，`@import`只能在样式表中定义。\n4. 加载方式：`<link>`可以同时加载多个外部样式表，而`@import`必须一条一条地执行。\n5. 附加功能：`link`标签支持添加一些额外属性，如`media`、`title`等，用于指定媒体类型或提供样式表的描述。`@import`不支持这些附加功能。\n6. 可控性：`<link>`支持动态插入，而`@import`不支持。\n\n\n\n### 元素垂直居中的方式有哪些？\n\n1. 使用flexbox布局，通过设置父元素的align-items属性为center实现元素垂直居中。\n2. 使用grid布局，可以通过设置网格项的align-self属性为center实现元素垂直居中。\n3. 使用position和transform属性，设置元素的top和left属性为50%，并使用transform属性的translate()函数将元素向上和左移动自身高度和宽度的一半，就可以实现元素垂直居中。\n4. 使用表格布局，将元素放入一个单元格中，并设置单元格的vertical-align属性为middle实现元素垂直居中。\n\n\n\n### 文本垂直居中的方式有哪些？\n\n1. 使用行高（line-height）属性，将行高设置为等于容器的高度减去文本行高，再将文本的行高设置为容器高度。\n2. 使用弹性盒子（flexbox）布局，在容器上设置 display:flex 和 align-items:center 属性。\n3. 使用网格布局（grid）将文本放置在居中单元格中。\n4. 使用绝对定位（absolute positioning）属性，并将文本的 top 和 bottom 都设置为 0，再设置 margin:auto 来水平居中\n\n\n\n### CSS 选择器的优先级是如何计算的？\n\n1. !important优先级最高\n2. 标签内样式：即在 HTML 标签内部使用 style 属性设置的样式，优先级第二高。\n3. ID选择器：以 # 符号开头，指定某个元素的唯一标识符，比如 #header，优先级第三高。\n4. 类选择器、属性选择器和伪类选择器：包括 .class、[attr]、:hover 等，优先级第四高。\n5. 元素选择器和伪元素选择器：包括 div、span、:before 等，优先级最低。\n\n在比较优先级时，遵循“从左到右，从高到低”的原则，也就是选择器中每增加一项就会降低一级别的优先级。如果两个选择器的优先级相同，则后面的选择器优先级更高。\n\n\n\n### 请阐述块格式化上下文（Block Formatting Context）、工作原理以及形成条件？\n\n块格式化上下文（Block Formatting Context，BFC）是一个独立的渲染区域，在这个区域内，元素的布局和外部元素互不影响。BFC是 Web 页面布局中的一种重要机制，主要用于控制块级元素的布局及其内部元素的排列方式。\n\nBFC的工作原理：\n\n1. 内部的块级盒子会在垂直方向一个接一个放置。\n2. 块级盒子的垂直间距（margin）会发生折叠。相邻的块级盒子的上下外边距会取最大值，而非相加。\n3. BFC的区域不会与浮动盒子重叠。在计算布局时，BFC会考虑浮动元素的占用空间，从而避免与浮动元素重叠。\n4. 计算BFC的高度时，浮动元素也参与计算。\n5. BFC是一个独立的容器，外部元素对其内部元素布局没有影响；同样，BFC内部元素的布局也不会影响外部元素。\n\n形成BFC的条件：\n\n要创建一个BFC，需要满足以下条件之一：\n\n1. 根元素（`<html>`）。\n2. 浮动元素（`float`属性为`left`或`right`）。\n3. 绝对定位元素（`position`属性为`absolute`或`fixed`）。\n4. 内联块（`display`属性为`inline-block`）。\n5. 表格单元格（`display`属性为`table-cell`）。\n6. 表格标题（`display`属性为`table-caption`）。\n7. 匿名表格单元格（`display`属性为`table`、`table-row`、`table-row-group`、`table-header-group`、`table-footer-group`、`table-column`、`table-column-group`）。\n8. 元素的`overflow`属性值不为`visible`（例如，`auto`、`scroll`、`hidden`）。\n9. 弹性盒子（`display`属性为`flex`或`inline-flex`）。\n10. 网格容器（`display`属性为`grid`或`inline-grid`）。\n11. 多列容器（`column-count`或`column-width`属性不为`auto`）。\n12. `contain`属性值为`layout`、`paint`或`strict`。\n\n通过满足以上条件之一，可以创建BFC，实现独立渲染区域。在实际应用中，BFC有助于解决外边距折叠、浮动元素引起的布局问题等。\n\n\n\n### 请阐述z-index属性，并说明如何形成层叠上下文（stacking context）\n\n`z-index`属性是CSS中用于控制元素在页面中的堆叠顺序（即在z轴上的顺序）的属性。具有较高`z-index`值的元素会覆盖较低`z-index`值的元素。需要注意的是，`z-index`属性只适用于具有定位属性（`position`属性值为`relative`、`absolute`或`fixed`）的元素。\n\n层叠上下文（Stacking Context）是一个抽象概念，它定义了一个元素在z轴上的层次。在同一个层叠上下文中，元素的堆叠顺序由`z-index`属性控制。层叠上下文可以嵌套，形成一个层叠上下文树。层叠上下文解决了多个元素重叠时的优先级显示。\n\n形成层叠上下文的条件：\n\n1. 根元素（`<html>`）。\n2. `z-index`值不为`auto`的定位元素（`position`属性值为`relative`、`absolute`或`fixed`）。\n3. `z-index`值不为`auto`的弹性盒子（`display`属性值为`flex`或`inline-flex`）的直接子元素。\n4. `z-index`值不为`auto`的网格容器（`display`属性值为`grid`或`inline-grid`）的直接子元素。\n5. `opacity`属性值小于1的元素。\n6. `transform`属性值不为`none`的元素。\n7. `filter`属性值不为`none`的元素。\n8. `perspective`属性值不为`none`的元素。\n9. `will-change`属性值指定了任意形成层叠上下文的属性的元素。\n10. `contain`属性值为`paint`或`strict`的元素。\n11. `mix-blend-mode`属性值不为`normal`的元素。\n12. `isolation`属性值为`isolate`的元素。\n\n满足以上任意条件之一的元素都会创建一个新的层叠上下文。在层叠上下文中，元素会根据其`z-index`值和其他因素进行堆叠。层叠上下文有助于更好地控制元素的堆叠顺序，解决元素覆盖和遮挡的问题。\n\n\n\n### CSS 有哪些继承属性？\n\n1. 文本和字体相关属性：\n   - `color`\n   - `font-family`\n   - `font-size`\n   - `font-weight`\n   - `font-style`\n   - `font-variant`\n   - `letter-spacing`\n   - `line-height`\n   - `text-align`\n   - `text-indent`\n   - `text-transform`\n   - `white-space`\n   - `word-spacing`\n2. 列表样式相关属性：\n   - `list-style-type`\n   - `list-style-position`\n   - `list-style-image`\n3. 表格布局相关属性：\n   - `border-collapse`\n   - `border-spacing`\n   - `caption-side`\n   - `empty-cells`\n   - `table-layout`\n4. 其他可继承属性：\n   - `visibility`\n   - `cursor`\n   - `quotes`\n   - `text-decoration`\n   - `text-shadow`\n   - `word-break`\n   - `word-wrap`\n   - `writing-mode`\n   - `direction`\n   \n\n\n\n### 有哪些清除浮动的技术，都适用哪些情况？\n\n1. 使用`clear`属性： 在浮动元素后添加一个空元素，然后使用CSS的`clear`属性来清除浮动。适用于简单布局和较早的浏览器版本。\n\n   ```css\n   <div style=\"float: left;\">...</div>\n   <div style=\"clear: both;\"></div>\n   ```\n\n2. 父元素使用`overflow`属性： 为父元素添加`overflow: auto`或`overflow: hidden`属性。此方法可以使父元素自动计算其高度，包括浮动元素。适用于不需要显示滚动条的布局。\n\n   ```css\n   .container {\n     overflow: auto;\n   }\n   ```\n\n3. 使用伪元素`::after`： 为父元素添加`::after`伪元素，并设置`clear: both`。这种方法不需要额外的HTML元素。适用于现代浏览器和简洁的HTML结构。\n\n   ```css\n   .container::after {\n     content: \"\";\n     display: table;\n     clear: both;\n   }\n   ```\n\n4. 使用Flexbox布局： 将父元素的`display`属性设置为`flex`。这会使所有子元素成为弹性项，并且不再需要清除浮动。适用于现代浏览器和需要使用弹性布局的场景。\n\n   ```css\n   .container {\n     display: flex;\n   }\n   ```\n\n5. 使用Grid布局： 将父元素的`display`属性设置为`grid`。这会使所有子元素成为网格项，并且不再需要清除浮动。适用于现代浏览器和需要使用网格布局的场景。\n\n   ```css\n   .container {\n     display: grid;\n   }\n   ```\n\n在实际项目中，选择哪种清除浮动的技术取决于项目的具体需求、浏览器兼容性和布局类型。现代项目通常更倾向于使用Flexbox或Grid布局来解决浮动问题。\n\n\n\n### 响应式布局有哪些\n\n响应式布局是一种使网站能够自动适应不同屏幕尺寸和设备类型的设计方法。以下是一些常见的响应式布局技术：\n\n1. 流式布局（Fluid Layout）： 使用百分比来定义元素的宽度，使元素随浏览器窗口大小变化而自动调整宽度。这种布局可以在一定程度上适应不同屏幕尺寸，但在极小或极大屏幕上可能无法提供最佳用户体验。\n2. 弹性布局（Flexible Layout）： 使用CSS3中的弹性盒子（Flexbox）布局模型，可以轻松创建自适应大小和顺序的布局。弹性布局可以根据屏幕尺寸自动调整元素的大小和排列，提供更好的响应式体验。\n3. 网格布局（Grid Layout）： 使用CSS3中的网格布局（Grid）模型，可以创建复杂的二维布局。网格布局允许在水平和垂直方向上自由排列和调整元素，从而实现高度自适应的响应式设计。\n4. 媒体查询（Media Queries）： 使用CSS3的媒体查询功能，可以针对不同屏幕尺寸、分辨率和设备类型应用特定的样式。结合流式布局、弹性布局和网格布局，媒体查询可以实现更精确和全面的响应式设计。\n5. 自适应图片（Responsive Images）： 使用`srcset`、`sizes`属性和`<picture>`元素，可以让浏览器根据设备像素比（DPR）和屏幕尺寸选择合适的图片资源。这样可以在不同设备上加载适当大小的图片，提高性能并保持视觉效果。\n6. 移动优先设计（Mobile-first Design）： 从移动设备的视角开始设计，然后逐步扩展到平板和桌面设备。这种设计方法强调简单、清晰和高效，可以提高跨设备的用户体验。\n\n在实际项目中，通常会综合运用以上技术来实现响应式布局。这些技术可以使网站在不同设备和屏幕尺寸下保持良好的用户体验和视觉效果。\n\n\n\n### 讲一下三栏布局实现？圣杯布局、双飞翼布局和flex布局\n\n三栏布局是指一个网页由三个栏目组成的布局，分别是左栏、右栏和中间栏。下面是三种实现三栏布局的方法：\n\n1. 圣杯布局\n\n圣杯布局是一种使用浮动和负边距实现的三栏布局。中间栏先放在html结构中，使用负边距将左右栏移动到中间栏的两侧，再使用相对定位将左右栏拉回原来的位置。这种布局可以使得中间栏优先渲染，兼顾SEO和用户体验。\n\n2. 双飞翼布局\n\n双飞翼布局也是一种使用浮动和负边距实现的三栏布局。与圣杯布局不同的是，左右栏使用margin负值撑开中间栏的宽度。这种布局与圣杯布局相比，代码更简单易懂。\n\n3. Flex布局\n\nFlex布局是CSS3引入的一种新的布局方式，通过flex容器和flex项目的属性设置，可以轻松实现三栏布局。设置左右栏的宽度为固定值，中间栏的宽度使用flex-grow属性自动填充。这种布局适用于移动端和PC端，具有响应式的特点。\n\n\n\n### 使用过哪些CSS预处理器？它们有什么优劣？\n\nLess和Sass这两个常见的CSS预处理器。它们的优势是可以使用变量、嵌套规则和函数等功能，可以更简单更高效地编写CSS代码。缺点是需要进行额外的预处理工作，增加了开发成本。\n\n\n\n### 如何解决CSS样式在不同浏览器中的兼容性问题？\n\n解决CSS样式在不同浏览器中的兼容性问题可以使用一些通用的方法，如使用CSS Reset，避免使用CSS Hack和浏览器前缀，使用标准的组件库，尽量使用标准的CSS属性和属性值等。\n\n\n\n### 如何制作一个自适应的正方形？\n\n在外层容器内创建一个正方形元素，并设置`padding-bottom`为100%。这里的关键是`padding-bottom`以父元素的宽度为基准计算，因此当设置为100%时，它将等于父元素的宽度，从而保证正方形的宽高相等。\n\n```html\n<div class=\"square-container\">\n  <div class=\"square\"></div>\n</div>\n```\n\n```css\n.square {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  padding-bottom: 100%; /* 确保正方形的高度等于宽度 */\n  background-color: #f00; /* 设置背景颜色以便观察效果 */\n}\n```\n\n\n\n### 讲讲margin塌陷和margin合并以及解决方案？\n\n**margin塌陷** 和 **margin合并** 都是 CSS 中描述 margin 行为的术语。它们分别指 margin 在不同场景下的特殊表现。\n\n1. **Margin塌陷**：Margin塌陷是指当一个元素的上外边距（margin-top）和相邻的另一个元素的下外边距（margin-bottom）相遇时，它们之间的距离实际上等于两个外边距中的较大值，而不是它们的总和。这种现象主要发生在具有相邻兄弟元素的块级元素之间。\n2. **Margin合并**：Margin合并是指在父子元素之间发生的现象。当一个元素的外边距与其父元素的外边距相遇时，它们之间的距离实际上等于两个外边距中的较大值，而不是它们的总和。Margin合并通常发生在没有边框、内边距或行内内容分隔的父元素与其第一个或最后一个子元素之间。\n\n解决方案：\n\n针对 margin 塌陷和合并的现象，有以下几种解决方案：\n\n1. **使用内边距（padding）**：如果适用，可以使用内边距代替外边距来调整元素之间的距离。内边距不会发生塌陷或合并。\n2. **添加边框（border）或内边距（padding）**：在父子元素间的 margin 合并问题上，可以通过给父元素添加一个边框或一个很小的内边距来阻止 margin 合并。\n3. **使用 BFC（块格式化上下文）**：创建一个新的 BFC（如通过设置 `overflow` 属性为 `auto` 或 `hidden`）可以防止父子元素间的 margin 合并。\n4. **使用伪元素**：可以通过在两个相邻的兄弟元素之间插入一个透明的伪元素（如 `::before` 或 `::after`），并为其添加 `display: inline-block;` 属性来防止兄弟元素间的 margin 塌陷。\n5. **避免使用外边距**：在某些情况下，可以使用其他布局技术（如 Flexbox 或 Grid）来调整元素之间的距离，从而避免 margin 塌陷和合并的问题。\n\n了解 margin 塌陷和合并现象以及如何解决这些问题可以帮助你更好地控制布局和元素间距。\n\n\n\n### 如何实现一个三角形？\n\n使用 CSS 创建一个三角形的常见方法是利用边框（border）属性。具体操作如下：\n\n1. 首先，创建一个宽高为0的元素（如 `div`），这样它的内容区域将不占据任何空间。\n2. 为该元素设置透明边框，这样它的边框也不会显示出来。\n3. 根据你需要的三角形方向，设置一个边框颜色，使该边框变得可见。\n\n以下是一个创建向上的三角形的示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<style>\n  .triangle {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n  }\n</style>\n</head>\n<body>\n  <div class=\"triangle\"></div>\n</body>\n</html>\n```\n\n在这个示例中，我们创建了一个名为 `.triangle` 的 `div` 元素。我们将其宽度和高度设置为 0，然后为其添加了左、右和底边框。左右边框设置为透明，底边框设置为红色。这将创建一个向上的红色三角形。\n\n\n\n### 如何画一条0.5px的线\n\n要在屏幕上绘制一条 0.5px 的线，可以使用 CSS 的伪元素 `::before` 或 `::after`，并设置它们的尺寸和缩放（scale）。以下是一个绘制 0.5px 水平线的示例：\n\n```css\n.half-pixel-line {\n    position: relative;\n    display: inline-block;\n    width: 100%;\n    height: 1px;\n}\n  \n.half-pixel-line::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 1px;\n    background-color: black;\n    transform-origin: left top;\n    transform: scaleY(0.5);\n}\n```\n\n\n\n### 视差滚动效果的原理？\n\n视差滚动效果（Parallax Scrolling）是一种视觉设计技巧，通过在页面滚动时以不同速度移动前景和背景元素，从而产生深度感和动态效果。这种效果可以使网页看起来更有趣、更具吸引力。\n\n视差滚动效果的原理在于，当用户滚动页面时，页面上的不同元素（例如前景、背景、文字等）以不同的速度移动。这些速度差使得靠近观察者的元素（前景）看起来移动得更快，而远离观察者的元素（背景）看起来移动得更慢。这种相对运动产生了一种错觉，使用户感觉到页面的不同部分之间有深度关系，从而增强了视觉体验。\n\n要实现视差滚动效果，可以使用以下方法之一：\n\n1. **纯 CSS 方法**：利用 CSS3 的 `background-attachment` 属性设置为 `fixed`。这种方法简单易实现，但仅适用于背景图像，并且在某些浏览器或设备上可能存在兼容性问题。\n2. **JavaScript 方法**：通过监听页面滚动事件，根据滚动位置动态调整元素的位置。这种方法更灵活，可以应用于任何元素，并且可以实现更复杂的视差效果。通常使用 JavaScript 库（如 Rellax.js、Parallax.js 等）来简化开发过程。\n\n需要注意的是，过多或不合适的视差滚动效果可能会导致页面性能下降、用户体验受损，因此在实现视差滚动效果时要保持适度。\n\n\n\n<hr />\n\n## JavaScript\n\n### js有哪些内置对象？\n\nJavaScript有许多内置对象，包括但不限于：\n\n- 基本对象： Object、Boolean、Symbol、Number、String\n- 符合数据结构：Array、Set、Map、WeakSet、WeakMap\n- 日期和时间对象：Date\n- 数学计算对象：Math\n- 正则表达式对象：RegExp\n- 函数对象：Function\n- 错误对象：Error、TypeError、RangeError等\n- 其他对象：Global、JSON等\n\n\n\n### 什么是闭包？\n\n闭包是指一个函数可以访问另一个函数作用域内的变量。当一个函数嵌套在另一个函数中时，内部函数可以访问外部函数的变量，即使外部函数已经返回了。这种情况下，内部函数形成了一个闭包，它保留了外部函数的作用域链并可以继续访问这些变量。闭包常常用于实现函数的封装和私有化，以及在回调和事件处理等场景下的数据共享与传递。\n\n\n\n### 如何理解作用域、作用域链和执行上下文？\n\n在JavaScript中，作用域、作用域链和执行上下文是密切相关的概念，它们与变量和函数的查找、访问以及生命周期有关。\n\n1. 作用域（Scope）：\n\n   **作用域是一个变量或函数的可访问范围**。JavaScript中有三种作用域：**全局作用域**、**局部（函数）作用域**和**块级作用域**。全局作用域中声明的变量和函数可以在整个代码中访问，局部作用域中声明的变量和函数只能在特定的函数内部访问，块级作用域在一对花括号内定义，对`let`和`const`关键字声明的变量有效。\n\n   变量的生命周期受其作用域的限制。全局作用域中的变量在整个程序执行过程中持续存在，局部作用域中的变量在函数执行结束时销毁，块级作用域在代码块执行结束时，块级作用域中的变量将被销毁。\n\n2. 作用域链（Scope Chain）：\n\n   **当代码执行过程中访问一个变量或函数时，JavaScript引擎会沿着作用域链查找该标识符**。作用域链是由当前执行上下文的作用域和其所有父级作用域组成的链表。\n\n   查找过程从当前作用域开始，然后逐级向上查找，直到找到目标标识符或到达全局作用域。如果在全局作用域中仍未找到目标标识符，则返回`undefined`。\n\n3. 执行上下文（Execution Context）：\n\n   **执行上下文是JavaScript代码执行过程中的环境**。每当进入一个新的函数执行或全局代码执行时，都会创建一个新的执行上下文。执行上下文包含了当前执行的代码所需的所有信息，如变量、函数、作用域链等。\n\n   JavaScript引擎使用执行上下文栈（Execution Context Stack）来管理执行上下文。栈顶的执行上下文为当前执行的代码环境。当一个函数被调用时，一个新的执行上下文被压入栈顶；当函数执行结束时，执行上下文从栈顶弹出，返回到调用者的上下文环境。\n\n总结起来，作用域是变量和函数的可访问范围；作用域链是由当前执行上下文的作用域和其父级作用域组成的链表，用于在代码执行过程中查找变量和函数；执行上下文是代码执行过程中的环境，包含了当前执行的代码所需的所有信息。这三者共同决定了代码执行过程中变量和函数的查找、访问以及生命周期。\n\n\n\n### 如何创建一个没有原型的对象？\n\n可以使用 Object.create(null) 方法创建一个没有原型的对象。这个方法创建一个全新的对象并将其原型设置为 null，因此它没有继承任何属性或方法。例如：\n\n```js\nconst obj = Object.create(null);\nconsole.log(obj.toString); // undefined\n```\n\n\n\n### 如何理解原型链？\n\n原型链是 JavaScript 中实现继承的一种机制，它通过让一个对象的原型指向另一个对象，从而使得一个对象可以访问另一个对象中定义的属性和方法。当我们试图访问一个对象中不存在的属性或方法时，JavaScript 引擎会沿着原型链一直向上查找，直到找到该属性或方法为止，或者最终抵达 Object.prototype（所有对象的祖先）上停止查找。\n\n\n\n### let const var比较\n\n1. 作用域：\n   - `var`：声明的变量具有函数作用域。这意味着在函数内部声明的变量只能在该函数内部访问，而在函数外部声明的变量具有全局作用域。\n   - `let`和`const`：声明的变量具有块级作用域。这意味着变量仅在声明它们的代码块（例如：`if`语句、`for`循环、`while`循环等）内部可访问。\n2. 变量提升（Hoisting）：\n   - `var`：声明的变量会被提升到所在作用域的顶部。这意味着在声明之前访问变量不会导致引用错误，但变量的值将是`undefined`。\n   - `let`和`const`：声明的变量不会被提升。在声明之前访问变量会导致引用错误。\n3. 重复声明：\n   - `var`：允许在同一作用域内多次声明同名变量，后续声明将被忽略。\n   - `let`和`const`：在同一作用域内不允许重复声明同名变量。尝试这样做会导致语法错误。\n4. 变量的可变性：\n   - `var`和`let`：声明的变量可被重新赋值。\n   - `const`：声明的变量是不可变的，即一旦赋值，无法更改。这对于声明常量或确保某个变量在整个程序执行过程中保持不变的情况非常有用。\n\n\n\n### 谈谈你对变量提升的理解\n\n变量提升（Hoisting）是 JavaScript 的一个核心概念，理解它对于编写和理解代码非常重要。以下是我对变量提升的理解：\n\n1. 什么是变量提升：在 JavaScript 中，变量和函数声明（使用var和function）在内部会被“提升”到它们所在作用域（全局或函数）的顶部。这意味着在代码执行之前，JavaScript 引擎已经知道这些变量和函数的存在，即使它们在源代码中的位置可能在后面。\n2. 声明与赋值：需要注意的是，提升只作用于声明，不作用于赋值或初始化。如果一个变量在后面被赋值，那么它在提升时仍被认为是`undefined`。只有当执行到赋值语句时，它才会被赋予特定的值。\n3. var, let, const：只有用`var`声明的变量会被提升。用`let`和`const`声明的变量也有类似的提升行为，但由于它们存在“暂时性死区”（Temporal Dead Zone，TDZ），在声明前对它们的访问会导致错误。\n4. 函数提升：函数声明也会被提升，并且优先级高于变量。如果一个函数和一个变量同名，且变量未被赋值，那么该名称指向函数。\n\n\n\n### JSON.stringify有什么缺点？\n\n`JSON.stringify()`是一个将JavaScript对象转换为JSON字符串的方法。尽管它在许多情况下非常有用，但它确实存在一些限制和缺点：\n\n1. 循环引用：`JSON.stringify()`无法处理具有循环引用的对象。如果一个对象的属性直接或间接引用了自身，`JSON.stringify()`将抛出一个错误，表示存在循环引用。\n2. `undefined`、函数和Symbol忽略：`JSON.stringify()`不会序列化对象中的`undefined`、函数和Symbol类型的属性。这些属性将被忽略，不会出现在生成的JSON字符串中，单独转换则会返回`undefined`。\n3. 丢失原型链：在对象序列化后，原型链上的属性和方法将丢失。只有对象自身的可枚举属性会被序列化。因此，在反序列化（使用`JSON.parse()`）后，原始对象的原型链信息将不复存在。\n4. 日期对象处理：当使用`JSON.stringify()`序列化日期对象时，日期对象会被转换为它们的ISO字符串表示形式。在反序列化时，这些日期将被视为普通字符串，而不是日期对象。\n5. 非数组和非对象的值：对于不是数组或对象的顶层值（例如：字符串、数字、布尔值等），`JSON.stringify()`会直接返回其对应的JSON表示，而不会将其包装在对象或数组中。\n\n\n\n### for...in 和 for...of的区别?\n\nfor...in循环用于遍历对象的可枚举属性，返回的是属性名称；for...of循环用于遍历可迭代对象（如数组、字符串、Map、Set等），返回的是元素值。\n\n\n\n### new操作符都做了什么\n\n1. 创建一个新对象\n2. 对象的`__proto__`指向构造函数的`prototype`\n3. 构造函数将对象绑定到`this`并调用\n4. 如果构造函数返回对象或函数则直接返回，否则返回这个新对象\n\n\n\n### 类数组和数组的区别，dom 的类数组如何转换成数组\n\n类数组（Array-like）和数组（Array）都是用于存储多个值的数据结构，但它们之间存在一些关键区别：\n\n1. 类型：数组是JavaScript的内置对象类型，继承自`Array.prototype`，具有一系列数组方法（如`push()`、`pop()`、`map()`等）。类数组是普通的对象，其属性名为索引（如`0`、`1`、`2`等），具有一个`length`属性，但不具备数组的方法。\n2. 原型：数组的原型为`Array.prototype`，因此具有数组的所有方法。类数组的原型通常为`Object.prototype`，并不包含数组的方法。\n\n要将DOM的类数组（例如，通过`document.getElementsByClassName()`或`document.querySelectorAll()`获取的元素集合）转换为数组，可以使用以下方法之一：\n\n1. 使用`Array.from()`方法：\n\n   ```js\n   let nodeList = document.querySelectorAll(\'div\');\n   let array = Array.from(nodeList);\n   ```\n   \n   `Array.from()`方法会创建一个新数组，并将类数组的元素逐个复制到新数组中。\n   \n2. 使用扩展运算符（Spread Operator）：\n\n   ```js\n   let nodeList = document.querySelectorAll(\'div\');\n   let array = [...nodeList];\n   ```\n   \n   扩展运算符`...`可以将类数组直接转换为数组。\n   \n3. 使用`Array.prototype.slice.call()`：\n\n   ```js\n   let nodeList = document.querySelectorAll(\'div\');\n   let array = Array.prototype.slice.call(nodeList);\n   ```\n   \n\n`Array.prototype.slice.call()`方法会将类数组作为上下文，并创建一个新数组，将类数组的元素逐个复制到新数组中。\n\n这些方法可以将类数组转换为数组，这样就可以在转换后的数组上使用数组的方法了。注意，这些方法不仅适用于DOM类数组，还适用于其他类数组对象。\n\n\n\n### offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别\n\noffsetWidth/offsetHeight是元素的可见宽度/高度加上padding、border和滚动条（如果存在）的宽度/高度。\n\nclientWidth/clientHeight是元素的可见宽度/高度，不包括padding和滚动条。\n\nscrollWidth/scrollHeight是元素内容的完整宽度/高度，包括溢出部分。如果元素没有溢出，则scrollWidth/scrollHeight等于clientWidth/clientHeight。如果有溢出，则scrollWidth/scrollHeight大于clientWidth/clientHeight。\n\n\n\n### mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系\n\nmouseover和mouseout是HTML DOM事件，它们会在鼠标移入或移出元素时触发。它们也会在鼠标指针进入或离开**子元素**时触发。这也就是说，如果在父元素上有mouseover事件，并且鼠标指针进入子元素，则该元素上仍然会触发mouseover事件。mouseout同理。\n\nmouseenter和mouseleave事件也是在鼠标进入或离开元素时触发。与mouseover和mouseout不同的是，mouseenter和mouseleave事件**不会传播到子元素**。因此，如果鼠标指针进入或离开元素的子元素，则不会触发mouseenter和mouseleave事件。\n\n\n\n### event.stopPropagation()与event.stopImmediatePropagation的区别\n\nevent.stopPropagation()可以阻止事件冒泡到父元素，但不阻止其他事件处理程序的执行。而event.stopImmediatePropagation()可以立即阻止事件冒泡并取消同一元素上其他事件处理程序的执行。\n\n\n\n### 说一下事件循环机制Event Loop\n\n事件循环（Event Loop）是 JavaScript 运行时环境中的一个核心概念，它负责协调异步操作和同步代码的执行。JavaScript 是单线程的，这意味着它一次只能执行一个任务。事件循环使 JavaScript 能够在执行同步代码的同时，处理异步操作（如定时器、用户交互和网络请求）的回调。\n\n事件循环的工作原理大致如下：\n\n1. 首先，JavaScript 引擎执行全局同步代码（例如来自`<script>`标签或 Node.js 文件的代码）。\n2. 当遇到异步操作（如 `setTimeout`、`setInterval`、`Promise`、`fetch` 等），它们的回调函数会被放入相应的任务队列中（微任务队列或宏任务队列）。\n3. 同步代码执行完成后，事件循环开始检查微任务队列。如果队列中有任务，事件循环将依次执行它们，直到队列为空。\n4. 接下来，事件循环检查宏任务队列。如果队列中有任务，事件循环将执行第一个任务，然后返回到微任务队列，检查是否有新的微任务需要执行。\n5. 事件循环在微任务队列和宏任务队列之间循环，依次执行队列中的任务。当两个队列都为空时，事件循环将等待新的任务（如用户交互或网络请求回调）。\n6. 当新任务出现时，事件循环将其添加到相应的队列中，并继续循环执行任务。\n\n事件循环的目标是在处理同步代码和异步回调之间保持平衡，确保 JavaScript 代码的执行效率和响应能力。通过这种方式，事件循环允许 JavaScript 在单线程环境中有效地处理并发操作。\n\n\n\n### esm和commonjs的区别\n\nESM（ECMAScript Modules）和 CommonJS 是 JavaScript 中两种不同的模块系统。它们都允许将代码拆分成可重用的模块，并在需要时导入这些模块。尽管它们都实现了相似的功能，但它们之间存在一些关键差异：\n\n1. 语法：ESM 和 CommonJS 使用不同的语法来导入和导出模块。\n\n   - ESM 使用 `import` 和 `export` 关键字\n   - CommonJS 使用 `require` 和 `module.exports`关键字\n\n2. 运行时加载与静态加载：\n\n   - CommonJS 是**运行时加载**，这意味着模块在运行时解析和加载。因此，在运行时可以动态修改模块和依赖关系。\n   - ESM 是**静态加载**，这意味着模块在编译时解析和加载。这允许更好的优化，如代码消除和更快的加载速度，但不允许在运行时动态修改模块。\n\n3. 作用域：ESM 和 CommonJS 在处理变量作用域方面有所不同。\n\n   - ESM 使用**模块作用域**，每个模块具有自己的顶级作用域。在模块内声明的变量不会污染全局作用域。\n   - CommonJS 使用**文件作用域**，但与 ESM 不同，CommonJS 模块可以通过 `global` 对象访问全局作用域。\n\n4. 循环依赖：ESM 和 CommonJS 处理循环依赖的方式不同。\n\n   - ESM 可以更好地处理循环依赖，因为模块是静态加载的。在循环依赖中，导入的值可能是不完整的，但不会导致错误。\n   - CommonJS 在处理循环依赖时可能会遇到问题，因为模块是运行时加载的。这可能导致在循环依赖中的模块中获得一个不完整的对象。\n\n5. 兼容性和使用场景：\n\n   - CommonJS 主要用于 Node.js 环境，因为它是 Node.js 的原生模块系统。虽然现代 Node.js 版本也支持 ESM，但很多旧的 Node.js 代码仍使用 CommonJS。然而，许多新的 Node.js 项目逐渐采用 ESM。\n   - ESM 通常用于现代 Web 开发，因为大多数现代浏览器原生支持 ESM。在使用构建工具（如 Webpack、Rollup 或 Parcel）时，ESM 也提供了更好的优化和打包能力。\n\n6. 实时绑定与值拷贝：\n\n   - ESM 使用**实时绑定**，当导入的值发生更改时，导入模块的值也会跟着更改。这意味着导入的值始终保持最新。\n   - CommonJS 使用**值拷贝**，当模块被导入时，值被复制到导入模块。这意味着在导入模块中，值的更改不会反映到原始模块，导入的值在导入时是固定的。\n\n7. 导出值：\n\n   - ESM 导出值是**映射关系**，**可读，不可修改**，但可通过导出的函数修改导出的值。\n   - CoomonJS 导出**值的拷贝**，**可以修改导出的值**。\n\n8. export使用：\n\n   - ESM export和export default支持一起使用。\n   - CoomonJS module.exports和exports不支持一起使用，会被覆盖。\n\n   \n\n总结一下，ESM 和 CommonJS 的主要区别在于它们的语法、加载机制、作用域、循环依赖处理、兼容性和使用场景以及实时绑定与值拷贝。尽管它们在某些方面有所不同，它们都是为了解决 JavaScript 模块化编程的问题。\n\n\n\n### 解释下JavaScript栈内存和堆内存？\n\n在 JavaScript 中，栈内存（Stack Memory）和堆内存（Heap Memory）扮演着不同的角色，它们分别负责存储不同类型的数据。以下是它们在 JavaScript 中的简要说明：\n\n1. 栈内存（Stack Memory）：\n   - 栈内存主要用于存储基本类型（原始类型）的值，如 `number`、`string`、`boolean`、`null` 和 `undefined`。这些类型的值通常较小且固定大小。\n   - 栈内存还负责存储函数调用的执行上下文、局部变量和临时数据。\n   - 栈内存遵循后进先出（LIFO）的原则进行分配和释放空间。当函数被调用时，函数的执行上下文、局部变量和相关信息会被压入栈中；当函数返回时，这些数据会从栈中弹出。\n   - 栈内存的分配和回收速度较快，因为内存管理由 JavaScript 引擎自动完成。\n   - 由于栈内存有限，如果递归调用过深或者分配大量的局部变量，可能导致栈溢出。\n2. 堆内存（Heap Memory）：\n   - 堆内存主要用于存储引用类型的值，如对象（`object`）、数组（`array`）和函数（`function`）。这些类型的值通常较大，大小不固定。\n   - JavaScript 引擎使用垃圾回收机制自动管理堆内存中的对象。当对象不再被引用时，它们会被标记为垃圾，并在下一次垃圾回收时释放内存。\n   - 与栈内存相比，堆内存分配和回收速度较慢，因为需要管理更复杂的数据结构和垃圾回收机制。\n   - 堆内存可以动态分配，因此可以存储更多数据。\n   - 如果没有正确处理引用关系，可能导致内存泄漏。\n\n总结一下，在 JavaScript 中，栈内存用于存储基本类型的值、函数调用的执行上下文和局部变量，堆内存用于存储引用类型的值。理解栈内存和堆内存的差异有助于编写高效且内存友好的 JavaScript 程序。\n\n\n\n### 箭头函数与普通函数区别？\n\n箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、`this` 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：\n\n1. `this` 关键字绑定：\n   - 箭头函数没有自己的 `this`，它从包围它的普通函数或全局作用域继承 `this`。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 `this`。\n   - 普通函数有自己的 `this`，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），`this` 的值可能会有所不同。\n2. arguments 对象：\n   - 箭头函数没有自己的 `arguments` 对象。它们可以访问包围它们的普通函数的 `arguments` 对象。\n   - 普通函数有自己的 `arguments` 对象，这是一个类数组对象，包含了传递给函数的参数。\n3. 构造函数行为：\n   - 箭头函数不能作为构造函数使用，因此不能使用 `new` 关键字调用。它们也没有 `prototype` 属性。\n   - 普通函数可以作为构造函数使用，通过 `new` 关键字创建新的对象实例。\n4. 原型链：\n   - 由于箭头函数没有 `prototype` 属性，它们不能作为其他对象的原型。\n   - 普通函数有 `prototype` 属性，可以作为其他对象的原型。\n5. 生成器：\n   - 箭头函数不能使用`yield`关键字。\n   - 普通函数可以使用`yield`关键字变成生成器函数。\n\n\n\n### 箭头函数的this是声明时确定还是调用时确定？\n\n箭头函数的 `this` 是根据其被声明的位置来确定的，而不是它被调用的位置。这个特性称为\"词法作用域\"或者\"静态作用域\"。箭头函数不会创建自己的 `this`，它会从自己的作用域链上一层继承 `this`。\n\n\n\n### isNaN与Number.isNaN的区别\n\nisNaN函数用于检查一个值是否是NaN，它会将传入的参数先转换为数字类型再进行判断。如果传入的参数无法转换为数字类型，则会返回true。\n\n而Number.isNaN用于检查一个值是否为NaN，但它不会将参数转换为数字类型，只有在参数本身就是NaN时才返回true。否则，返回false。\n\n\n\n### 谈谈你对this的理解\n\n在 JavaScript 中，`this` 是一个特殊的关键字，它在函数调用时动态地引用了一个对象。`this` 的值取决于函数的调用方式，不同的调用方式会导致 `this` 指向不同的对象。以下是一些关于 `this` 的不同用法和场景：\n\n1. 全局上下文：\n\n   当在全局作用域中使用 `this` 时，它指向全局对象。在浏览器环境中，全局对象是 `window`；在 Node.js 环境中，全局对象是 `global`。\n\n2. 函数调用：\n\n   当在函数内部使用 `this` 且函数作为普通函数调用时（非对象方法调用），`this` 通常指向全局对象。但在严格模式下（使用 `\"use strict\"`），`this` 会被设置为 `undefined`。\n\n3. 对象方法调用：\n\n   当在对象的方法内部使用 `this` 时，`this` 指向调用该方法的对象。这也适用于原型链中的方法。\n\n4. 构造函数调用：\n\n   当在构造函数内部使用 `this` 且使用 `new` 关键字调用构造函数时，`this` 指向新创建的对象实例。\n\n5. 显式绑定：\n\n   使用 `call`、`apply` 或 `bind` 方法调用函数时，可以显式地将 `this` 绑定到一个指定的对象。\n\n6. 箭头函数：\n\n   箭头函数没有自己的 `this`，它从包围它的普通函数或全局作用域继承 `this`。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 `this`。\n\n总之，`this` 是 JavaScript 中一个动态上下文的关键字，它的值取决于函数调用的方式。\n\n\n\n### 谈谈你对严格模式的理解\n\n在JavaScript中，严格模式（strict mode）和非严格模式（sloppy mode）主要有以下几个区别：\n\n1. 变量声明： 在严格模式下，必须明确地声明变量（使用`let`、`const`或`var`关键字）。否则，将会抛出一个引用错误（ReferenceError）。在非严格模式下，如果没有声明变量，JavaScript会自动将其声明为全局变量，这可能会导致意外的全局污染。\n2. this指针： 在严格模式下，全局作用域中的`this`值为`undefined`。在非严格模式下，全局作用域中的`this`值为全局对象（浏览器环境中为`window`对象，Node.js环境中为`global`对象）。此外，在严格模式下，不允许使用`call`、`apply`或`bind`将`this`值设置为`null`或`undefined`。\n3. 禁止使用未来保留字： 严格模式中，不能将一些未来保留字（如`implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static`和`yield`）用作变量名或函数名。\n4. 禁止使用八进制字面量： 在严格模式下，不允许使用八进制字面量（如`0123`）。非严格模式下，八进制字面量是允许的。\n5. 禁止删除变量、函数和函数参数： 严格模式中，使用`delete`操作符删除变量、函数和函数参数会引发语法错误（SyntaxError）。在非严格模式下，这样的操作是允许的，但实际上不会删除这些对象。\n6. 限制函数参数的重复声明： 在严格模式下，如果一个函数具有多个相同名称的参数，将会抛出一个语法错误。非严格模式下允许这种重复声明，但只有最后一个参数值会生效。\n7. 错误处理： 严格模式相较于非严格模式，更严格地处理某些类型的错误。例如，当试图修改只读属性、给不可扩展的对象添加属性或删除不可配置的属性时，严格模式会抛出类型错误（TypeError），而非严格模式下则会静默失败。\n\n要启用严格模式，可以在脚本或函数开头添加`\"use strict\";`指令。这将对整个脚本或函数体中的代码启用严格模式。推荐使用严格模式编写代码，因为它可以帮助发现潜在的错误并避免一些不良的编程实践。\n\n\n\n### 谈谈你对Promise的理解\n\nPromise是一种在JavaScript中用于处理异步操作的编程模式。它表示一个尚未完成但预计在未来某个时刻完成的操作的结果。Promise允许我们以更简洁、易读的方式处理异步操作，避免了传统的回调地狱（callback hell）问题。\n\nPromise有三种状态：\n\n1. pending（待定）：初始状态，既不是fulfilled，也不是rejected。\n2. fulfilled（已实现）：表示异步操作已成功完成。\n3. rejected（已拒绝）：表示异步操作失败。\n\nPromise具有以下特点：\n\n1. Promise对象是不可变的，一旦创建，其状态就不能再被改变。\n2. Promise状态只能从pending变为fulfilled或rejected，不能逆向改变，且只能改变一次。\n3. Promise允许我们将成功和失败的处理函数分开，增加代码的可读性。\n\n缺点：\n\n1. 无法取消：一旦创建了 Promise，就无法取消它。这可能导致在某些情况下，不再需要结果的异步操作仍然在执行。\n2. 总是异步：Promise 的回调总是异步执行，即使操作已经完成。这可能会导致一些意外的行为，特别是在执行顺序敏感的情况下。\n3. 调试困难：由于 Promise 的链式调用和异步特性，调试 Promise 可能比调试同步代码更具挑战性。错误堆栈可能不够清晰，难以确定问题出在哪里。\n\nPromise基本用法包括：\n\n1. 创建Promise对象：通过`new Promise(executor)`创建一个Promise对象，其中executor是一个执行器函数，接受两个参数：resolve和reject。成功时调用resolve函数并传递结果，失败时调用reject函数并传递原因。\n2. 链式调用：通过`.then()`方法处理fulfilled状态，接受一个回调函数作为参数，当Promise状态变为fulfilled时调用。`.catch()`方法处理rejected状态，接受一个回调函数作为参数，当Promise状态变为rejected时调用。\n3. Promise.all：接受一个Promise数组作为参数，当所有Promise都变为fulfilled状态时返回一个新的Promise，其值为所有Promise结果的数组。如果有任意一个Promise变为rejected状态，则返回的Promise也变为rejected，且返回原因是第一个rejected的Promise的原因。\n4. Promise.race：接受一个Promise数组作为参数，返回一个新的Promise，其状态和结果与第一个完成（无论是fulfilled还是rejected）的Promise相同。\n\n通过使用Promise，我们可以更有效地处理异步操作，降低代码复杂性，提高可维护性。在现代JavaScript开发中，Promise已成为处理异步操作的重要基石。\n\n\n\n\n\n### 为什么0.1+0.2不等于0.3\n\n在JavaScript（以及许多其他编程语言）中，0.1 + 0.2 不等于 0.3 的原因是浮点数精度问题。JavaScript使用IEEE 754标准中规定的双精度浮点数（double-precision floating point）来表示数字。这种表示方法在大多数情况下都很有效，但有时会导致精度损失。\n\n双精度浮点数只有有限的位数（64位）来表示数字，其中1位表示符号位，11位表示指数，以及52位表示尾数。当尝试表示某些数字（特别是十进制小数）时，它们的二进制表示可能是无限循环的，因此需要截断以适应有限的位数。这可能导致浮点数的近似值与实际值之间存在微小差异。\n\n在本例中，0.1和0.2的二进制表示都是无限循环的，需要截断。当它们被截断并以双精度浮点数存储时，这两个数字的实际值与理论值略有不同。因此，当执行0.1 + 0.2时，结果也会有微小误差，与0.3的理论值不完全相等。\n\n为了解决这个问题，可以将结果四舍五入到所需的精度。例如，如果要比较两个数字是否相等，可以将它们四舍五入到一个合理的精度，然后再进行比较：\n\n```js\nfunction areNumbersAlmostEqual(num1, num2, epsilon = 1e-10) {\n  return Math.abs(num1 - num2) < epsilon;\n}\n\nconsole.log(areNumbersAlmostEqual(0.1 + 0.2, 0.3)); // 输出 true\n```\n\n在这个示例中，我们使用一个称为\"epsilon\"的小数值来表示可接受的误差范围。我们计算两个数字之差的绝对值，如果它小于epsilon，我们认为这两个数字几乎相等。在实践中，需要根据具体问题选择合适的epsilon值。\n\n\n\n### Map与WeakMap的区别\n\nMap 和 WeakMap 在 JavaScript 中都提供了键值对的存储，但它们的工作方式和底层实现有一些重要的区别。\n\n1. 键的引用：在 Map 中，键的引用是强引用，也就是说只要 Map 存在，那么它的键值对就会保留在内存中，不会被垃圾收集器回收。而在 WeakMap 中，键的引用是弱引用，也就是说如果没有其他地方引用该键，那么该键就会被垃圾收集器回收，不论该 WeakMap 是否还存在。\n\n2. 键的类型：在 Map 中，键可以是任何类型，包括原始类型（比如字符串、数字、布尔值）和对象类型。而在 WeakMap 中，键必须是对象。\n\n3. 迭代器和清除方法：Map 具有诸如 `size`、`clear`、`keys`、`values` 和 `entries` 等方法，允许开发者获取大小，清除所有键值对，或者迭代所有的键或值。然而，由于 WeakMap 的键是弱引用，为了防止在垃圾回收过程中可能引发的并发问题，WeakMap 没有这些方法。\n\n4. 底层实现：JavaScript 本身是高级语言，其具体实现取决于底层的 JavaScript 引擎，如 V8 或 SpiderMonkey。在一般情况下，Map 可以使用简单的哈希表来实现。对于 WeakMap，由于其键是弱引用，因此在内存管理方面需要更加复杂的处理。这些处理通常在引擎级别完成，而不是在 JavaScript 代码级别。\n\n以上这些区别使得 Map 和 WeakMap 有各自适用的情况。比如，当你需要存储的键值对在某个时间点之后不再需要时，使用 WeakMap 可以防止内存泄漏。而当你需要完全控制何时删除键值对时，使用 Map 更为合适。\n\n\n\n### 谈谈你对词法作用域的理解\n\n词法作用域（有时也称为静态作用域）是在编程中用于确定变量可见性和生命周期的一种作用域规则。以下是对词法作用域的深入理解：\n\n1. **定义时确定**：词法作用域是在代码的编写阶段定义的，而不是在运行时。换句话说，作用域是由代码的物理结构决定的，而不是它是如何被调用的。\n\n2. **嵌套结构**：在词法作用域中，我们可以在一个函数内部定义另一个函数，从而形成一个嵌套的作用域链。内部函数可以访问其外部函数的变量和参数，但外部函数不能访问其内部函数的变量。\n\n3. **全局与局部**：\n   - **全局作用域**：定义在所有函数外部的变量拥有全局作用域。全局变量可以在代码的任何地方访问。\n   - **局部作用域**：在函数内部定义的变量拥有局部作用域。它们只能在函数内部被访问。\n\n4. **作用域链**：当在一个作用域内查找一个变量时，如果当前作用域没有定义该变量，查找会继续到包含（外部）作用域，直到找到该变量或达到全局作用域。这种查找链被称为作用域链。\n\n5. **与动态作用域的区别**：词法作用域与动态作用域是两种不同的作用域规则。在动态作用域中，作用域是由函数如何被调用决定的，而不是代码的结构。JavaScript 使用的是词法作用域，而不是动态作用域。\n\n6. **闭包**：闭包是词法作用域和函数的强大组合。当函数能够记住并访问其词法作用域，即使当该函数在其原始词法作用域之外执行时，我们就称之为闭包。\n\n7. **阻止变量提升**：在 JavaScript 中，`let` 和 `const` 关键字（ES6及之后的版本引入）为变量定义提供了块级作用域，这与传统的 `var` 关键字有所不同。\n\n8. **性能考虑**：由于词法作用域是在编译时确定的，编译器可以对代码进行优化。知道哪些变量在哪里被访问，以及它们如何被访问，可以帮助编译器提高代码的执行效率。\n\n\n\n<hr />\n\n## TypeScript\n\n### type和interface的区别\n\n1. 声明方式：\n\n   - `type` 是使用 `type` 关键字定义类型别名，可以为基本类型、联合类型、交叉类型等复杂类型提供一个名称。例如：\n\n     ```typescript\n     type Point = {\n       x: number;\n       y: number;\n     };\n     ```\n\n   - `interface` 是使用 `interface` 关键字定义接口，主要用于描述对象的结构。例如：\n\n     ```typescript\n     interface Point {\n       x: number;\n       y: number;\n     }\n     ```\n\n2. 扩展：\n\n   - `type` 可以使用交叉类型 `&` 进行扩展。例如：\n\n     ```typescript\n     type Name = {\n       name: string;\n     };\n     \n     type Age = {\n       age: number;\n     };\n     \n     type Person = Name & Age;\n     ```\n\n   - `interface` 可以使用 `extends` 关键字进行扩展。例如：\n\n     ```typescript\n     interface Name {\n       name: string;\n     }\n     \n     interface Age {\n       age: number;\n     }\n     \n     interface Person extends Name, Age {}\n     ```\n\n3. 合并声明：\n\n   - `type` 不能进行合并声明，同名的 `type` 会导致错误。\n   - `interface` 可以进行合并声明，同名的 `interface` 会自动合并，合并后的接口包含所有声明的属性。\n\n4. 类型映射：\n\n   - `type` 可以使用映射类型创建新类型，例如：\n\n     ```typescript\n     type ReadonlyPoint = Readonly<Point>;\n     ```\n\n   - `interface` 不能直接使用映射类型，但可以通过交叉类型和映射类型创建新接口：\n\n     ```typescript\n     interface ReadonlyPoint extends Readonly<Point> {}\n     ```\n\n5. 其他类型表示：\n\n   - `type` 支持联合类型、元组类型、映射类型等更多类型表示。例如：\n\n     ```typescript\n     type Coordinate = [number, number];\n     type Shape = \'circle\' | \'square\' | \'rectangle\';\n     ```\n     \n- `interface` 主要用于描述对象的结构，不支持其他类型表示。\n\n总结一下，`type` 和 `interface` 在 TypeScript 中都可以用于定义复杂类型，但它们在声明方式、扩展、合并声明和类型表示等方面有所不同。`type` 更灵活，支持更多类型表示，而 `interface` 更适用于描述对象结构，可以进行合并声明。\n\n\n\n### object类型和Object类型的区别\n\n在 TypeScript 中，`object`类型是指非原始类型，即除了 `number`、`string`、`boolean`、`symbol`、`null` 和 `undefined` 之外的类型。而 `Object` 类型是 JavaScript 中的全局对象类型，包含了一些内置方法和属性（如 `toString()` 和 `valueOf()`），可以进行类型转换。\n\n一个实例化的 JavaScript 对象的类型是 `Object`，而一个非原始类型的值的类型是 `object`。例如：\n\n```typescript\nconst obj1: object = {};    // OK\nconst obj2: Object = {};    // OK\n\nconst num1: object = 42;    // Error\nconst num2: Object = 42;    // OK, 但不推荐，因为 42 为原始类型\n```\n\n总之，`object`表示任何非原始类型的值，而 `Object`表示 JavaScript 的全局对象类型。\n\n\n\n### 谈谈你对Enum枚举类型的理解\n\n在 TypeScript 中，枚举（Enum）是一种特殊的数据类型，它允许为一组相关的值赋予有意义的名字。枚举类型可以帮助提高代码的可读性和可维护性。以下是关于 TypeScript 中枚举类型的一些关键点：\n\n1. 声明枚举：\n\n   使用 `enum` 关键字定义一个枚举类型。例如：\n\n   ```typescript\n   enum Color {\n     Red,\n     Green,\n     Blue\n   }\n   ```\n\n2. 使用枚举：\n\n   可以通过枚举类型名字访问枚举值。例如：\n\n   ```typescript\n   let myColor: Color = Color.Red;\n   ```\n\n3. 数字枚举：\n\n   默认情况下，枚举值是从 0 开始自增的数字。你也可以为某个成员显式指定一个数字，后续成员将从该数字开始自增。例如：\n\n   ```typescript\n   enum Direction {\n     Up = 1,\n     Down, // 2\n     Left, // 3\n     Right // 4\n   }\n   ```\n\n4. 字符串枚举：\n\n   除了数字枚举，TypeScript 还支持字符串枚举。在字符串枚举中，每个成员都需要显式地赋予一个字符串值。例如：\n\n   ```typescript\n   enum HttpMethod {\n     GET = \'GET\',\n     POST = \'POST\',\n     PUT = \'PUT\',\n     DELETE = \'DELETE\'\n   }\n   ```\n\n5. 反向映射：\n\n   数字枚举具有反向映射的特性，这意味着可以通过枚举值得到枚举名。例如：\n\n   ```typescript\n   enum Status {\n     OK = 200,\n     NotFound = 404\n   }\n   \n   console.log(Status[200]); // 输出 \"OK\"\n   ```\n\n   字符串枚举没有反向映射特性。\n\n6. 常量枚举：\n\n   使用 `const` 关键字声明常量枚举。常量枚举在编译时会被计算，**不会在编译后的代码中生成实际的枚举对象**，可以减少生成的代码体积。例如：\n\n   ```typescript\n   const enum Weekday {\n     Sunday,\n     Monday,\n     Tuesday,\n     Wednesday,\n     Thursday,\n     Friday,\n     Saturday\n   }\n   ```\n\n总之，TypeScript 中的枚举类型提供了一种为一组相关值赋予有意义名字的方法，增强了代码的可读性和可维护性。枚举类型包括数字枚举、字符串枚举和常量枚举，可以根据不同的需求选择使用。\n\n\n\n### 谈谈你对泛型的理解\n\n泛型是一种在定义函数、接口或类时不预先指定具体的类型，而是在使用时指定的一种特性。在TypeScript中，泛型被广泛应用以增加代码的重用性和可维护性。\n\n以下是我对TypeScript中泛型的理解：\n\n1. **类型安全**：泛型可以帮助我们在编译时检查类型信息。这种特性可以有效地减少运行时的错误，因为我们可以在代码编写阶段就捕获潜在的类型错误。\n2. **代码重用**：我们可以编写一个适用于多种类型的函数，而不是针对每一种类型都写一个函数。泛型可以提高代码的复用性，减少不必要的代码重复。\n3. **灵活性**：泛型提供了高度的灵活性，我们可以在编写函数或类时不必预先指定具体的类型，而是在使用这些函数或类时指定类型。这样就使得我们的函数或类可以适应更广泛的情况。\n4. **类型推断**：在许多情况下，TypeScript编译器可以自动推断出泛型的类型，这大大减少了我们编写和阅读代码时的工作量。\n\n\n\n### any和unknown的区别？\n\n在 TypeScript 中，`any` 和 `unknown` 都可以代表任何类型的值。但是它们在类型安全性和如何使用上有显著的差异。\n\n1. **类型检查**：\n   - `any`：当你将一个值标记为 `any` 类型时，TypeScript 将不会对这个值进行任何类型检查。这意味着，你可以在该值上进行任何操作，而不会得到编译时的错误。\n   - `unknown`：它表示一个未知的值的类型。你不能直接对 `unknown` 类型的值进行操作，也不能将它分配给除 `unknown` 和 `any` 类型之外的其他类型的变量，除非你先进行类型检查或类型断言。\n\n2. **安全性**：\n   - `any`：使用 `any` 会绕过 TypeScript 的类型系统，可能导致运行时错误。它提供了最大的灵活性，但也损失了类型安全性。\n   - `unknown`：要操作 `unknown` 类型的值，你必须先确保这个值是你期望的类型。这迫使你更加谨慎地处理这些值，增加了类型安全性。\n\n3. **使用场景**：\n   - `any`：当你确实不关心类型或从老的 JavaScript 代码迁移到 TypeScript 时，可能会使用 `any` 作为临时解决方案。\n   - `unknown`：当你想表示一个可以是任何类型的值，但仍然想保持类型安全性时，可以使用 `unknown`。\n\n**示例**：\n\n考虑以下代码片段：\n\n```typescript\nlet a: any = \"hello\";\nlet b: number = a;  // 这里不会有错误，因为 a 是 any 类型\n\nlet x: unknown = \"hello\";\nlet y: number = x;  // 错误！不能将类型 \"unknown\" 分配给类型 \"number\"\n\nif (typeof x === \"number\") {\n    let z: number = x;  // 在这里没问题，因为我们已经检查了 x 的类型\n}\n```\n\n总之，`unknown` 提供了一种在不完全确定类型时保持类型安全性的方式，而 `any` 则完全关闭了 TypeScript 的类型检查。在可能的情况下，推荐使用 `unknown` 而不是 `any`，以保持代码的类型安全性。\n\n\n\n### ts文件和d.ts文件的区别是什么\n\n在 TypeScript 开发中，`.ts` 文件和 `.d.ts` 文件有着不同的用途和特点：\n\n1. **`.ts` 文件**:\n   - 这是 TypeScript 的主要文件类型。\n   - `.ts` 文件包含 TypeScript 代码，这些代码包括类型注解、接口定义、类、函数等。\n   - 这些文件会被 TypeScript 编译器编译成 JavaScript 文件，以便在浏览器或 Node.js 环境中运行。\n   - `.ts` 文件通常用于编写应用程序或库的实际逻辑。\n2. **`.d.ts` 文件**:\n   - `.d.ts` 文件是 TypeScript 的声明文件。\n   - 这些文件只包含类型声明，而不包含实际的可执行代码。\n   - 它们的主要作用是为已存在的 JavaScript 代码提供类型信息。这使得 TypeScript 开发者可以在不改变现有代码的情况下，利用 TypeScript 的类型检查和自动补全特性。\n   - 常见的用途包括为第三方库（如 jQuery 或 Lodash）提供类型定义，这些库本身可能是用 JavaScript 编写的。\n   - 通过使用 `.d.ts` 文件，可以在 TypeScript 项目中安全地使用这些 JavaScript 库，同时享受到类型系统带来的好处。\n\n简而言之，`.ts` 文件包含 TypeScript 代码的实际实现，而 `.d.ts` 文件则为这些实现或其他 JavaScript 代码提供类型定义。这种区分使得 TypeScript 能够与现有的 JavaScript 代码和库更好地集成，同时为开发者提供类型安全和其他 TypeScript 特性的优势。\n\n\n\n<hr />\n\n## Node\n\n### require一个模块时的查找过程\n\n当使用 `require` 函数加载一个模块时，Node.js 遵循一定的查找和解析过程。以下是 `require` 函数的主要查找过程：\n\n1. 内置模块：\n\n   首先，Node.js 检查请求的模块是否为内置模块（如 `http`, `fs`, `path` 等）。如果是内置模块，直接返回内置模块的导出对象，查找过程结束。\n\n2. 文件和文件夹模块：\n\n   如果请求的模块不是内置模块，Node.js 将尝试将其解析为文件或文件夹模块。按照以下顺序查找：\n\n   - 检查是否存在带 `.js`、`.json`、`.node` 扩展名的文件。如果找到了匹配的文件，加载并执行该文件，然后返回其导出对象。\n   - 如果没有找到匹配的文件，检查是否存在同名文件夹。如果存在同名文件夹，Node.js 将查看该文件夹内的 `package.json` 文件。如果 `package.json` 文件中定义了 `main` 字段，Node.js 将尝试加载该字段指定的文件。如果没有 `main` 字段或无法加载指定的文件，Node.js 将尝试加载文件夹内的 `index.js`、`index.json` 或 `index.node` 文件。\n\n3. 节点模块：\n\n   如果请求的模块既不是内置模块，也不是文件或文件夹模块，Node.js 将尝试将其解析为节点模块。Node.js 会按照一定的顺序在 `node_modules` 文件夹中查找模块：\n\n   - 从当前文件所在的目录开始，查找 `node_modules` 文件夹。如果找到了匹配的模块，加载并执行该模块，然后返回其导出对象。\n   - 如果在当前目录的 `node_modules` 文件夹中未找到匹配的模块，Node.js 将继续向上级目录查找，直到找到匹配的模块或到达文件系统的根目录。\n\n4. 查找失败：\n\n   如果在以上步骤中未找到匹配的模块，Node.js 将抛出一个 `MODULE_NOT_FOUND` 错误。\n\n总结一下，当使用 `require` 函数加载一个模块时，Node.js 遵循一定的查找和解析过程。首先检查内置模块，然后尝试解析为文件或文件夹模块，最后尝试解析为节点模块。如果在这些步骤中未找到匹配的模块，Node.js 将抛出一个错误。\n\n\n\n### 谈谈你对Node中间件的理解\n\n中间件（Middleware）是一种重要的设计模式。它们用于处理请求和响应的过程中的各种任务，以便将逻辑分离到不同的组件中，提高代码的可读性和可维护性。以下是关于 Node.js 中间件的一些关键点：\n\n1. 功能：中间件的主要功能是在请求和响应的处理过程中执行特定任务。例如，验证用户身份、解析请求体、记录访问日志、处理跨域请求等。\n\n2. 顺序执行：中间件按照添加顺序依次执行。当一个中间件处理完毕后，它可以选择将控制权传递给下一个中间件，或者直接结束请求-响应周期。\n\n3. 基本结构：在 Express 中，中间件通常是一个函数，接收三个参数：`req`（请求对象）、`res`（响应对象）和 `next`（下一个中间件函数）。在 Koa 中，中间件是一个异步函数，接收一个参数：`ctx`（上下文对象），并返回一个 Promise。\n\n   - Express 中间件示例：\n\n     ```js\n     function logger(req, res, next) {\n       console.log(`${req.method} ${req.url}`);\n       next();\n     }\n     ```\n\n   - Koa 中间件示例：\n\n     ```js\n     async function logger(ctx, next) {\n       console.log(`${ctx.method} ${ctx.url}`);\n       await next();\n     }\n     ```\n\n4. 添加中间件：在 Express 和 Koa 中，都有一种方法来将中间件添加到请求处理管道中。\n\n   - Express 示例：\n\n     ```js\n     const express = require(\'express\');\n     const app = express();\n     app.use(logger);\n     ```\n\n   - Koa 示例：\n\n     ```js\n     const Koa = require(\'koa\');\n     const app = new Koa();\n     app.use(logger);\n     ```\n\n5. 错误处理：中间件还可以用于处理错误。在 Express 中，错误处理中间件接收四个参数：`err`（错误对象）、`req`（请求对象）、`res`（响应对象）和 `next`（下一个中间件函数）。在 Koa 中，错误处理中间件通常在其他中间件的 `try`/`catch` 块中捕获异常。\n\n   - Express 错误处理示例：\n\n     ```js\n     function errorHandler(err, req, res, next) {\n       console.error(err);\n       res.status(500).send(\'Internal Server Error\');\n     }\n     app.use(errorHandler);\n     ```\n\n   - Koa 错误处理示例：\n\n     ```js\n     async function errorHandler(ctx, next) {\n       try {\n         await next();\n       } catch (err) {\n         console.error(err);\n         ctx.status = 500;\n         ctx.body = \'Internal Server Error\';\n       }\n     }\n     app.use(errorHandler);\n     ```\n\n总之，Node.js 中间件是一种设计模式，用于在请求和响应的处理过程中执行特定任务。中间件可以帮助我们将逻辑分离到不同的组件中，提高代码的可读性和可维护性。通过使用中间件，我们可以更方便地组织和管理代码，以实现各种功能，如身份验证、日志记录、错误处理等。\n\n当创建一个中间件时，需要考虑以下几点：\n\n1. 职责分离：每个中间件应该只负责一个特定任务。这有助于保持代码的简洁和易于维护。\n2. 代码复用：通过将通用功能封装在中间件中，我们可以在不同的项目和模块中重用这些功能。\n3. 顺序重要：中间件的执行顺序很重要，因为它们之间可能存在依赖关系。例如，一个解析请求体的中间件应该在处理具体业务逻辑的中间件之前执行。\n4. 可配置性：中间件应该具有一定的可配置性，以便根据项目的不同需求进行调整。\n5. 异常处理：确保在中间件中处理可能发生的异常，以便能够优雅地处理错误并向用户返回有用的错误信息。\n\n通过使用中间件，我们可以创建出更加模块化、可扩展和可维护的 Node.js 应用程序。无论是使用 Express、Koa 还是其他框架，中间件都是 Node.js 开发中一个非常重要的概念。\n\n\n\n### npm run dev时发生了什么？\n\n`npm run dev` 是一个在 Node.js 项目中常见的命令，通常用于启动开发环境。这个命令实际上会触发一系列的操作。下面是一个简化的概述：\n\n1. 首先，当你执行 `npm run dev` 命令时，npm 会在项目的 `package.json` 文件中查找名为 `dev` 的脚本。这个脚本通常是一个包含了如何启动开发服务器或构建工具的命令。\n2. 接下来，npm 会执行 `dev` 脚本中的命令。这个命令通常会启动一个开发服务器，如 Webpack Dev Server、Express、Next.js 等，这些服务器会监听文件更改，自动重新编译和刷新浏览器。\n3. 在开发服务器启动的过程中，可能会执行一些构建任务，如编译 JavaScript、CSS、HTML 等资源，执行代码检查，以及优化代码等。\n4. 有些项目可能还会启动其他辅助工具，如热模块替换（HMR, Hot Module Replacement）来实现无需刷新页面即可更新局部变化，或者启动一个代理服务器来处理跨域请求等。\n5. 最后，当开发服务器启动完成后，你可以在浏览器中访问项目，并在修改代码后看到实时更新。\n\n综上，`npm run dev` 通常是一个用于启动开发环境的命令，它会执行一系列操作来方便开发人员进行实时的代码调试和更新。具体的操作可能因项目和开发工具的不同而有所差异。\n\n\n\n### Node中进程之间是如何通信的\n\n在 Node.js 中，进程之间可以使用多种方式进行通信。主要的通信方式是使用进程间通信（Inter-process communication, IPC）通道。以下是 Node.js 中实现进程间通信的几种方法：\n\n1. `child_process.fork()`\n\n   使用 `child_process.fork()` 方法创建的子进程会自动建立一个 IPC 通道，允许父子进程之间通过 `send()` 方法发送消息，同时监听 `message` 事件接收消息。例如：\n\n   父进程（parent.js）：\n\n   ```js\n   const { fork } = require(\'child_process\');\n   const child = fork(\'./child.js\');\n   \n   child.send(\'Hello from parent!\');\n   \n   child.on(\'message\', (msg) => {\n     console.log(`Received message from child: ${msg}`);\n   });\n   ```\n\n   子进程（child.js）：\n\n   ```js\n   process.on(\'message\', (msg) => {\n     console.log(`Received message from parent: ${msg}`);\n     process.send(\'Hello from child!\');\n   });\n   ```\n\n2. `child_process.spawn()`\n\n   使用 `child_process.spawn()` 创建子进程时，可以通过配置 `stdio` 选项来建立一个 IPC 通道。例如：\n\n   父进程（parent.js）：\n\n   ```js\n   const { spawn } = require(\'child_process\');\n   const child = spawn(process.execPath, [\'./child.js\'], {\n     stdio: [\'inherit\', \'inherit\', \'inherit\', \'ipc\']\n   });\n   \n   child.send(\'Hello from parent!\');\n   \n   child.on(\'message\', (msg) => {\n     console.log(`Received message from child: ${msg}`);\n   });\n   ```\n\n   子进程（child.js）：\n\n   ```js\n   process.on(\'message\', (msg) => {\n     console.log(`Received message from parent: ${msg}`);\n     process.send(\'Hello from child!\');\n   });\n   ```\n\n3. 使用第三方库\n\n   除了上述 Node.js 内置的方法外，还可以使用一些第三方库来实现进程间通信，如：`node-ipc`、`zeromq` 等。这些库通常提供了更高级的抽象和更强大的功能。\n\n总之，Node.js 中进程间通信主要通过 IPC 通道实现。可以使用 `child_process.fork()` 或 `child_process.spawn()` 方法创建具有 IPC 通道的子进程，也可以考虑使用第三方库来实现更高级的通信需求。\n\n\n\n### 谈谈你对Stream的理解\n\n在 Node.js 中，流（Stream）是一种处理数据的抽象接口，允许开发者按照一定的顺序处理数据。流可以用于读取、写入或转换数据。流的核心思想是将大量数据拆分成小的数据块，一次处理一个数据块，从而避免一次性加载整个数据集导致的内存不足问题。流在 Node.js 中被广泛应用，如文件操作、网络传输等场景。\n\n流有以下四种类型：\n\n1. **Readable Stream**：可读流是从某个来源读取数据的流。例如，从文件中读取数据、从 HTTP 响应中读取数据等。可读流会触发 `data` 事件来传输数据块，当数据读取完成时，会触发 `end` 事件。\n2. **Writable Stream**：可写流是将数据写入到某个目标的流。例如，向文件中写入数据、向 HTTP 请求中写入数据等。可写流提供了 `write()` 方法用于写入数据，`end()` 方法用于表示数据写入完成。\n3. **Duplex Stream**：双工流是可读可写的流，可以同时读取和写入数据。例如，TCP 套接字就是一个双工流，允许在同一时间进行数据的读取和写入。\n4. **Transform Stream**：转换流是一种特殊的双工流，它可以在读写过程中修改或转换数据。例如，压缩或解压数据、加密或解密数据等。\n\n在 Node.js 中，流是基于事件的，可读流和可写流都继承自 `EventEmitter` 类。这使得流可以通过事件机制来处理各种情况，如数据到达、数据写入完成、错误发生等。\n\n流有许多优点，例如：\n\n- **内存占用低**：流允许按需处理数据，避免一次性加载整个数据集导致的内存不足问题。\n- **速度快**：流可以在数据可用时立即开始处理，而无需等待整个数据集加载完成。\n- **可组合**：流可以通过管道（pipe）组合在一起，实现数据的读取、转换和写入等一系列操作。\n\n总之，Node.js 中的流是一种处理大量数据的高效方式，具有低内存占用、快速处理和可组合等特点。在文件操作、网络传输等场景中，流被广泛应用。\n\n\n\n### 谈谈你对Node事件循环的理解\n\nNode.js 事件循环（Event Loop）是其核心运行机制之一，它允许 Node.js 在处理大量并发操作时保持高性能。事件循环是一个程序结构，用于等待、接收并处理事件，例如 I/O 操作、计时器和其他异步操作。它的工作原理是在事件队列中持续循环，直到程序终止。下面详细介绍 Node.js 事件循环的关键概念：\n\n1. 单线程：Node.js 采用单线程模型，这意味着在给定时刻只能执行一个任务。但是，由于它采用非阻塞 I/O，因此可以处理大量并发操作。\n2. 非阻塞 I/O：Node.js 的 I/O 操作是非阻塞的，这意味着执行 I/O 时不会等待操作完成，而是继续执行其他任务。当 I/O 操作完成时，回调函数将被添加到事件队列以供事件循环处理。\n3. 事件队列：事件队列是一个先进先出（FIFO）的队列，用于存储待处理的事件。事件循环会不断从队列中取出并处理事件。\n4. 事件循环阶段：Node.js 事件循环分为几个阶段，每个阶段负责处理不同类型的任务：\n   - 定时器阶段：处理 setTimeout 和 setInterval 计时器的回调。\n   - I/O 回调阶段：处理大部分 I/O 回调。\n   - 闲置、准备阶段：内部使用，为其他阶段做准备。\n   - 轮询阶段：检查新的 I/O 事件并处理。\n   - 检查阶段：处理 setImmediate 的回调。\n   - 关闭事件回调阶段：处理关闭请求，如服务器关闭、socket 断开等。\n5. 微任务（Microtasks）：在事件循环的每个阶段之间，Node.js 会处理微任务队列。微任务包括 Promise 的 resolve 和 reject 回调。这意味着微任务会在事件循环的下一个阶段之前执行。\n\n通过协调这些概念，Node.js 事件循环使得程序能够以高效、可扩展的方式处理大量并发操作。在编写 Node.js 程序时，了解事件循环如何工作以及如何在程序中使用异步模式是非常重要的。\n\n\n\n### process.nextTick(callback)、setImmediate(callback)和setTimeout(callback, 0)的区别？\n\n`process.nextTick(callback)`、`setImmediate(callback)` 和 `setTimeout(callback, 0)` 都是在 Node.js 中用于异步执行代码的函数，但它们的行为和执行顺序有所不同。\n\n1. **`process.nextTick(callback)`**：此函数将 `callback` 添加到当前事件循环的\"next tick queue\"中。这意味着 `callback` 函数会在当前操作完成后、事件循环的下一轮循环之前立即执行。`process.nextTick` 具有最高优先级，因此在所有异步任务中最先执行。\n2. **`setImmediate(callback)`**：此函数将 `callback` 添加到事件循环的\"check\"阶段（即在 I/O 回调之后、关闭回调之前）。`setImmediate` 的执行顺序要低于 `process.nextTick`，但高于 `setTimeout(callback, 0)`。`setImmediate` 主要用于分离计算密集型任务，以允许其他任务在事件循环中执行。\n3. **`setTimeout(callback, 0)`**：此函数将 `callback` 添加到定时器队列，使其在定时器阶段执行。尽管延迟时间设置为 0，但实际的延迟可能会更长，因为事件循环需要处理其他任务。`setTimeout(callback, 0)` 的执行顺序最低，通常在所有其他异步任务之后执行。\n\n总结一下，这些函数的执行顺序是：\n\n- `process.nextTick(callback)`：优先级最高，在当前事件循环的下一刻执行。\n- `setImmediate(callback)`：在事件循环的 I/O 回调之后执行。\n- `setTimeout(callback, 0)`：在定时器队列中执行，具有最低的优先级。\n\n在实践中，你应该根据需要选择适当的函数。例如，如果你希望在事件循环的下一轮循环之前立即执行一个任务，可以使用 `process.nextTick`；如果你希望在其他任务完成后执行一个任务，可以使用 `setImmediate` 或 `setTimeout`。\n\n\n\n### child_process模块中，spawn()、fork()、exec()的区别？\n\n`child_process` 是 Node.js 的一个内置模块，它允许你在子进程中执行系统命令和运行其他 Node.js 进程。模块中的 `spawn()`、`fork()` 和 `exec()` 函数都可以用于创建子进程，但它们之间存在一些差异：\n\n1. **`spawn(command[, args][, options])`**：`spawn` 是一个底层函数，用于异步地创建一个新的子进程。它接受一个命令（例如 `\'ls\'` 或 `\'node\'`）和一个可选的参数数组。`spawn` 返回一个 `ChildProcess` 对象，你可以通过该对象的 `stdout` 和 `stderr` 流来获取子进程的输出。`spawn` 适用于需要处理大量数据的长时间运行的进程，因为它不会缓冲输出，而是将数据以流的形式返回。\n2. **`fork(modulePath[, args][, options])`**：`fork` 是一个特殊的 `spawn`，专门用于创建 Node.js 子进程。它接受一个 Node.js 模块的路径（而不是系统命令）和一个可选的参数数组。与 `spawn` 类似，`fork` 返回一个 `ChildProcess` 对象。`fork` 还为父子进程之间的通信提供了内置支持，可以使用 `send()` 方法发送消息，接收消息的事件为 `message`。由于 `fork` 专门用于 Node.js 进程，所以它更适合 Node.js 应用程序中的进程管理。\n3. **`exec(command[, options][, callback])`**：`exec` 用于异步地执行系统命令，并将输出缓冲到一个回调函数中。它接受一个完整的命令字符串（包括参数），当进程完成时，回调函数将被调用，并接收可能的错误、标准输出和标准错误作为参数。`exec` 适用于预期输出较小的短时命令，因为它会将输出缓冲到内存中，可能导致内存不足的问题。\n\n总结一下：\n\n- `spawn()`：用于异步地创建子进程，适用于大量数据的长时间运行的进程。\n- `fork()`：用于创建 Node.js 子进程，提供了父子进程间的内置通信支持。\n- `exec()`：用于执行短时命令，将输出缓冲到内存中。适用于预期输出较小的情况。\n\n在选择适当的函数时，你应该根据需要执行的命令类型、预期的输出量和是否需要进程间通信来进行判断。\n\n\n\n<hr />\n\n## 浏览器\n\n### DOMContentLoaded 与 load 的区别 ?\n\n`DOMContentLoaded` 和 `load` 都是浏览器中的事件，它们表示页面加载过程中的不同阶段。这两个事件的主要区别在于它们触发的时间和关注的内容。\n\n1. **DOMContentLoaded**：当 HTML 文档被完全加载和解析完成后，`DOMContentLoaded` 事件就会触发，而此时无需等待样式表、图像和子框架的完成加载。换句话说，`DOMContentLoaded` 主要关注 HTML 文档结构的加载，以便 JavaScript 代码可以在 DOM 树准备就绪后立即运行。这使得你可以尽早地开始操作 DOM，而无需等待其他资源加载完成。\n2. **load**：当页面上的所有资源（包括样式表、图像、子框架等）都完成加载后，`load` 事件会触发。这意味着在 `load` 事件触发时，你可以确保页面上的所有资源都可用，这对于需要操作图像尺寸或其他依赖外部资源的功能来说非常有用。\n\n总之，`DOMContentLoaded` 和 `load` 事件的区别在于它们关注的内容和触发时间：\n\n- `DOMContentLoaded`：在 HTML 文档结构加载和解析完成后触发，不等待外部资源（如样式表和图像）加载完成。\n- `load`：在页面上的所有资源（包括样式表、图像等）加载完成后触发。\n\n通常，如果你的 JavaScript 代码仅依赖于 DOM 结构，那么使用 `DOMContentLoaded` 事件会更快、更有效。如果你的代码依赖于外部资源，那么使用 `load` 事件可能更合适。\n\n\n\n### 谈谈你对dom事件机制的理解\n\nDOM（文档对象模型，Document Object Model）事件机制是Web浏览器中实现交互的重要组成部分。在JavaScript中，DOM事件机制使得开发者可以在特定情况下响应用户的操作，如点击、滚动、键盘输入等。以下是对DOM事件机制的一些理解：\n\n1. 事件流：DOM事件机制分为三个阶段，分别是捕获阶段（capturing phase）、目标阶段（target phase）和冒泡阶段（bubbling phase）。事件首先会经过捕获阶段，沿着DOM树从上至下传递，直到到达事件的目标元素。然后进入目标阶段，触发目标元素上的事件处理程序。最后是冒泡阶段，事件沿着DOM树从下往上回传。\n2. 事件处理程序：开发者可以为DOM元素添加事件处理程序，用以响应特定的事件。事件处理程序可以使用两种方式进行绑定：一种是通过HTML属性直接在元素上绑定，如`onclick`；另一种是通过JavaScript为元素添加事件处理程序，如`addEventListener()`方法。\n3. 事件对象：当事件触发时，浏览器会自动创建一个事件对象，该对象包含了有关事件的详细信息，例如事件类型、目标元素、触发时间等。事件对象通常作为事件处理程序的第一个参数传递。\n4. 事件委托：事件委托是一种事件处理机制，通过将事件处理程序绑定到父元素，可以实现对子元素的事件监听。这样可以减少事件处理程序的数量，提高性能。事件委托利用了事件冒泡机制，使得在父元素上可以捕捉到子元素触发的事件。\n5. 阻止默认行为和阻止事件传播：在某些情况下，我们希望阻止事件的默认行为或阻止事件的传播。可以通过调用事件对象的`preventDefault()`方法来阻止默认行为，调用`stopPropagation()`方法来阻止事件的传播。\n\n了解DOM事件机制对于前端开发者非常重要，因为它涉及到网页交互、用户体验等关键方面。掌握DOM事件机制有助于编写更高效、可维护的代码。\n\n\n\n### 什么是默认行为，哪些事件有默认行为\n\n默认行为是指浏览器在某些事件触发时自动执行的内置行为。在处理这些事件时，如果不希望触发默认行为，可以使用`preventDefault()`方法来阻止它。以下是一些具有默认行为的常见事件：\n\n1. `click`：当点击某些元素（如链接）时，浏览器会执行默认行为，如导航到指定的URL。\n2. `submit`：当表单元素触发提交事件时，浏览器的默认行为是向服务器发送表单数据。\n3. `keydown`：在输入框内按下某些特定键（如Enter键）时，可能会触发浏览器的默认行为，如提交表单。\n4. `contextmenu`：当用户右击网页时，浏览器会显示上下文菜单。这是`contextmenu`事件的默认行为。\n5. `dragstart`和`drop`：当对某些元素进行拖放操作时，浏览器会执行默认的拖放行为。\n6. `mousedown`：在文本区域内按下鼠标，浏览器默认会选中文本。\n7. `wheel`：当用户滚动鼠标滚轮时，浏览器的默认行为是滚动页面。\n8. `touchstart`、`touchmove`、`touchend`：在触摸设备上，这些触摸事件的默认行为可能包括滚动、缩放等。\n\n这些事件的默认行为取决于浏览器及其版本。在某些情况下，为了实现自定义行为或提高用户体验，开发者可能需要阻止这些默认行为。在事件处理程序中调用`event.preventDefault()`方法可以实现这一目的。但请注意，不是所有事件的默认行为都可以被阻止，部分事件可能由于浏览器安全策略等原因无法阻止默认行为。\n\n\n\n### CSS加载会造成阻塞吗？\n\nCSS 加载对于渲染流程来说是有阻塞性的。当浏览器遇到一个外部 CSS 文件时，它会发送一个请求去获取这个文件。在获取并解析完 CSS 文件之前，浏览器会阻塞渲染流程。这是因为 CSS 文件中可能包含对页面元素的样式信息，浏览器需要确保在渲染页面时使用正确的样式。\n\n尽管 CSS 加载阻塞渲染，但它并不阻塞其他资源的下载（如 JavaScript、图片等）。这意味着浏览器可以并行下载其他资源，从而提高页面的加载性能。\n\n为了避免 CSS 阻塞渲染，可以采取以下措施：\n\n1. **将 CSS 放在 `<head>` 标签中**：将 `<link>` 标签放在 `<head>` 中，可以确保浏览器尽早发现并下载 CSS 文件，从而减少渲染阻塞的时间。\n2. **使用媒体查询**：通过为 CSS 文件添加媒体查询，可以告诉浏览器只在特定条件下使用这个文件。这样，在不满足条件的情况下，浏览器不会阻塞渲染。例如：`<link rel=\"stylesheet\" href=\"print.css\" media=\"print\">`。\n3. **代码分割和按需加载**：将 CSS 分为多个较小的文件，只在需要时加载。例如，可以将关键 CSS 内联到 HTML 文档中，以加速首屏渲染。其他非关键 CSS 可以在页面加载完成后异步加载。\n4. **优化和压缩 CSS**：优化和压缩 CSS 代码，可以减小文件大小，从而加快下载速度。可以使用 CSS 预处理器（如 Sass、Less）或压缩工具（如 CSSNano、UglifyCSS）进行优化。\n\n通过采用这些策略，可以降低 CSS 加载对页面渲染的阻塞性，从而提高用户体验。\n\n\n\n### 谈谈你对跨域资源共享CORS的理解\n\n跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种安全机制，允许一个网页的资源（例如 AJAX 请求、字体、图片等）从不同的源（域名、协议或端口）访问。由于同源策略（Same-origin policy）的限制，不同源的网页通常无法互相访问资源。CORS 通过在 HTTP 头中加入特定的字段，使得浏览器和服务器之间可以协商，从而允许跨域请求。\n\nCORS 主要通过以下几种方式实现跨域访问：\n\n1. **简单请求**：简单请求是指满足一定条件的跨域请求，包括使用以下 HTTP 方法之一：GET、HEAD、POST，并且 HTTP 头信息不超出以下字段：Accept、Accept-Language、Content-Language、Content-Type（限于 application/x-www-form-urlencoded、multipart/form-data、text/plain）。对于简单请求，浏览器会在请求中添加 `Origin` 头，指示请求来自哪个源。服务器接收到请求后，如果允许跨域访问，会在响应头中添加 `Access-Control-Allow-Origin` 字段。\n2. **预检请求**：预检请求（Preflight request）是一种 CORS 机制，用于处理不满足简单请求条件的跨域请求。预检请求使用 OPTIONS 方法发送，浏览器会在请求头中包含 `Origin`、`Access-Control-Request-Method` 和 `Access-Control-Request-Headers` 字段。服务器收到预检请求后，如果允许跨域访问，会在响应头中添加 `Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers` 等字段。预检请求成功后，浏览器才会发送实际的跨域请求。\n3. **携带身份凭证**：CORS 还支持在跨域请求中携带身份凭证（如 Cookie），通过设置 `withCredentials` 属性为 `true`。在这种情况下，服务器需要在响应头中添加 `Access-Control-Allow-Credentials: true` 字段，以允许携带身份凭证的请求。同时，`Access-Control-Allow-Origin` 字段不能为通配符（`*`），必须指定具体的源。\n\n总的来说，CORS 通过在 HTTP 头中添加特定的字段，使得浏览器和服务器之间可以协商允许跨域访问。这种机制确保了 Web 应用程序的安全性，同时允许跨域资源共享。在实际开发中，服务器端需要正确配置 CORS 相关的响应头，以支持跨域请求。\n\n\n\n### 浏览器的主要组成部分是什么？\n\n浏览器主要由以下几个组成部分：\n\n1. **用户界面（User Interface）**：用户界面包括地址栏、前进/后退按钮、书签菜单等。它是用户与浏览器进行交互的部分。\n2. **浏览器引擎（Browser Engine）**：浏览器引擎是浏览器的核心部分，负责在用户界面和渲染引擎之间协调操作。它接收用户界面的命令，然后将其传递给渲染引擎或其他浏览器组件。\n3. **渲染引擎（Rendering Engine）**：渲染引擎负责显示请求的内容，如 HTML、CSS 和图像等。它将这些资源解析为屏幕上可见的图形。主流的渲染引擎有 WebKit（Chrome、Safari 等浏览器使用）和 Gecko（Firefox 使用）。\n4. **网络（Networking）**：网络组件用于处理网络请求和响应，如 HTTP 请求，以获取所需的资源（HTML、CSS、JavaScript、图像等）。它还负责处理网络协议、DNS 查询等。\n5. **JavaScript 解释器（JavaScript Interpreter）**：JavaScript 解释器负责解析和执行 JavaScript 代码。主流的 JavaScript 引擎有 V8（Chrome 和 Node.js 使用）、SpiderMonkey（Firefox 使用）和 JavaScriptCore（Safari 使用）。\n6. **UI 后端（UI Backend）**：UI 后端负责绘制用户界面的基本组件，如窗口、按钮等。它使用操作系统的用户界面方法，以实现跨平台的用户界面功能。\n7. **数据存储（Data Storage）**：浏览器需要在本地存储数据，如 Cookie、localStorage 和 IndexedDB 等。这些数据存储技术使得 Web 应用可以在浏览器中持久化数据。\n\n这些组件共同构成了现代浏览器，使得用户可以浏览网页并与之互动。各个浏览器可能在实现上有所不同，但它们的基本组成部分和功能是相似的。\n\n\n\n### 谈谈你对SPA单页应用的理解\n\nSPA（Single Page Application，单页应用）是一种 Web 应用开发模式，它在浏览器中加载一个 HTML 文件，然后通过 JavaScript 动态更新和操作 DOM 元素，以实现页面内容的改变。在这种模式下，所有的操作都在同一个页面中进行，不需要跳转到其他页面。这样可以避免多次向服务器请求不同的页面，从而提高用户体验。\n\n以下是关于 SPA 的一些特点和优缺点：\n\n优点：\n\n1. **快速响应**：SPA 在第一次加载时，获取所有必要的资源（HTML、CSS、JavaScript），之后只需通过 AJAX 请求获取数据，无需重新加载整个页面。这使得 SPA 更快速响应，为用户提供了更流畅的体验。\n2. **前后端分离**：SPA 通常与 RESTful API 结合使用，使得前端和后端可以独立开发和部署。这种分离有助于提高开发效率，降低维护成本。\n3. **易于开发和调试**：由于 SPA 主要依赖于 JavaScript 进行页面更新和数据处理，开发者可以使用各种现代 JavaScript 开发工具和框架，如 React、Angular 和 Vue 等，以简化开发和调试过程。\n\n缺点：\n\n1. **SEO 问题**：传统的搜索引擎爬虫可能无法正确解析和执行 JavaScript，导致 SPA 页面的内容无法被搜索引擎索引。虽然现代搜索引擎如 Google 在这方面有所改进，但仍需额外的优化以确保 SPA 的搜索引擎优化（SEO）效果。\n2. **初始加载时间**：由于 SPA 在第一次加载时需要获取所有必要的资源，这可能导致初始加载时间较长。为解决这个问题，可以采用代码分割、懒加载等技术来优化加载性能。\n3. **安全问题**：SPA 可能面临跨站脚本（XSS）攻击和其他安全威胁。开发者需要采取相应的安全措施，如对用户输入进行过滤和验证，确保 Web 应用的安全性。\n\n总的来说，SPA 是一种流行的 Web 应用开发模式，它具有快速响应、前后端分离等优点，但同时也需要注意解决 SEO、性能和安全等方面的问题。\n\n\n\n### 为什么JS执行时会阻塞页面加载\n\nJavaScript 执行阻塞页面加载的原因是浏览器在解析和渲染 HTML 文档时遵循自上而下的顺序。当浏览器遇到一个 `<script>` 标签时（尤其是外部 JavaScript 文件），它会立即下载并执行这个脚本。由于 JavaScript 可能会修改 DOM 结构或操作 CSSOM（如添加、删除元素或更改样式），浏览器必须确保在执行 JavaScript 之前，先解析完 JavaScript 之前的 HTML 和 CSS。这样可以**防止页面出现不一致的渲染效果**。\n\n因此，当浏览器遇到一个 JavaScript 脚本时，它会：\n\n1. 阻塞 HTML 解析。\n2. 如果有外部 JavaScript 文件，发送请求并等待下载完成。\n3. 执行 JavaScript 代码。\n4. 继续解析剩余的 HTML 文档。\n\nJavaScript 执行阻塞页面加载可能会导致性能问题和较差的用户体验。为了解决这个问题，可以采用以下策略：\n\n1. **将脚本放在文档底部**：将 `<script>` 标签放在文档的底部，紧邻 `</body>` 标签。这样可以确保在执行 JavaScript 之前，先解析完 HTML 和 CSS，从而减少阻塞时间。\n2. **使用 `defer` 属性**：给 `<script>` 标签添加 `defer` 属性，可以告诉浏览器在下载脚本的同时继续解析 HTML。脚本将在文档解析完成后顺序执行。例如：`<script src=\"example.js\" defer></script>`。\n3. **使用 `async` 属性**：给 `<script>` 标签添加 `async` 属性，可以使脚本异步下载和执行。这意味着脚本会在下载完成后立即执行，而不用等待其他脚本。请注意，这可能会导致脚本执行顺序发生变化，因此只适用于那些不依赖其他脚本的独立脚本。例如：`<script src=\"example.js\" async></script>`。\n\n通过采用这些策略，可以减少 JavaScript 对页面加载的阻塞性，提高页面性能和用户体验。\n\n\n\n### 说一说你对Cookie localStorage sessionStorage的理解\n\nCookie、localStorage 和 sessionStorage 都是在客户端存储数据的技术，但它们之间有一些关键的区别：\n\n1. **Cookie**：\n   - Cookie 最初是为了在客户端保存用户会话信息而设计的，它们可以在客户端和服务器之间进行传递。\n   - Cookie 的大小限制为 4KB 左右，因此不适合存储大量数据。\n   - Cookie 有一个有效期，可以设置为特定的时间长度。过期后，Cookie 会被自动删除。\n   - Cookie 可能面临安全风险，如跨站请求伪造（CSRF）攻击。因此，在使用 Cookie 时需要采取一定的安全措施。\n   - 因为每次 HTTP 请求都会携带 Cookie，所以频繁操作 Cookie 可能会影响性能。\n2. **localStorage**：\n   - localStorage 是 HTML5 引入的一种客户端存储技术，允许在用户的浏览器中存储较大量的数据（通常为 5-10MB，根据浏览器实现有所不同）。\n   - localStorage 中存储的数据没有有效期，会一直保留，除非用户手动清除或者使用代码进行删除。\n   - localStorage 只在客户端进行操作，不会与服务器进行通信。\n   - localStorage 的数据存储在同一个域名下，不同域名之间的 localStorage 数据是隔离的。\n3. **sessionStorage**：\n   - sessionStorage 与 localStorage 非常相似，它们都是 HTML5 引入的客户端存储技术，具有相同的存储容量限制。\n   - 与 localStorage 不同的是，sessionStorage 的数据仅在当前浏览器标签或窗口的生命周期内有效。当用户关闭标签或窗口时，sessionStorage 中的数据会被自动清除。\n   - sessionStorage 同样只在客户端进行操作，不会与服务器进行通信。\n   - sessionStorage 的数据同样存储在同一个域名下，不同域名之间的 sessionStorage 数据是隔离的。\n\n总之，Cookie、localStorage 和 sessionStorage 都是客户端存储技术，但它们之间在数据有效期、存储容量和与服务器通信等方面有所不同。根据具体需求和场景，开发者可以选择合适的技术进行数据存储。\n\n\n\n### 讲讲浏览器缓存\n\n浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。\n\n浏览器缓存主要分为以下几种类型：\n\n1. **强缓存**： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制：\n   - `Expires`：指定资源的过期时间。例如：`Expires: Wed, 21 Oct 2023 07:28:00 GMT`。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。\n   - `Cache-Control`：使用更现代且准确的方式控制缓存。例如：`Cache-Control: max-age=3600`，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 `no-cache`、`no-store`、`must-revalidate` 等。\n2. **协商缓存**： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制：\n   - `Last-Modified` 和 `If-Modified-Since`：服务器返回资源时，通过 `Last-Modified` 响应头指定资源最后修改时间。浏览器下次请求时会通过 `If-Modified-Since` 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 `304 Not Modified` 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 `Last-Modified` 时间。\n   - `ETag` 和 `If-None-Match`：`ETag` 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 `If-None-Match` 请求头发送这个标识。服务器会比较这个标识和资源的当前 `ETag`，如果相同，则返回 `304 Not Modified` 状态码；否则返回更新后的资源和新的 `ETag`。\n3. **其他缓存技术**： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。\n\n\n\n### 路由history和hash的区别？\n\n路由 history 和 hash 是前端路由（Single Page Application, SPA）中常用的两种模式。它们的主要区别在于实现方式和 URL 的展示形式。\n\n1. **Hash 模式**：\n   - Hash 模式基于浏览器 URL 中的哈希（`#`）部分进行路由切换。当哈希值改变时，浏览器不会向服务器发送请求，而是触发 `hashchange` 事件。前端路由库会监听这个事件，并根据哈希值变化来更新视图。\n   - URL 示例：`https://example.com/#/page1`\n   - Hash 模式兼容性较好，适用于旧版本浏览器。\n2. **History 模式**：\n   - History 模式基于 HTML5 的 History API（如 `pushState`、`replaceState` 和 `popstate` 事件）实现。这些 API 允许在不重新加载页面的情况下，直接操作浏览器的历史记录和 URL。\n   - URL 示例：`https://example.com/page1`\n   - History 模式需要服务器的配合，因为在用户直接访问某个路由（如 `https://example.com/page1`）时，如果服务器没有对应的配置，可能会返回 404 错误。为了解决这个问题，服务器需要设置一个通配符路由，将所有未匹配到的路由都重定向到单页应用的入口 HTML 文件。\n\n总之，Hash 模式和 History 模式是前端路由中的两种实现方式，具有不同的 URL 展示形式和浏览器兼容性。在选择路由模式时，需要根据项目需求、用户体验和服务器配置等因素进行权衡。\n\n\n\n### 谈一谈你对重排和重绘理解\n\n在浏览器渲染过程中，重排（reflow）和重绘（repaint）是两个重要概念。它们是指浏览器在处理 DOM 元素样式和位置变化时所发生的操作。\n\n**重排（Reflow）**： 重排，也称为回流，是指浏览器重新计算元素的布局、尺寸和位置等几何信息的过程。当 DOM 结构发生变化，或者元素的尺寸、位置、边距等样式发生改变时，浏览器需要重新计算这些元素的几何属性，并确定如何在页面上显示它们。重排可能会导致整个页面的重新布局，因此是一个性能敏感的过程。\n\n触发重排的操作包括：\n\n- 添加或删除 DOM 元素\n- 修改元素尺寸（如宽度、高度、边距等）\n- 修改元素位置（如浮动、定位等）\n- 改变窗口大小\n- 修改默认字体大小\n\n**重绘（Repaint）**： 重绘是指浏览器重新绘制 DOM 元素的过程，但不涉及元素的几何属性计算。当元素的外观样式（如颜色、背景、边框等）发生变化时，浏览器需要重新绘制这些元素，以反映样式的变化。相较于重排，重绘的性能开销较小。\n\n触发重绘的操作包括：\n\n- 修改元素颜色、背景等视觉样式\n- 元素的几何属性发生变化，触发重排（重排会导致重绘）\n\n为了提高页面渲染性能，我们应尽量减少重排和重绘的发生。一些优化措施包括：\n\n- 避免频繁修改 DOM 结构和样式，可以将修改操作合并后一次性执行\n- 使用 `requestAnimationFrame` 或者 `setTimeout` 函数进行样式更新的节流\n- 对于不可见或者离屏的元素，可以先将它们移除或隐藏，然后在内存中进行样式修改，最后再重新插入或显示\n- 使用 CSS3 动画替代 JavaScript 动画，以利用 GPU 加速\n- 使用虚拟 DOM 技术（如 React、Vue 等框架），避免不必要的 DOM 更新\n\n\n\n### 谈一谈跨域，同源策略，以及跨域解决方案\n\n**同源策略**： 同源策略是一种安全机制，用于限制文档或脚本从不同来源的数据进行交互。当两个资源具有相同的协议（如 http 或 https）、域名和端口时，它们被认为是同源的。同源策略限制了从一个源加载的网页脚本与来自另一个源的资源进行交互的能力，以防止恶意行为，如跨站脚本攻击（XSS）或数据窃取。\n\n**跨域**： 跨域是指当一个资源试图访问来自不同源的另一个资源时，由于同源策略的限制而无法进行的情况。例如，一个从 `http://example-a.com` 加载的网页试图通过 AJAX 请求 `http://example-b.com` 上的数据，这就是一个跨域请求。\n\n**跨域解决方案**： 有多种方法可以绕过同源策略的限制，实现跨域请求。以下是一些常见的跨域解决方案：\n\n1. **CORS（跨域资源共享）**： CORS 是一种官方推荐的跨域解决方案。它允许服务器通过设置响应头（如 `Access-Control-Allow-Origin`）来放宽对跨域请求的限制。浏览器将根据这些响应头决定是否允许跨域请求。\n2. **JSONP（JSON with Padding）**： JSONP 利用了 `<script>` 标签的 src 属性不受同源策略限制的特性。它通过动态创建一个 `<script>` 标签，并将回调函数作为参数传递给服务器。服务器将请求数据包装在回调函数中，并将其作为响应返回。客户端脚本收到响应后，会立即执行回调函数以获取数据。\n3. **使用代理服务器**： 可以通过代理服务器将跨域请求转发到目标服务器。这样，客户端与代理服务器之间的请求就是同源的，而代理服务器与目标服务器之间的请求则由代理服务器完成。常见的代理服务器实现方式有 Nginx 反向代理、Node.js 中间件代理等。\n4. **使用 iframe 和 postMessage**： 可以使用 iframe 加载跨域页面，然后通过 `window.postMessage` 方法在不同源的窗口之间传递消息。这种方法需要跨域页面的配合，以便在接收到消息时执行相应操作。\n5. **使用 WebSockets**： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接，客户端和服务器可以进行双向通信，实现跨域数据交换。\n6. **使用 CORS 代理**： 如果目标服务器没有实现 CORS，而你又不想在自己的服务器上设置反向代理，可以使用第三方 CORS 代理服务。这些服务在请求目标服务器时为你添加 CORS 响应头，从而使浏览器允许跨域请求。但请注意，这可能会带来安全风险，因此不建议在生产环境中使用。\n7. **使用 document.domain**： 当两个具有相同根域名但子域名不同的页面需要进行跨域通信时，可以将它们的 `document.domain` 设置为相同的值。这样，它们将被视为同源，可以进行通信。但此方法仅适用于具有相同根域名的情况。\n8. **使用 window.name**： 可以利用 `window.name` 在同源和跨域的窗口之间传递数据。`window.name` 属性在窗口跳转时会保留其值，因此可以将数据存储在 `window.name` 中，然后通过跳转到同源页面来读取数据。但这种方法受到一些限制，只能传递字符串数据，且安全性和可靠性相对较低。\n\n每种跨域解决方案都有其优缺点，需要根据实际场景和需求选择合适的方法。现代 Web 开发中，CORS 是最常用且推荐的解决方案。但在某些特殊场景或者兼容旧版浏览器时，可能需要考虑其他方案。在实现跨域时，始终要关注安全性和数据保护，确保不会引入安全漏洞。\n\n\n\n### 前端如何进行seo优化\n\n前端在进行搜索引擎优化（SEO）时，可以从以下几个方面进行优化：\n\n1. **合理的标题、描述和关键词**： 确保每个页面都有独特且描述准确的`<title>`标签和`<meta name=\"description\">`标签。这有助于搜索引擎理解页面内容，同时也为用户在搜索结果中显示更具吸引力的信息。\n2. **语义化的 HTML 结构**： 使用语义化的 HTML 标签，如`<header>`、`<footer>`、`<nav>`、`<section>`、`<article>`等，以帮助搜索引擎更好地理解页面结构和内容。\n3. **良好的页面结构**： 确保页面具有清晰的层次结构和导航，这有助于搜索引擎爬虫更容易地抓取和索引页面内容。\n4. **优化 URL 结构**： 使用简洁且描述性的 URL，避免过长或包含不必要的参数。这有助于搜索引擎理解页面内容，并提高用户体验。\n5. **使用 header 标签**： 使用`<h1>`至`<h6>`等 header 标签来组织页面内容，确保每个页面只有一个`<h1>`标签。这有助于搜索引擎理解页面的主题和重要性。\n6. **图片优化**： 为所有图片添加`alt`属性，以便搜索引擎了解图片内容。同时，优化图片大小和格式，以提高页面加载速度。\n7. **内部链接和锚文本**： 合理地使用内部链接和有意义的锚文本，以帮助搜索引擎更好地理解站点结构和内容之间的关联。\n8. **响应式设计**： 确保网站适应不同设备和屏幕尺寸，提供良好的用户体验。搜索引擎倾向于对移动友好的网站给予更高的排名。\n9. **网站速度优化**： 提高网站加载速度，减少页面渲染时间。这包括压缩资源、合并文件、优化图片、使用浏览器缓存等。搜索引擎会考虑网站速度作为排名的因素之一。\n10. **遵循 W3C 标准**： 确保代码符合 W3C 标准，减少 HTML、CSS 和 JavaScript 的错误。这有助于搜索引擎更容易地抓取和解析页面内容。\n11. **生成 XML Sitemap**： 为网站创建一个 XML Sitemap，并提交给搜索引擎。这有助于搜索引擎更有效地抓取和索引网站内容。\n12. **使用结构化数据**： 使用结构化数据（如 Schema.org、JSON-LD、Microdata 等）来标注页面内容，有助于搜索引擎更准确地理解页面信息，并可能在搜索结果中显示为富文本摘要，提高点击率。\n13. **使用 robots.txt 控制爬虫访问**： 合理设置 robots.txt 文件，指定搜索引擎爬虫可以访问和抓取的页面，避免爬虫抓取不相关或低质量的页面。\n14. **优化站内搜索**： 提供高效、准确的站内搜索功能，有助于提高用户体验和用户停留时间，间接影响搜索排名。\n15. **社交媒体整合**： 将网站内容与社交媒体平台整合，提高内容的曝光度和分享率，增加外部链接，有助于提高搜索排名。\n16. **网站安全**： 使用 HTTPS 加密，保护用户数据和隐私。搜索引擎会将安全性作为排名因素之一。\n\n总之，前端在进行 SEO 优化时，要关注页面结构、内容、用户体验和技术实现等多个方面。通过提高页面质量、提升用户体验和遵循搜索引擎的最佳实践，有助于提高网站在搜索结果中的排名和可见度。\n\n\n\n### requestAnimationFrame与requestIdleCallback区别\n\n`requestAnimationFrame`和`requestIdleCallback`都是浏览器提供的用于优化JavaScript任务调度的API。它们之间的主要区别在于它们的使用场景和触发时机。\n\n1. **requestAnimationFrame**：\n\n`requestAnimationFrame`主要用于优化浏览器的动画渲染。它允许你在浏览器即将进行下一次重绘之前安排一个回调函数执行。这意味着，回调函数将在最佳的时间点执行，从而提高动画的性能和流畅度。\n\n`requestAnimationFrame`的优点包括：\n\n- 与浏览器的刷新率同步，避免动画卡顿或丢帧现象。\n- 当页面不可见或最小化时，浏览器会暂停执行`requestAnimationFrame`回调，从而减少CPU和GPU的使用，节省资源。\n\n典型的`requestAnimationFrame`用法如下：\n\n```js\nfunction animate() {\n  // 执行动画操作\n  ...\n  // 在下一次重绘之前请求执行动画\n  requestAnimationFrame(animate);\n}\n\nrequestAnimationFrame(animate);\n```\n\n1. **requestIdleCallback**：\n\n`requestIdleCallback`用于优化非关键性任务的执行，例如代码分析、日志报告、数据存储等。当浏览器空闲时，`requestIdleCallback`会触发回调函数执行，从而避免阻塞关键任务，如渲染、动画和用户交互。\n\n`requestIdleCallback`的优点包括：\n\n- 利用浏览器的空闲时间执行低优先级任务，避免干扰关键任务。\n- 可以设置超时时间，确保在指定时间内完成任务。\n\n典型的`requestIdleCallback`用法如下：\n\n```js\nfunction performNonCriticalTask(deadline) {\n  while (deadline.timeRemaining() > 0) {\n    // 执行非关键任务\n    ...\n  }\n\n  // 如果还有未完成的任务，继续请求空闲回调\n  requestIdleCallback(performNonCriticalTask);\n}\n\nrequestIdleCallback(performNonCriticalTask);\n```\n\n总之，`requestAnimationFrame`和`requestIdleCallback`分别用于优化动画渲染和非关键性任务的执行。`requestAnimationFrame`在每次浏览器重绘之前执行回调，以实现高性能的动画效果；`requestIdleCallback`则在浏览器空闲时执行回调，避免影响关键任务。\n\n\n\n### SSR的实现原理？\n\n服务器端渲染（Server Side Rendering，简称 SSR）是一种 web 应用的渲染方式，其实现原理是在服务器端将页面内容渲染为 HTML 字符串，然后将这些字符串发送到客户端，客户端接收到 HTML 后直接显示，无需等待 JavaScript 的解析、执行和渲染。\n\nSSR 的核心实现原理可以概括为以下几个步骤：\n\n1. **请求处理**：客户端发起请求时，请求首先到达服务器。\n2. **服务器渲染**：服务器接收到请求后，根据路由和数据，将对应的页面内容渲染为 HTML 字符串。这一步通常涉及到模板引擎或服务器端 JavaScript 框架的使用，例如 React 的 `ReactDOMServer.renderToString()` 和 Vue 的 `vue-server-renderer`。\n3. **数据注入**：在渲染过程中，服务器还需要获取所需的数据，将其注入到 HTML 中。这可以通过内联脚本、JSON 格式或其他方式实现。数据注入的目的是在客户端 JavaScript 代码运行时能够获取到服务器端已经准备好的数据，避免重复请求。\n4. **生成完整 HTML**：将渲染好的 HTML 字符串插入到 HTML 模板中，形成一个完整的 HTML 页面。这个页面包含了已经渲染好的内容以及必要的 JavaScript、CSS 等资源引用。\n5. **发送响应**：服务器将完整的 HTML 页面作为响应发送给客户端。客户端接收到响应后，直接将 HTML 页面展示给用户。\n6. **客户端接管**：在客户端，浏览器会解析和执行 JavaScript 代码，接管页面的交互和操作。这一步通常被称为 \"hydration\" 或 \"激活\"，因为客户端 JavaScript 代码需要 \"激活\" 服务器端渲染的静态 HTML，使其具有动态功能。\n\n通过 SSR，用户可以更快地看到页面的内容，因为无需等待客户端的 JavaScript 代码下载、解析、执行和渲染。此外，由于搜索引擎爬虫能够更好地解析服务器端渲染的 HTML，因此 SSR 对 SEO 也有一定的优势。然而，SSR 也会增加服务器的负担，因为服务器需要负责渲染页面。在实际应用中，可以根据项目需求和性能要求，选择合适的渲染方式。\n\n\n\n### 讲讲你对PWA的理解\n\nPWA（Progressive Web App，渐进式 web 应用）是一种将现代 web 技术与传统移动应用功能结合的应用开发模式。PWA 旨在通过提供原生应用的类似体验，改进 web 应用的可用性、性能和用户体验。PWA 的核心技术包括 Service Workers、Web App Manifest 和离线缓存等。\n\nPWA 的主要特点如下：\n\n1. **可靠性**：通过 Service Workers 和离线缓存技术，PWA 可以在无网络或网络不稳定的环境下运行。用户在访问 PWA 时，即使断网，也能看到离线内容或自定义的离线提示页面。\n2. **快速**：PWA 通过预缓存关键资源和优化加载策略，提高了应用的加载速度和运行性能。在访问 PWA 时，用户可以更快地看到页面内容，并感受到流畅的交互体验。\n3. **可安装**：通过 Web App Manifest，PWA 可以被添加到用户的设备主屏幕，并以独立窗口运行，类似于原生应用。用户可以直接从主屏幕启动 PWA，而无需通过浏览器。\n4. **跨平台**：PWA 基于 web 技术，因此可以在不同的操作系统和设备上运行，包括桌面和移动设备。这意味着，开发者只需维护一套代码，就能为多个平台提供类似的应用体验。\n5. **更新简便**：PWA 无需通过应用商店发布和更新。当用户访问 PWA 时，应用会自动检查并应用更新。这样，用户总是能获取到最新的应用版本，而开发者也能更轻松地发布和管理更新。\n6. **安全**：PWA 需要通过 HTTPS 运行，确保数据传输的安全性。同时，由于 Service Workers 可以拦截和处理请求，PWA 还可以实现更丰富的安全策略和功能，如请求过滤、内容安全策略（CSP）等。\n7. **可搜索**：PWA 作为 web 应用，可以被搜索引擎抓取和索引。这意味着，PWA 可以获得更好的搜索引擎优化（SEO），提高应用的可见度和用户获取途径。\n\n总之，PWA 是一种充分利用现代 web 技术，为用户提供原生应用般体验的 web 应用开发模式。通过 PWA，开发者可以实现更可靠、快速、可安装和跨平台的应用，提升用户体验和满意度。\n\n\n\n### 谈谈浏览器的离线缓存与本地缓存的区别\n\n浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：\n\n1. 目的：\n\n离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。\n\n本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。\n\n2. 存储类型：\n\n离线缓存：使用HTML5的Application Cache（AppCache）和Service Worker技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括HTML、CSS、JavaScript等资源。\n\n本地缓存：使用浏览器提供的缓存策略和存储机制实现，如HTTP缓存、Cookie、Web Storage（包括localStorage和sessionStorage）和IndexedDB等。\n\n3. 生命周期：\n\n离线缓存：由开发者通过AppCache或Service Worker配置文件控制，包括缓存资源的更新和过期策略。\n\n本地缓存：由浏览器或服务器通过HTTP头部字段（如Cache-Control、Expires等）控制，或通过脚本（如localStorage和IndexedDB）设置的存储时间限制。\n\n4. 适用场景：\n\n离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。\n\n本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。\n\n总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。\n\n\n\n### 谈谈你对Shadow DOM的理解\n\nShadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。\n\nShadow DOM 的关键特点如下：\n\n1. **封装**：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。\n2. **隔离**：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。\n3. **附件阴影树**：通过 `attachShadow` 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 \"Shadow Host\"，而创建的 Shadow DOM 被称为 \"Shadow Tree\"。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。\n4. **插槽（Slot）**：Shadow DOM 支持使用 `<slot>` 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。\n5. **样式隔离**：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。\n\n总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。\n\n\n\n### 谈谈你对微前端的理解？\n\n微前端（Micro Frontends）是一种架构模式，它的主要目标是将单一的，通常较大的前端应用程序（如单页面应用）拆分为多个较小的、独立的部分。这些独立的部分通常被称为\"微应用\"（micro apps）。\n\n微前端的主要理念来源于微服务架构，后者在后端开发中已经变得非常流行。与微服务一样，微前端也强调团队的独立性和技术栈的多样性。每个微应用可以由不同的团队使用不同的技术栈来开发，然后再集成到一个统一的用户界面中。\n\n以下是我对微前端的一些理解：\n\n1. **解耦**：微前端的一个关键优点是解耦。每个微应用都是独立的，有自己的代码库、构建流程、开发团队和生命周期。这可以使每个团队更专注于自己的部分，降低开发复杂性，提高开发速度。\n\n2. **技术栈无关**：每个微应用可以选择适合自己需求的技术栈，不必受限于整个应用的技术选择。这使得前端开发可以跟上技术的发展，逐步引入新的技术和工具，而无需进行大规模的重构。\n\n3. **并行开发**：由于每个微应用都是独立的，所以可以并行开发，提高开发效率。也可以更灵活地调整开发资源和计划，因为每个团队的工作不会直接影响到其他团队。\n\n4. **独立部署**：每个微应用可以独立部署，不需要重新部署整个应用。这可以大大减少部署带来的风险，并且可以更快地将新功能和修复推送到用户那里。\n\n但是，微前端也不是没有挑战的。例如，微应用间的通信和协调、整体用户体验的一致性、性能问题（比如加载时间和资源占用）等，都需要在实施微前端架构时仔细考虑。\n\n总的来说，我认为微前端是一个有前景的架构模式，它在前端开发中引入了微服务的思想，有助于解决大型、复杂的前端应用开发和维护的问题。但是，它也需要对前端架构和工程化有深入的理解，才能有效地实施和管理。\n\n\n\n### 讲讲浏览器的进程和线程\n\n浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。\n\n**进程**：\n\n进程是一个运行中的程序实例，它包含程序所需的所有资源。一个进程拥有独立的内存空间、全局变量、打开的文件和设备等。浏览器中的进程主要有以下几类：\n\n1. **浏览器主进程**：负责协调浏览器的各个模块，包括用户界面、地址栏、书签栏等。它还负责管理浏览器的各个标签页进程和插件进程。\n2. **渲染进程**：负责将网页内容渲染到屏幕上。每个标签页通常对应一个渲染进程（在某些情况下，标签页可能会共享一个渲染进程）。渲染进程包括 HTML、CSS 和 JavaScript 的解析、布局、渲染以及执行等任务。\n3. **插件进程**：负责运行和管理浏览器插件（如 Flash）。\n4. **网络进程**：负责处理网络请求，包括资源的下载、上传和缓存。\n\n**线程**：\n\n线程是进程中的一个执行单元，它共享进程的资源，如内存空间和文件句柄。一个进程可以有多个线程，这些线程可以并发执行任务。在浏览器中，有以下几种主要的线程：\n\n1. **主线程**：渲染进程的主要执行线程，负责解析和执行 JavaScript 代码、处理 DOM 事件、执行 CSS 动画等任务。主线程是单线程的，这意味着 JavaScript 的执行和页面渲染任务需要排队执行。\n2. **Web Workers**：一种可以在后台运行 JavaScript 代码的线程，它与主线程独立，不会阻塞主线程。Web Workers 可以用于执行耗时的计算任务，避免影响页面渲染。\n3. **Service Workers**：用于实现离线缓存、消息推送、后台同步等功能的独立线程。Service Workers 与 Web Workers 类似，但具有更多的 API 和能力。\n4. **渲染线程**：负责将解析好的 HTML、CSS 和图像资源绘制到屏幕上。渲染线程与主线程是分离的，这意味着页面的渲染和 JavaScript 的执行是并行进行的。\n5. **合成线程**：负责处理页面的合成和分层。当浏览器检测到可以使用 GPU 加速的动画时，合成线程会将这些动画分离出来并在 GPU 上独立运行。这可以避免主线程的阻塞，提高页面的性能。\n6. **网络线程**：负责处理 HTTP 请求和响应，以及与服务器之间的通信。网络线程与主线程独立，以避免网络请求导致的阻塞。\n7. **定时器线程**：负责处理 JavaScript 中的定时器任务（如 `setTimeout` 和 `setInterval`）。这些任务会在定时器线程上排队执行，然后在指定的时间后将回调函数推送到主线程的任务队列中。\n8. **解析线程**：负责解析 HTML 和 CSS。解析线程会将解析后的 DOM 树和 CSSOM 树合并为渲染树，并传递给渲染线程进行绘制。在某些情况下，解析线程和主线程可能会合并为一个线程，这取决于浏览器的具体实现。\n9. **文件线程**：负责处理与文件系统的交互，如读取和写入操作。这些操作在文件线程上执行，避免阻塞主线程。\n\n以上就是浏览器中的一些主要进程和线程。需要注意的是，不同浏览器的实现可能会有所不同，但它们的基本原理和任务分工是类似的。理解这些进程和线程之间的关系有助于我们更好地理解浏览器的运行原理，从而优化前端性能。\n\n\n\n### html解析过程\n\nHTML（超文本标记语言）是用于构建和呈现网页内容的标准标记语言。浏览器解析HTML的过程包括以下几个步骤：\n\n1. 获取HTML文档：浏览器首先向服务器发送请求，获取HTML文档。服务器响应请求并返回HTML文件，通常是一个以`.html`或`.htm`为扩展名的文件。\n2. 词法分析：浏览器开始对HTML文档进行词法分析，将其分解成各种符号（tokens），例如标签、属性和文本内容。词法分析的结果是一系列token，这些token有助于构建DOM树。\n3. 构建DOM树：浏览器将词法分析得到的tokens用于构建DOM（文档对象模型）树。DOM树是一种表示HTML文档结构的树形数据结构，其中每个节点代表页面上的一个元素、属性或文本内容。\n4. 解析CSS：浏览器会解析与HTML文档关联的CSS样式表，包括内联样式、内部样式和外部样式。解析CSS样式后，浏览器会生成CSSOM（CSS对象模型）树，这是一种表示CSS样式的树形结构。\n5. 构建渲染树：浏览器将DOM树和CSSOM树合并，生成渲染树。渲染树包含了页面上可见的所有元素及其样式信息。隐藏元素（如`display: none;`）不会包含在渲染树中。\n6. 布局（Layout）：根据渲染树，浏览器计算每个元素在页面上的准确位置和大小。这个过程也被称为重排（reflow）。\n7. 绘制（Painting）：布局完成后，浏览器开始将元素绘制到屏幕上。这个过程包括绘制文本、颜色、图片、边框等视觉效果。\n8. 合成（Compositing）：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。\n\n在整个解析过程中，浏览器可能还需要处理JavaScript代码。JavaScript可以通过修改DOM树、CSSOM树和触发事件等方式影响页面的呈现。\n\n\n\n### 说一说从输入URL到页面呈现发生了什么\n\n从输入 URL 到页面呈现，经历了以下几个主要步骤：\n\n1. **地址解析**：浏览器首先解析输入的 URL，提取协议、域名、端口和路径等信息。\n\n2. **DNS 查询**：浏览器通过 DNS 查询将域名解析为 IP 地址。如果浏览器或操作系统缓存中已有相应的 DNS 记录，将直接使用缓存的结果；否则，浏览器将发送请求到 DNS 服务器进行查询。\n\n3. **建立 TCP 连接**：浏览器与目标服务器建立 TCP 连接，进行三次握手。这一步确保了数据传输的可靠性。\n\n4. **发送 HTTP 请求**：浏览器构建 HTTP 请求报文，包含请求头（如 User-Agent、Accept 等）和请求体（如 POST 提交的表单数据），然后通过建立的 TCP 连接将请求报文发送给服务器。\n\n5. **服务器响应**：服务器收到请求后，处理请求并生成响应报文，包含响应头（如 Content-Type、Content-Length 等）和响应体（如请求的 HTML 文件）。服务器通过 TCP 连接将响应报文发送回浏览器。\n\n6. **浏览器接收响应**：浏览器接收并解析响应报文，提取状态码、响应头和响应体等信息。\n\n7. **解析 HTML**：浏览器开始解析 HTML 文档，构建 DOM 树。遇到外部资源（如 CSS、JavaScript、图片等），浏览器会发起额外的请求获取这些资源。\n\n8. **解析 CSS**：浏览器解析 CSS 文件，构建 CSSOM 树。CSSOM 树和 DOM 树会被合并为渲染树。\n\n9. **执行 JavaScript**：浏览器解析并执行 JavaScript 代码。注意，JavaScript 的执行可能会修改 DOM 树和 CSSOM 树，从而影响渲染树的构建。\n\n10. **构建渲染树**：浏览器将 DOM 树和 CSSOM 树合并为渲染树，包含每个可见元素的布局信息。\n\n11. **布局**：浏览器根据渲染树计算每个元素的准确位置和大小，确定页面的布局。\n\n12. **绘制**：浏览器遍历渲染树，将每个元素绘制到屏幕上。\n\n13. **合成**：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。\n\n14. **页面呈现**：浏览器将渲染好的页面呈现给用户。\n\n\n总之，从输入 URL 到页面呈现，浏览器经历了一系列复杂的过程。理解这些过程有助于我们优化前端性能，提高用户体验。\n\n\n\n### 当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？\n\n当前主要的前端渲染方式有三种：服务器端渲染（SSR）、客户端渲染（CSR）和预渲染（Prerendering）。下面分别阐述这三种渲染方式的特点及优缺点：\n\n1. **服务器端渲染（SSR）**：\n\n   服务器端渲染指的是在服务器上将网页的 HTML、CSS 和 JavaScript 渲染成完整的 HTML 页面，然后将渲染后的页面发送给客户端。客户端接收到页面后直接展示，无需执行额外的 JavaScript。\n\n   - 优点：\n     1. 有利于 SEO，因为搜索引擎可以直接爬取完整的 HTML 页面。\n     2. 首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。\n   - 缺点：\n     1. 服务器端压力较大，因为每次请求都需要服务器进行页面渲染。\n     2. 用户交互复杂度受限，因为每次交互都可能需要重新渲染页面。\n\n2. **客户端渲染（CSR）**：\n\n   客户端渲染指的是将 HTML、CSS 和 JavaScript 发送给客户端，然后在客户端执行 JavaScript 来生成页面内容。这种方式在现代前端框架（如 React、Vue 和 Angular）中非常常见。\n\n   - 优点：\n     1. 服务器压力较小，因为页面渲染工作由客户端完成。\n     2. 用户交互体验较好，因为客户端可以实现动态的、无需刷新页面的交互。\n   - 缺点：\n     1. 首屏加载速度较慢，因为客户端需要等待 JavaScript 执行完毕才能看到页面内容。\n     2. 不利于 SEO，因为搜索引擎在爬取页面时可能无法执行 JavaScript。\n\n3. **预渲染（Prerendering）**：\n\n   预渲染是在构建过程中生成静态 HTML 文件，然后将这些静态文件部署到服务器。当用户请求页面时，服务器直接返回对应的静态 HTML 文件。这种方法适用于内容不经常变动的网站。\n\n   - 优点：\n     1. 首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。\n     2. 有利于 SEO，因为搜索引擎可以直接爬取静态 HTML 页面。\n     3. 服务器压力较小，因为页面在构建过程中已经渲染完成。\n   - 缺点：\n     1. 构建过程可能较慢，尤其是对于大型网站。\n     2. 如果网站内容经常变动，需要频繁地重新构建和部署页面。\n\n总结：\n\n每种渲染方式都有其优缺点，具体选择哪种方式要根据实际项目需求进行权衡。以下是一些建议：\n\n- 如果 SEO 对项目至关重要，而且项目内容相对稳定，则可以考虑使用预渲染或服务器端渲染。\n- 如果项目需要提供丰富的用户交互体验，可以考虑使用客户端渲染，这样能够充分利用现代前端框架的优势。\n- 如果项目的内容动态性较强，可以考虑使用服务器端渲染或客户端渲染。但对于客户端渲染，可能需要考虑使用服务端渲染的同构应用或者采用一些服务器端渲染辅助的技术（如 prerender.io）来提高 SEO 效果。\n- 对于首屏加载速度有较高要求的项目，可以考虑使用服务器端渲染或预渲染。\n\n实际项目中，可以根据需求灵活地将不同渲染方式结合使用，以达到最佳的性能和用户体验。例如，可以在服务器端渲染首屏内容以提高首屏加载速度，然后在客户端渲染后续的页面内容以提供更好的交互体验。\n\n\n\n### 谈谈你对Web Workers的理解\n\nWeb Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：\n\n1. 无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。\n\n2. 无法访问全局对象：Web Workers 不能访问许多全局对象，如 `window` 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。\n\n3. 无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。\n\n4. 无法加载其他脚本：Web Workers 无法使用 `<script>` 标签加载其他脚本。但是，可以使用 `importScripts()` 函数来导入其他脚本。\n\n5. 数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。\n\n6. 运行环境的限制：Web Workers 运行在不同的全局上下文中，即 `DedicatedWorkerGlobalScope`，而不是主线程的 `window`。因此，一些预期在 `window` 上下文中使用的代码在 Web Worker 中可能无法正常工作。\n\n总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。\n\n\n\n### 谈谈你对V8垃圾回收的理解？\n\nV8引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。\n\n1. 分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。\n2. 增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。\n\nV8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。\n\n\n\n### 如何优化和减少垃圾回收的影响，从而提高应用性能？\n\n以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：\n\n1. **避免全局变量**：全局变量不会被垃圾回收，除非它们被设置为 `null`。只有在确实需要时才应该使用它们。\n2. **使用对象池**：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。\n3. **小心闭包**：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。\n4. **手动释放大对象**：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 `null`，从而提前提示垃圾回收器。\n5. **避免循环引用**：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。\n6. **使用弱引用**：在合适的场景下，使用 `WeakMap` 或 `WeakSet` 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。\n7. **优化事件监听器**：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。\n8. **减少内存分配**：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。\n9. **使用浏览器开发者工具**：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。\n10. **考虑使用 WebAssembly**：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。\n\n\n\n<hr />\n\n## 计算机网络\n\n### 谈谈你对OSI模型的理解\n\nOSI（开放式系统互联）模型是一个用于描述计算机网络协议的七层参考模型。它是ISO（国际标准化组织）在20世纪80年代提出的，旨在促进不同类型的计算机和网络系统之间的互通性和互操作性。OSI模型可以帮助我们更好地理解网络通信过程中的各个步骤，以及如何在这些步骤中组织和使用各种协议。\n\nOSI模型从下到上共有7层，每一层都有特定的职责，它们分别是：\n\n1. 物理层（Physical Layer）：这一层负责处理与传输介质（如电缆、光纤）有关的硬件方面的问题，包括比特（0和1）的传输、电压、接口等。物理层的主要目标是确保数据在传输过程中的完整性和可靠性。\n2. 数据链路层（Data Link Layer）：数据链路层负责在网络节点之间建立、维护和拆除数据链路。它将物理层传输的比特组合成帧（frame），同时负责错误检测和流量控制。典型的数据链路层协议有以太网（Ethernet）、Wi-Fi和PPP（点对点协议）等。\n3. 网络层（Network Layer）：网络层负责将数据包（packet）从源节点路由到目标节点。它处理IP地址、路由选择、分片和重组等问题。网络层的主要协议有IP（互联网协议）、ICMP（互联网控制消息协议）等。\n4. 传输层（Transport Layer）：传输层负责在源端和目标端之间提供端到端（end-to-end）的数据传输服务。它处理数据的分段、重组、流量控制、错误检测和校正等问题。常见的传输层协议有TCP（传输控制协议）和UDP（用户数据报协议）。\n5. 会话层（Session Layer）：会话层负责在通信双方之间建立、管理和终止会话。会话层的主要职责是维护会话状态、同步数据流和进行恢复操作。尽管OSI模型中包含了会话层，但在实际的互联网协议中，很多功能已经与其他层次结合在一起，例如TCP协议。\n6. 表示层（Presentation Layer）：表示层负责处理数据的表示、编码和解码，以便在不同系统之间进行交换。这包括数据压缩、加密和字符集转换等等功能。表示层的一个典型例子是SSL/TLS协议，它在应用层协议（如HTTP）之下提供数据加密和解密服务。然而，在现代网络协议中，表示层的很多功能通常直接集成在应用层协议中，如JSON、XML等数据格式。\n7. 应用层（Application Layer）：应用层是OSI模型中最高层，它负责处理用户与网络之间的交互，提供面向用户的服务。应用层协议定义了各种应用程序如何与网络进行通信，例如发送电子邮件、浏览网页等。常见的应用层协议包括HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。\n\nOSI模型的一个重要优点是它将网络功能划分为若干模块化的层次，每个层次都有明确的职责。这种分层架构有助于降低网络设计和实现的复杂性，同时还有利于对现有协议的改进和替换，以适应不断变化的技术需求。\n\n然而，需要注意的是，OSI模型主要是一个理论框架，用于帮助我们更好地理解网络协议的组织和交互。实际上，许多现代网络协议并不完全遵循OSI模型的严格分层结构，而是采用更灵活的混合模式。例如，TCP/IP模型是互联网中最常用的网络协议体系，它将OSI模型的7层合并为4层（应用层、传输层、网络层和链路层）。尽管如此，OSI模型仍然是一个有用的概念工具，可以帮助我们更好地理解复杂的计算机网络。\n\n\n\n### 什么是HTTP，它的用途是什么？\n\nHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于在互联网上进行数据通信的应用层协议。它基于 TCP/IP 协议栈工作，通常使用 TCP 作为传输层协议。HTTP 的主要作用是规定了客户端（例如浏览器）和服务器之间的请求和响应的格式与规则，从而实现数据的交换。\n\nHTTP 的主要用途是：\n\n1. **资源获取**：客户端可以通过 HTTP 向服务器发送请求，获取 HTML、CSS、JavaScript、图片、视频等各种资源，以便呈现和运行网页或其他应用。\n2. **数据提交**：客户端可以通过 HTTP 将数据提交给服务器，例如表单提交、文件上传等。\n3. **API 交互**：客户端和服务器可以通过 HTTP 进行 API 交互，以便在前后端之间传递数据。常见的数据格式包括 JSON 和 XML。\n\nHTTP 协议的特点：\n\n1. **无状态**：HTTP 是无状态的，意味着服务器不会存储与客户端之间交互的信息。为了实现有状态的会话，可以使用 Cookie 和 Session 等技术。\n2. **简单快速**：HTTP 协议简单，易于实现。客户端和服务器之间的请求和响应报文格式统一，便于解析和处理。\n3. **可扩展**：HTTP 允许自定义请求头和响应头，可以根据需要扩展协议的功能。\n4. **明文传输**：HTTP 协议本身不提供数据加密功能，所有数据以明文形式传输。为了提高数据安全性，可以使用 HTTPS（HTTP Secure，基于 SSL/TLS 的 HTTP）进行加密传输。\n\nHTTP 协议包括一系列请求方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。此外，HTTP 协议还定义了一系列状态码，用于表示请求的结果和相关信息。\n\n\n\n### TCP中三次握手和四次挥手的含义\n\n在 TCP（传输控制协议）中，三次握手和四次挥手是用来建立和终止连接的重要过程。下面分别解释它们的含义：\n\n**三次握手（Three-Way Handshake）**：\n\n三次握手是建立 TCP 连接的过程，确保数据传输的可靠性和连接的双向通信。这个过程包含三个步骤：\n\n1. 客户端向服务器发送一个 SYN（同步）报文，表示客户端希望建立连接。报文中包含一个随机生成的序列号（Sequence Number）。\n2. 服务器收到 SYN 报文后，回复一个 SYN+ACK（同步确认）报文，其中 ACK 的值为客户端序列号加一。同时，服务器也会发送一个自己的随机序列号。\n3. 客户端收到 SYN+ACK 报文后，发送一个 ACK（确认）报文给服务器，其中 ACK 的值为服务器序列号加一。\n\n完成这三个步骤后，客户端和服务器之间的 TCP 连接就建立好了，可以进行双向通信。\n\n**四次挥手（Four-Way Handshake）**：\n\n四次挥手是终止 TCP 连接的过程。当数据传输完成后，客户端和服务器需要通过四次挥手来关闭连接。这个过程包含四个步骤：\n\n1. 客户端发送一个 FIN（完成）报文给服务器，表示客户端已完成数据发送。\n2. 服务器收到 FIN 报文后，回复一个 ACK（确认）报文给客户端，表示已收到客户端的关闭请求。此时，客户端到服务器的连接被关闭，但服务器到客户端的连接仍然存在。\n3. 当服务器完成数据发送后，也会发送一个 FIN 报文给客户端，表示服务器准备关闭连接。\n4. 客户端收到服务器的 FIN 报文后，回复一个 ACK 报文给服务器，表示已收到服务器的关闭请求。经过一段时间（通常为 2MSL，即最长报文段寿命的两倍）后，客户端关闭与服务器的连接。\n\n完成这四个步骤后，客户端和服务器之间的 TCP 连接就被完全关闭了。\n\n\n\n### TCP提供了什么服务？\n\n传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它为应用程序之间提供可靠的数据传输服务。TCP在Internet协议族中被广泛应用，与网络层协议IP（Internet Protocol）共同组成TCP/IP协议簇。\n\nTCP提供的服务包括：\n\n1. 面向连接：TCP在数据传输前建立一个连接。连接的建立、维护和终止都由TCP管理。这种面向连接的方式使得TCP适用于需要可靠通信的应用。\n2. 可靠传输：TCP通过使用确认机制、重传机制和错误校验来确保数据的可靠传输。如果数据包丢失或损坏，TCP会自动重发数据包，从而保证数据的完整性和正确性。\n3. 流量控制：TCP使用滑动窗口机制来实现流量控制，确保接收方的缓冲区不会被发送方的数据溢出。这样，发送方和接收方可以根据自身处理能力和网络状况动态调整传输速率，提高传输效率。\n4. 拥塞控制：为了防止网络拥塞，TCP使用拥塞控制算法来调整发送数据的速率。当网络出现拥塞时，TCP会减少发送速率，避免网络拥塞进一步恶化。当网络恢复正常时，TCP会逐渐提高发送速率。\n5. 数据排序：TCP会为每个数据包分配一个序号，接收方可以根据序号重新组合数据包，从而确保数据按正确顺序传输。\n6. 复用与分用：TCP允许多个应用程序在同一台主机上通过不同的端口共享网络资源。这意味着多个应用程序可以在同一时间使用TCP进行数据传输，而不会互相干扰。\n\n\n\n### SSL/TLS是如何握手的？\n\nSSL（安全套接层）和TLS（传输层安全）协议用于在互联网上建立安全的、加密的通信连接。尽管TLS是SSL的后续版本，但在实际用语中，它们经常互换使用。TLS握手过程可以分为以下几个步骤：\n\n1. 客户端发起连接：客户端（例如，浏览器）向服务器发起一个安全连接请求。这个请求包括客户端支持的TLS版本、支持的加密套件（加密算法和密钥交换方法的组合）以及一个随机数（ClientHello 随机数）。\n2. 服务器响应：服务器从客户端提供的加密套件列表中选择一个加密套件，并向客户端返回服务器的证书（包含公钥和服务器身份信息）、选择的TLS版本和加密套件，以及一个随机数（ServerHello 随机数）。此外，如果需要客户端身份验证，服务器还会请求客户端的证书。\n3. 证书验证：客户端验证服务器证书的有效性。证书应由受信任的证书颁发机构（CA）签名。这一步的目的是确保与客户端通信的服务器是可信的，防止中间人攻击。\n4. 密钥交换：客户端使用服务器证书中的公钥加密一个新的随机数（称为 Pre-Master Secret），并将其发送给服务器。服务器使用其私钥解密 Pre-Master Secret。然后，客户端和服务器分别使用 ClientHello 随机数、ServerHello 随机数和 Pre-Master Secret，通过一个伪随机函数生成主密钥（Master Secret）。这个主密钥将用于之后的对称加密和解密操作。\n5. 客户端和服务器协商参数：客户端和服务器根据主密钥生成一组加密参数（例如，对称密钥、初始化向量、消息验证码等），这些参数将用于保护后续的数据传输。\n6. 客户端和服务器验证握手过程：客户端发送一个加密的 Finished 消息，服务器解密并验证消息的完整性。服务器也发送一个加密的 Finished 消息，客户端解密并验证。这一步的目的是确保双方已正确完成密钥交换和参数协商。\n7. 加密数据传输：完成握手过程后，客户端和服务器使用协商的加密参数进行安全的数据传输。此时，所有传输的数据都是加密的，以确保其机密性和完整性。\n\nTLS握手过程旨在在客户端和服务器之间建立一个安全、加密的通信通道，以保护数据在互联网上的传输。\n\n\n\n### 数字证书里面主要包含什么信息？\n\n数字证书，通常用于 SSL/TLS 通信和其他加密场景，是一个电子文档，用于证明公钥的所有权和身份。数字证书通常由认证机构 (CA) 签署。以下是数字证书中主要的包含的信息：\n\n1. **主体信息（Subject）**：\n    - **公钥（Public Key）**：该证书对应的公钥。\n    - **主体的名称（Subject Name）**：通常为网站的域名或组织的名称。\n    - **组织名称（Organization Name）**：证书持有者的组织或公司名称（例如，\"OpenAI Inc.\"）。\n    - **组织单位（Organizational Unit, OU）**：组织内的特定部门或单位。\n    - **地理位置信息**：如国家（Country）、州/省（State/Province）、城市（Locality）等。\n\n2. **颁发者信息（Issuer）**：\n    - **颁发者名称（Issuer Name）**：签发该证书的证书认证机构 (CA) 的名称。\n    - 和主体类似，可能还包括组织名称、组织单位、国家等信息。\n\n3. **有效期（Validity Period）**：\n    - **开始日期（Not Before）**：证书的有效开始日期。\n    - **结束日期（Not After）**：证书的过期日期。\n\n4. **序列号（Serial Number）**：颁发者给证书分配的唯一编号，用于识别。\n\n5. **签名算法（Signature Algorithm）**：用于签署此证书的算法（如 RSA、ECDSA 或其他）。\n\n6. **证书签名（Signature）**：CA 使用其私钥生成的证书的数字签名。这使得其他人可以使用 CA 的公钥来验证证书的真实性和完整性。\n\n7. **扩展和约束（Extensions and Constraints）**：这些是可选的，但在许多证书中都有。它们为证书提供了额外的属性和规则。例如：\n    - **Key Usage**：描述公钥可以用于什么（例如，数据加密、数字签名等）。\n    - **Extended Key Usage**：进一步详细说明公钥的使用，如服务器身份验证、客户端身份验证等。\n    - **Subject Alternative Name (SAN)**：除主体名称外，其他有效的名称（通常用于多域名或通配符证书）。\n    - **Certificate Policies**：关于证书如何使用和 CA 如何管理证书的策略。\n\n8. **版本（Version）**：证书的版本号。目前，最常见的版本是 v3。\n\n当客户端（例如，web 浏览器）接收到数字证书时，它会使用相关 CA 的公钥来验证证书的签名，从而验证证书的真实性。此过程有助于确保在网络上进行的通信是安全和加密的。\n\n\n\n### Websocket与Ajax的区别？\n\nWebSocket 和 Ajax 是两种不同的 Web 技术，它们在实现客户端与服务器之间通信时有一些区别。以下是它们之间的主要区别：\n\n1. **连接方式**：\n   - WebSocket：WebSocket 是一种全双工通信协议，建立连接后，客户端和服务器之间可以同时进行数据发送和接收。WebSocket 连接在建立后会保持连接状态，直至显式断开连接。\n   - Ajax：Ajax（Asynchronous JavaScript and XML）是一种基于 HTTP 协议的异步请求技术。每次 Ajax 请求都需要建立一个新的 HTTP 连接，请求完成后连接会被关闭。因此，Ajax 是一种基于请求-响应模式的半双工通信方式。\n2. **实时性**：\n   - WebSocket：由于 WebSocket 是全双工通信，服务器可以在任何时候主动向客户端发送数据，因此实时性较强，适用于实时通信、在线游戏等场景。\n   - Ajax：由于 Ajax 基于请求-响应模式，服务器不能主动向客户端发送数据，客户端需要定期发起请求以获取更新。因此，实时性相对较弱，适用于非实时的数据获取和更新。\n3. **开销和性能**：\n   - WebSocket：WebSocket 在建立连接后会保持连接状态，因此减少了频繁建立和断开连接的开销。同时，WebSocket 使用自己的二进制分帧格式进行数据传输，帧头较小，数据传输效率较高。\n   - Ajax：每次 Ajax 请求都需要建立新的 HTTP 连接，这会导致一定的性能开销。另外，HTTP 协议的请求和响应头部较大，相对降低了数据传输效率。\n\n总结：WebSocket 适用于实时性要求较高、需要双向通信的场景，而 Ajax 更适用于传统的 Web 应用，用于获取和更新数据。根据实际应用需求，可以选择合适的技术进行通信。\n\n\n\n### HTTP1.0、HTTP1.1、HTTP2.0之间有什么区别\n\n1. **HTTP/1.0**:\n   - **无连接**：每个 HTTP 请求打开一个新的连接，请求结束后立即关闭连接。\n   - **无状态**：每个请求都是独立的，服务器不保存之前的请求信息。\n   - **缓存**：使用简单的 `Pragma: no-cache` 来避免缓存。\n\n2. **HTTP/1.1**:\n   - **长连接**：引入了持久连接，这意味着多个 HTTP 请求和响应可以在一个连接中连续发送，避免了为每个请求都建立新连接的开销。这是通过 `Connection: keep-alive` 头来实现的。\n   - **管线化**：请求可以同时被发送，但是服务器必须按照它们接收到的顺序来逐一响应。\n   - **缓存控制**：更加详细和精确的缓存头，如 `Cache-Control`，提供了更好的缓存管理。\n   - **主机头的要求**：允许多个域名解析到同一 IP 地址，从而使虚拟主机成为可能。\n   - **错误通知**：增加了更多的状态码和更丰富的错误信息。\n\n3. **HTTP/2**:\n   - **二进制协议**：不再是像 HTTP/1.x 那样的文本协议，而是一个二进制协议。这使得协议的解析、网络传输更高效。\n   - **多路复用**：允许多个请求和响应在一个连接上同时并行交换，解决了 HTTP/1.1 中的“线头阻塞”问题。\n   - **优先级和权重**：可以为请求设置优先级和权重，使得重要的请求得到更快的响应。\n   - **服务器推送**：服务器可以对客户端“推送”资源，即使客户端尚未请求。\n   - **首部压缩**：使用 HPACK 压缩，减少了请求和响应的大小。\n   - **更强的流控制**：为每一个流提供了流控制机制。\n\n\n\n### HTTP/2相比HTTP/1.1新增了什么\n\nHTTP/2 是 HTTP/1.1 的升级版本，旨在解决 HTTP/1.1 中的一些性能问题，提高网络传输的效率。HTTP/2 相比于 HTTP/1.1 主要有以下新增特性：\n\n1. **二进制分帧**：HTTP/2 将数据以二进制格式进行传输，请求和响应被分解为更小的帧，每个帧有自己的类型和标识符。这使得数据传输更加高效，易于解析。\n2. **多路复用**：HTTP/2 允许在同一个 TCP 连接上同时发送和接收多个请求和响应，避免了 HTTP/1.1 中的队头阻塞问题。这样可以提高页面加载速度，减少网络延迟。\n3. **头部压缩**：HTTP/2 使用 HPACK 压缩算法对请求和响应头部进行压缩，减小了传输数据的大小，从而降低了传输延迟。\n4. **服务器推送**：HTTP/2 服务器可以主动将一些尚未被客户端请求的资源推送给客户端，以便客户端在需要时立即使用，提高了资源加载速度。\n\n\n\n### HTTP/3相比HTTP/2解决了哪些问题？\n\nHTTP/3 是互联网工程任务组（IETF）制定的新一代 HTTP（超文本传输协议）标准，它基于 QUIC 协议（快速 UDP 互联网连接），旨在解决 HTTP/2 存在的一些问题，提高网络性能和安全性。相较于 HTTP/2，HTTP/3 主要解决了以下问题：\n\n1. 首部阻塞（Head-of-line blocking）：在 HTTP/2 中，多个请求和响应通过同一个 TCP 连接进行多路复用。由于 TCP 是面向连接的、可靠的传输协议，要求数据按顺序到达，当其中一个数据包丢失或延迟时，整个连接的其他数据包必须等待，直到丢失的数据包被重新传输并到达。这种现象被称为首部阻塞。HTTP/3 采用基于 UDP 的 QUIC 协议，它允许单独处理每个数据流，从而消除了首部阻塞问题。\n2. 连接建立延迟：HTTP/2 在建立 TCP 连接之后，还需要通过 TLS 握手建立安全连接。这意味着需要多次往返才能完成连接建立。而 HTTP/3 使用 QUIC 协议，它将传输层（TCP）和安全层（TLS）整合在一起，从而减少了连接建立所需的往返次数。对于已经与服务器建立过连接的客户端，QUIC 甚至可以实现 0-RTT（零往返时间）连接建立，大幅降低了延迟。\n3. 更好的网络路径迁移：当客户端或服务器的 IP 地址发生变化时（如移动设备在 Wi-Fi 和移动网络之间切换），TCP 连接可能中断，需要重新建立。HTTP/3 的 QUIC 协议提供了内置的连接迁移特性，允许在 IP 地址变化时保持连接状态，减少中断和延迟。\n4. 拥塞控制和恢复：由于 HTTP/3 使用 QUIC 协议，它可以在单独的数据流上实现更细粒度的拥塞控制。这意味着当一个数据流受到网络拥塞影响时，其他数据流可以继续正常传输，不受影响。同时，QUIC 采用了更先进的丢包恢复机制，使得数据传输更加高效和可靠。\n\n尽管 HTTP/3 有很多优势，但它目前仍在逐步推广和普及。浏览器和服务器需要支持 QUIC 协议，以便充分利用 HTTP/3 带来的改进。\n\n\n\n### GET和POST请求的区别是什么？\n\nGET和POST是HTTP协议中最常见的两种请求方法，它们之间的主要区别包括：\n\n1. **请求参数的传递方式不同**：\n   - GET请求的参数被附加到URL之后，以键值对的形式出现，各参数之间以&符号分割，如`http://example.com/page?param1=value1&param2=value2`。\n   - POST请求的参数存储在请求体（Request Body）中。\n\n2. **数据大小的限制不同**：\n   - GET由于受URL长度限制，所以能传递的参数量相对有限。\n   - POST请求由于参数在请求体中，理论上数据量没有限制，但实际上大小会受到WEB服务器的限制。\n\n3. **安全性不同**：\n   - GET请求的参数直接被包含在URL中，数据暴露给了用户，安全性较低，因此不适合传递敏感信息。\n   - POST请求的参数在请求体中，用户无法在地址栏看到，安全性相对较高。\n\n4. **可缓存**：\n   - GET请求的结果通常可以被浏览器或代理服务器缓存。\n   - POST请求的结果则通常不被缓存。\n\n5. **幂等性和副作用**：\n   - GET是幂等的，也就是说，无论调用一次还是多次，产生的效果是相同的。\n   - POST不是幂等的，每次请求都可能导致不同的结果。\n\n6. **请求的用途**：\n   - GET通常用于请求服务器数据，例如网页浏览、图片加载等。\n   - POST通常用于提交数据给服务器，例如表单提交、文件上传等。\n\n虽然GET和POST是最常见的HTTP请求方法，但HTTP协议还定义了其他一些请求方法，如PUT、DELETE、PATCH、HEAD等，每种方法都有其特定的用途和语义。\n\n\n\n### TCP与UDP有什么区别？\n\nTCP（传输控制协议）和UDP（用户数据报协议）是互联网协议套件的两个主要协议，它们用于不同类型的网络服务，并具有各自的特点和用途。以下是它们的主要区别：\n\n1. **连接类型**：\n   - TCP是一种面向连接的协议，这意味着在数据交换之前，必须首先建立连接。一旦建立了连接，就会保持开放状态，直到所有数据传输完毕。TCP使用的是可靠的通信通道，确保数据的完整性和顺序。\n   - UDP是一种无连接的协议，这意味着它不需要在发送数据之前建立连接。因此，UDP的通信通道是不可靠的，无法保证数据的完整性和顺序。\n\n2. **速度和可靠性**：\n   - TCP提供了一种可靠的数据传输方法，通过校验和、序列号、确认应答、重传机制和拥塞控制等机制，确保数据在网络中的正确无误的传输。但这些特性使得TCP相比UDP来说速度较慢。\n   - UDP不提供数据可靠性，它只是简单地发送数据，不进行错误检查或数据恢复。这意味着如果网络出现问题，数据可能会丢失。但由于缺少了这些额外的特性，UDP的速度通常比TCP快。\n\n3. **使用场景**：\n   - TCP常用于需要高可靠性的应用，如Web浏览器、电子邮件服务、文件传输等。\n   - UDP常用于对实时性要求较高、可接受一些数据丢失的应用，如流媒体、在线游戏和VoIP（网络电话）。\n\n4. **报头长度**：\n   - TCP的报头长度更长，最小为20字节，因为它包含了许多控制信息（如序列号和确认号）。\n   - UDP的报头长度较短，只有8字节，因为它只提供基本的功能。\n\n5. **流量控制和拥塞控制**：\n   - TCP有内置的流量控制和拥塞控制机制，这使得TCP可以在网络繁忙时降低数据发送速度，以防止数据丢失。\n   - UDP没有这些控制机制，所以在网络繁忙时可能会导致大量数据丢失。\n\n总的来说，TCP和UDP都有它们各自的优势和使用场景。选择使用哪一个协议取决于特定的应用需求，如需要可靠性还是速度，以及对数据丢失的容忍度。\n\n\n\n### 常见的API设计规范有哪些？\n\n确实，RESTful是API设计中的一种非常流行的设计风格，但并非唯一的设计规范。除了RESTful之外，还有一些其他的API设计规范和架构风格，包括：\n\n1. **REST (Representational State Transfer)**：REST是一种软件架构风格，通常用于设计网络应用程序。RESTful API遵循一组约定，如使用HTTP方法（GET，POST，PUT，DELETE等），使用路径来表示资源，并在可能的情况下，使用HTTP状态代码来表示错误。RESTful API通常使用JSON进行数据传输。\n2. **GraphQL**：GraphQL是一个开源的数据查询和操作语言，同时也是一个运行时系统，用于现有数据的查询。与REST不同，GraphQL允许客户端精确地获取它需要的数据，而无需获取额外的信息。这可以帮助解决RESTful设计中的过度获取和信息获取不足的问题。\n3. **gRPC**：gRPC是一个高性能、开源的通用RPC框架，它由Google开发。gRPC提供了一种简单的方法来定义服务：客户端应用程序可以直接在服务器上调用方法，就像是本地对象一样，而不用考虑底层的网络通信细节。\n4. **JSON-RPC和XML-RPC**：这两种都是远程过程调用(RPC)规范，它们允许在网络上的一台计算机（客户端）调用另一台计算机（服务器）上的方法或过程。JSON-RPC使用JSON来编码数据，而XML-RPC使用XML来编码数据。\n5. **OData (Open Data Protocol)**：OData是一个用于构建和消费RESTful API的开放标准。使用OData，你可以通过简单的HTTP请求进行查询和操作数据。\n6. **SOAP**：SOAP是一种基于XML的消息协议，用于在web服务中交换结构化的信息。SOAP可以与各种通信协议一起使用，包括HTTP、SMTP等。\n\n以上都是常见的API设计规范和架构风格，每种都有其特点和用途，设计API时应根据具体需求和场景进行选择。\n\n\n\n### 哪些协议底层使用UDP？\n\nUDP（用户数据报协议）是一种无连接的网络通信协议，它不保证数据报的交付、顺序或校验，从而在通信速度和网络效率上优于TCP。以下是一些在底层使用UDP的协议：\n\n1. **DNS (域名系统)**: DNS用于将互联网域名解析为IP地址。由于解析请求必须尽快完成，通常使用UDP作为传输协议。\n\n2. **DHCP (动态主机配置协议)**: DHCP是一种网络协议，用于在网络上动态分配IP地址。因为DHCP请求需要快速处理，所以通常使用UDP。\n\n3. **RTP (实时传输协议)**: RTP用于实时传输音频和视频数据。RTP通常与RTCP (RTP 控制协议)一起使用，用于媒体流的同步和质量反馈。RTP使用UDP，因为对于实时媒体流来说，速度和效率比确保每个包的交付更重要。\n\n4. **SNMP (简单网络管理协议)**: SNMP用于管理和监控网络设备。SNMP消息需要快速发送并响应，因此使用UDP。\n\n5. **NTP (网络时间协议)**: NTP用于在网络中同步时钟。NTP消息需要快速交付，所以通常使用UDP。\n\n6. **QUIC (快速UDP互联网连接)**: QUIC是一种多路复用的传输层协议，用于在HTTP/3中替代TCP。QUIC使用UDP，以减少连接和重新传输的延迟。\n\n7. **VoIP (语音 over IP)**: VoIP技术，如Skype和一些其他的互联网电话应用，使用UDP进行音频数据传输，因为它们更关心实时性，而不是数据的完整性。\n\n\n\n### HTTP中，get、post、put、delete有什么区别？\n\nHTTP中的GET、POST、PUT、DELETE是四种常见的HTTP方法（也称为“动词”），它们各自代表了不同的操作，通常用于RESTful Web服务中。以下是这四种方法的基本区别：\n\n1. **GET**：\n   - 用途：获取资源信息。\n   - 安全性：GET是安全的，这意味着它只是获取信息并不改变资源状态。\n   - 幂等性：GET是幂等的，这意味着多次执行同一GET请求，结果都是一样的。\n   - 数据传输：参数包含在URL中，因此数据量有限，并且可能被记录在日志中。\n   - 缓存：GET请求的响应是可以被缓存的。\n   - 示例：访问一个网页或获取某个项目的详细信息。\n\n2. **POST**：\n   - 用途：提交数据并创建新资源。\n   - 安全性：POST不是安全的，因为它可能改变资源的状态。\n   - 幂等性：POST不是幂等的，因为重复发送同一个POST请求可能会有不同的效果（例如，重复创建相同的资源）。\n   - 数据传输：参数不在URL中，而是在请求体中。因此，可以发送大量的数据。\n   - 示例：填写并提交一个表单。\n\n3. **PUT**：\n   - 用途：更新现有资源或创建新资源。\n   - 安全性：PUT不是安全的。\n   - 幂等性：PUT是幂等的，重复执行同一PUT请求应该总是产生相同的结果。\n   - 数据传输：数据在请求体中。\n   - 示例：更新一个项目的详细信息。\n\n4. **DELETE**：\n   - 用途：删除资源。\n   - 安全性：DELETE不是安全的。\n   - 幂等性：DELETE是幂等的，因为无论删除多少次，资源都已经被删除。\n   - 数据传输：通常不带请求体，资源标识通常在URL中。\n   - 示例：删除一个项目。\n\n\n\n<hr />\n\n## MVVM框架\n\n### 为什么 data 在组件内必须是函数，而 vue 的根实例则没有此限制？\n\n在 Vue 组件中，`data` 必须是一个函数，因为组件可能会被多次实例化。如果 `data` 是一个对象，那么所有组件实例将共享相同的数据对象。这样一来，当一个组件实例修改了数据时，所有其他实例的数据也会被更改，这是我们不希望看到的。使用函数可以确保每次实例化组件时，都会返回一个全新的数据对象副本，从而保证组件实例之间的数据隔离。\n\n在 Vue 的根实例中，这个限制并不适用。根实例只会被创建一次，因此不需要担心多个实例共享相同的数据对象。然而，将 `data` 作为函数返回对象的方式也是可以在根实例中使用的，这样可以保持一致性。但在实际开发中，为了简便，我们通常在根实例中直接使用对象作为 `data`。\n\n\n\n### vue2中选项props、data、method、computed、watch的优先级？\n\n在 Vue2 中，props、data、methods、computed 和 watch 这些选项都扮演着不同的角色，因此它们之间没有严格的优先级顺序。然而，我们可以从两个方面来理解这些选项的关系和执行顺序：数据初始化和数据更新。\n\n1. 数据初始化：\n\n在 Vue 组件实例创建和挂载的过程中，各选项的执行顺序如下：\n\na) props：父组件向子组件传递数据。当子组件实例创建时，首先从父组件接收 props 数据。\n\nb) data：组件的本地状态数据。在接收 props 数据后，组件会初始化 data。\n\nc) methods：用于在组件中定义各种方法。methods 选项在 data 初始化之后定义，这样可以在其他地方（如计算属性或侦听器）调用这些方法。\n\nd) computed：计算属性是基于其他数据（如 props、data、methods 等）计算而来的。因为计算属性依赖于其他数据，所以它们在 data 和 methods 初始化之后计算。\n\ne) watch：侦听器用于观察和响应 Vue 实例上的数据变化。watch 选项在数据初始化完成之后设置，以便在数据发生变化时触发回调函数。\n\n2. 数据更新：\n\n当组件的数据发生变化时，Vue 会根据依赖关系来更新 computed 和 watch。在这种情况下，它们的执行顺序如下：\n\na) 数据变化：当 props 或 data 中的数据发生变化时，会触发更新。\n\nb) computed：当依赖的数据发生变化时，计算属性会重新计算。由于计算属性具有缓存机制，只有当依赖数据发生变化时，它们才会重新计算。\n\nc) watch：当被观察的数据发生变化时，侦听器会触发相应的回调函数。与计算属性不同，侦听器没有缓存机制，每次数据变化都会触发回调函数。\n\n总结：在 Vue2 中，props、data、methods、computed 和 watch 这些选项都扮演着不同的角色。在组件实例创建和挂载的过程中，各选项按照特定顺序执行。在数据更新时，computed 和 watch 根据依赖关系来触发更新。\n\n\n\n### 谈谈你对vue2以及vue3双向绑定原理的理解\n\nVue.js 是一个用于构建用户界面的渐进式 JavaScript 框架。Vue 具有响应式数据绑定功能，使得数据和 DOM 之间能够双向绑定。Vue2 和 Vue3 的双向绑定原理有所不同，接下来分别介绍它们的实现原理：\n\n1. Vue2 双向绑定原理：\n\nVue2 使用的双向绑定核心原理是基于数据劫持和发布-订阅模式。Vue2 的双向绑定分为两部分：数据劫持（通过 Object.defineProperty()） 和 Watcher 类。\n\n- 数据劫持：Vue2 使用 Object.defineProperty() 方法劫持数据对象的属性，对属性的 getter 和 setter 进行拦截。当属性值被访问或修改时，会触发 getter 和 setter，实现数据的响应式。\n- Watcher 类：Watcher 用于订阅数据变化和更新视图。每个数据属性都有一个 Watcher 实例，当数据发生变化时，触发 setter，并通知 Watcher，然后 Watcher 会调用其更新函数，将新值应用到 DOM。\n\n2. Vue3 双向绑定原理：\n\nVue3 的双向绑定原理基于 Proxy 和 Reflect。Vue3 使用 Proxy 对象对数据进行代理，而不是像 Vue2 那样使用 Object.defineProperty() 进行数据劫持。\n\n- Proxy：Vue3 使用 Proxy 对象创建一个数据代理，当代理对象的属性被访问或修改时，会触发 Proxy 的拦截器函数（如 get 或 set），实现数据的响应式。\n- Reflect：Vue3 使用 Reflect API 进行对象操作，如获取属性值、设置属性值等。Reflect API 提供了一种更简洁、安全的方法来操作对象，同时具有更好的性能。\n\nVue3 相较于 Vue2 的优势：\n\n- Vue3 使用 Proxy 代替 Object.defineProperty()，可以直接监听对象的变化，而不仅仅是属性。这解决了 Vue2 中无法监听数组变化和对象属性添加的问题。\n- Vue3 使用 Proxy 可以提高性能，因为 Proxy 是原生支持的，而 Object.defineProperty() 是基于 JavaScript 层面的劫持。\n- Vue3 代码结构更简洁，易于维护。\n\n总结：Vue2 和 Vue3 的双向绑定原理都是基于数据劫持，但它们使用的技术实现方式不同。Vue2 使用 Object.defineProperty() 和发布-订阅模式，而 Vue3 使用 Proxy 和 Reflect。Vue3 相对于 Vue2 在性能和功能上有所改进。\n\n\n\n### Vue中响应式属性、dep以及watcher之间的关系是什么？\n\nVue.js 中的响应式系统是其核心特性之一，该系统使得 Vue.js 可以在数据改变时更新视图。这个响应式系统主要包含以下三个核心概念：响应式属性、Dep（依赖）以及 Watcher（观察者）。\n\n1. **响应式属性**：在 Vue.js 中，当我们在 data 对象中定义属性时，Vue.js 会将这些属性转化为 getter/setter 形式，这样就实现了响应式。当我们访问或修改一个属性时，getter/setter 就会被调用。\n\n2. **Dep（依赖）**：Dep 可以看作是一个订阅器，它维护着一个 Watcher 列表，当响应式属性被修改时，Dep 会通知它的所有 Watcher，告诉它们数据已经被更新。Dep 在 getter 中收集 Watcher，在 setter 中触发 Watcher 更新。\n\n3. **Watcher（观察者）**：Watcher 是一个观察者对象，它观察某个响应式属性的变化。当响应式属性的 getter 被访问时，Dep 会将当前的 Watcher 添加到自己的订阅者列表中。当响应式属性被修改时，Dep 会通知 Watcher，然后 Watcher 会执行相应的操作（比如更新视图）。\n\n所以，**响应式属性、Dep 和 Watcher 之间的关系**可以这样理解：响应式属性是被观察的目标，Dep 是观察者（Watcher）和目标（响应式属性）之间的桥梁，它负责添加观察者，也负责在目标发生改变时通知观察者。Watcher 则是观察者，它观察响应式属性的变化，当变化发生时，执行相应的操作。\n\n总的来说，这种关系构成了 Vue.js 的响应式系统，使得 Vue.js 可以在数据改变时自动更新视图。\n\n\n\n### Vue中，Watcher有哪些类型？\n\n在 Vue.js 中，Watcher（观察者）是响应式系统的重要组成部分，它用于在某个数据发生变化时执行特定的回调函数。在 Vue.js 中，主要有以下几种类型的 Watcher：\n\n1. **渲染 Watcher**：每一个组件实例都有对应的一个渲染 Watcher。当组件的数据变化时，渲染 Watcher 会被触发，进而重新渲染组件。这种类型的 Watcher 是 Vue 内部自动创建的，用于保证组件视图的更新。\n\n2. **用户 Watcher**：这是用户通过 `vm.$watch()` API 或组件的 `watch` 选项创建的 Watcher。用户可以通过这种方式来监听某个数据的变化，并在变化时执行特定的回调函数。\n\n3. **计算属性 Watcher**：这种类型的 Watcher 用于计算属性（computed property）。当计算属性所依赖的数据发生变化时，计算属性 Watcher 会被触发，从而重新计算属性的值。\n\n以上就是 Vue.js 中主要的几种 Watcher。这些 Watcher 都在 Vue 的响应式系统中起到了关键的作用，使得 Vue 可以在数据改变时自动更新视图。\n\n\n\n### vue2和vue3分别的父组件和子组件的渲染时机？\n\n**vue2:**\n\n- **初始化渲染时机**\n\n  父beforeCreate => 父created => 父beforeMount => 子beforeCreate => 子created => 子beforeMount => 子mounted => 父mounted\n\n- **更新过程**\n\n  父beforeUpdate => 子beforeUpdate => 子updated => 父updated\n\n- **销毁过程**\n\n  父beforeDestory => 子beforeDestory => 子destoryed => 父destoryed\n\n**vue3:**\n\n- **初始化渲染时机**\n\n  父setup => 父beforeCreate => 父created => 父beforeMount => 子setup => 子beforeCreate => 子created => 子beforeMount => 子mounted => 父mounted\n\n- **更新过程**\n\n  父beforeUpdate => 子beforeUpdate => 子updated => 父updated\n\n- **销毁过程**\n\n  父beforeUnmount => 子beforeUnmount => 子unmounted => 父unmounted\n\n\n\n### 谈谈你对vue2以及vue3整个渲染过程的理解\n\nVue.js 是一个用于构建用户界面的渐进式 JavaScript 框架。Vue2 和 Vue3 的渲染过程有所不同，下面分别介绍它们的渲染过程：\n\n1. Vue2 渲染过程：\n\nVue2 的渲染过程主要包括以下步骤：\n\n1. 解析模板：Vue2 使用基于 HTML 的模板语法。Vue 会将模板解析成抽象语法树（AST）。\n\n2. 生成渲染函数：Vue2 会将 AST 转换为渲染函数（render function）。渲染函数是一个纯 JavaScript 函数，用于创建和更新虚拟 DOM 树。\n\n3. 响应式数据：Vue2 使用 Object.defineProperty() 为数据对象创建 getter 和 setter。当数据发生变化时，会触发 setter，并通知对应的 Watcher 实例。\n\n4. 创建 Watcher：对于每个数据属性，Vue2 会创建一个 Watcher 实例。Watcher 负责订阅数据变化，并在数据更新时调用渲染函数。\n\n5. 首次渲染：在实例创建时，Vue2 会调用渲染函数生成虚拟 DOM 树，并将其映射到实际的 DOM 节点上。\n\n6. 更新：当数据发生变化时，Vue2 会重新调用渲染函数生成新的虚拟 DOM 树。然后，使用虚拟 DOM 的 diff 算法（称为 patching）找出变化的部分，并更新实际的 DOM。\n\nVue3 渲染过程：\n\nVue3 的渲染过程与 Vue2 类似，但有一些关键的改进和优化。以下是 Vue3 渲染过程的主要步骤：\n\n1. 解析模板：Vue3 同样使用基于 HTML 的模板语法，并将模板解析成抽象语法树（AST）。\n2. 生成渲染函数：Vue3 会将 AST 转换为渲染函数。Vue3 的渲染函数使用了一种新的编译策略，称为 \"优化模式\"，可以在编译阶段静态地分析模板中的动态绑定，并生成更高效的代码。\n3. 响应式数据：Vue3 使用 Proxy 对象代替 Object.defineProperty()，创建数据的响应式代理。这提供了更好的性能和更广泛的数据监听能力。\n4. 创建 Watcher：Vue3 中仍然使用 Watcher 实例订阅数据变化，并在数据更新时调用渲染函数。但 Vue3 的 Watcher 实现有所优化，减少了不必要的计算和渲染。\n5. 首次渲染：与 Vue2 类似，Vue3 会在实例创建时调用渲染函数生成虚拟 DOM 树，并将其映射到实际的 DOM节点上。\n6. 更新：当数据发生变化时，Vue3 会重新调用渲染函数生成新的虚拟 DOM 树。然后，使用优化后的虚拟 DOM diff 算法找出变化的部分，并更新实际的 DOM。Vue3 的 diff 算法经过优化，可以更快地找到差异并更新 DOM。\n7. 组合式 API：Vue3 引入了组合式 API，它是一种更灵活的组织和复用组件逻辑的方式。使用组合式 API，可以更容易地将代码分解为独立的、可重用的函数。这对于更大型的项目和更复杂的组件逻辑非常有用。\n\n总结：Vue2 和 Vue3 的渲染过程有很多相似之处，如解析模板、生成渲染函数、响应式数据、创建 Watcher、首次渲染和更新。然而，Vue3 在性能、响应式系统和组件逻辑复用方面进行了优化和改进，提供了更高效和灵活的渲染过程。\n\n<img src=\"https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_05_31_BBZDb5.jpg\" style=\"width: 50%\" />\n\n\n\n### 说下nextTick的原理\n\nVue 的 `nextTick` 函数是一个非常实用的工具方法，它允许我们在 DOM 更新完成后延迟执行一个回调函数。这在某些情况下非常有用，例如当你需要在数据变化后操作 DOM 元素时。接下来我们来详细了解 `nextTick` 的原理。\n\nVue 中的数据变化是异步的。当数据发生变化时，Vue 不会立即更新 DOM，而是将更新任务推入一个队列。在同一事件循环中发生的所有数据变化都会被加入到这个队列中。在下一个事件循环（也就是下一个 \"tick\"）开始时，Vue 会清空队列，并批量执行 DOM 更新。这种机制可以避免不必要的 DOM 更新，从而提高性能。\n\n`nextTick` 的作用就是在这个队列清空并且 DOM 更新完成后，执行我们传给它的回调函数。这样我们可以确保回调函数在 DOM 更新后执行，让我们可以安全地操作已经更新过的 DOM 元素。\n\n为了实现 `nextTick`，Vue 使用了一个任务队列和一种任务调度策略。具体实现取决于浏览器支持的 API。Vue 首选使用 `Promise.then()`、`MutationObserver` 或 `setImmediate` 进行异步调度。如果浏览器不支持这些 API，Vue 会退回到使用 `setTimeout(fn, 0)`。\n\n总结，`nextTick` 的原理是基于 Vue 的异步更新队列和任务调度策略。通过使用 `nextTick`，我们可以在 DOM 更新完成后执行回调函数，确保在操作 DOM 时，数据已经被更新。\n\n\n\n### 谈谈你对keep-alive的理解\n\n`keep-alive` 是 Vue 中的一个内置组件，它用于缓存组件的状态以提高性能。当我们在不同组件之间切换时，通常组件会被销毁并重新创建。然而，在某些情况下，我们可能希望保留组件的状态，以避免不必要的重新渲染。这时，我们可以使用 `keep-alive` 组件来实现这个目的。\n\n以下是关于 `keep-alive` 的一些关键点：\n\n1. 缓存组件：将组件包裹在 `keep-alive` 标签内，可以使其状态得到缓存。当组件被切换时，它不会被销毁，而是被缓存起来。当组件重新被激活时，它的状态会被恢复，而不是重新创建。\n2. 生命周期钩子：当组件被 `keep-alive` 包裹时，组件的生命周期钩子会发生变化。组件在被激活和停用时，分别触发 `activated` 和 `deactivated` 生命周期钩子。这使得我们可以在这两个钩子函数中执行一些特定的逻辑，如获取数据或重置状态。\n3. 包含和排除组件：`keep-alive` 组件提供了 `include` 和 `exclude` 属性，允许我们有选择地缓存特定的组件。我们可以通过组件名称或正则表达式来指定要缓存的组件。\n4. 缓存策略：`keep-alive` 还提供了一个 `max` 属性，允许我们设置缓存组件的最大数量。当缓存组件的数量超过这个限制时，最早的组件会被销毁。\n\n总结：`keep-alive` 是 Vue 的内置组件，用于缓存组件状态以提高性能。通过将组件包裹在 `keep-alive` 标签内，我们可以在不同组件之间切换时保留它们的状态。`keep-alive` 还提供了一些属性来控制缓存行为，如包含和排除组件、设置缓存最大数量等。同时，`keep-alive` 影响了组件的生命周期钩子，引入了 `activated` 和 `deactivated` 钩子。\n\n\n\n### 讲讲vue组件之间的通信\n\n组件通信有如下分类：\n\n- 父子组件之间的通信\n  - `props`/`$emit`。\n  - `$parent`/`$children`\n  - `ref`\n  - `provide`/`inject`\n  - `$attrs`/`$listeners` => vue3已移除\n  - `$on`/`$emit` => vue3已移除\n- 兄弟组件之间的通信\n  - `eventBus`\n  - `vuex`\n- 跨级通信\n  - `eventBus`\n  - `vuex`\n  - `provide`/`inject`\n  - `$attrs`/`$listeners`\n  - `$on`/`$emit`\n\n这里讲下eventBus，eventBus又称为事件总线，在vue中可以用来作为组件间的沟通桥梁，所有组件公用相同的事件中心，可以向该中心发送事件和监听事件。eventBus的缺点是就是当项目较大时，容易造成难以维护的灾难。\n\n```javascript\n// event-bus.js\nimport Vue from \'vue\'\nexport const EventBus = new Vue()\n\n// Children1.vue\nthis.$bus.$emit(\'foo\') \n\n// Children2.vue\nthis.$bus.$on(\'foo\', this.handle) \n```\n\n\n\n### 谈谈你对vue2以及vue3生命周期的理解\n\nVue 生命周期指的是 Vue 组件从创建到销毁经历的不同阶段。在组件的生命周期中，Vue 提供了一系列生命周期钩子函数，允许我们在特定时刻执行一些自定义逻辑。Vue2 和 Vue3 的生命周期钩子有些许不同，下面分别介绍它们。\n\n1. Vue2 生命周期钩子：\n\na) beforeCreate：在实例创建之后，数据观测、属性计算等初始化之前触发。\n\nb) created：在实例创建完成后，数据观测、属性计算等已经初始化完毕，但尚未开始 DOM 编译和挂载。\n\nc) beforeMount：在模板编译完成、挂载 DOM 之前触发。此时，虚拟 DOM 已创建，真实 DOM 尚未更新。\n\nd) mounted：在模板编译完成、挂载 DOM 之后触发。此时，真实 DOM 已经更新。\n\ne) beforeUpdate：在数据发生变化，组件重新渲染之前触发。此时，可以获取到旧的 DOM 结构。\n\nf) updated：在数据发生变化，组件重新渲染并更新 DOM 之后触发。此时，可以获取到新的 DOM 结构。\n\ng) beforeDestroy：在实例销毁之前触发。此时，实例仍然完全可用。\n\nh) destroyed：在实例销毁之后触发。此时，实例的所有指令绑定、事件监听器等都已经解除。\n\n1. Vue3 生命周期钩子：\n\nVue3 的生命周期钩子基本与 Vue2 类似，但有一些命名上的变化。这些变化主要是为了与 Vue3 的组合式 API 保持一致：\n\na) beforeCreate -> setup：在 Vue3 中，setup 函数取代了 beforeCreate 和 created 生命周期钩子。组件的数据和方法在 setup 函数中定义。\n\nb) created：由于有了 setup 函数，created 生命周期钩子在 Vue3 中不再使用。\n\nc) beforeMount：与 Vue2 中相同。\n\nd) mounted：与 Vue2 中相同。\n\ne) beforeUpdate：与 Vue2 中相同。\n\nf) updated：与 Vue2 中相同。\n\ng) beforeUnmount：Vue3 中将 beforeDestroy 重命名为 beforeUnmount。\n\nh) unmounted：Vue3 中将 destroyed 重命名为 unmounted。\n\n总结：Vue2 和 Vue3 的生命周期钩子基本相似，允许我们在组件的不同阶段执行自定义逻辑。主要区别在于 Vue3 引入了 setup 函数取代了 beforeCreate 和 created 生命周期钩子，并将 beforeDestroy 和 destroyed 重命名为 beforeUnmount 和 unmounted。这些变化使得 Vue3 生命周期钩子与组合式 API 保持一致。\n\n\n\n### 什么情况下会创建Watcher(观察者)？什么情况下会创建Dep(依赖容器)对象？\n\n在 Vue.js 中，Watcher 对象和 Dep 对象的创建时机如下：\n\n1. 创建 Watcher 对象的情况：\n\n- 编译模板：在编译模板时，Vue.js 解析模板中的指令（如 v-model、v-bind 等）和插值表达式（如 {{message}}），为每个指令或表达式创建一个 Watcher 对象。这些 Watcher 对象负责监听数据变化并在数据发生变化时更新视图。\n- 手动实例化：当需要手动监控某个表达式或计算属性时，可以创建一个 Watcher 对象。例如，在 Vue 组件中，可以使用 vm.$watch() 方法创建一个 Watcher 对象以监听某个数据属性或计算属性的变化。\n\n1. 创建 Dep 对象的情况：\n\n- 响应式数据：当 Vue 组件实例化时，Vue.js 会遍历组件的 data 对象。对于 data 对象中的每个属性，Vue.js 使用 Object.defineProperty() 方法进行劫持。在这个过程中，会为每个属性创建一个 Dep 对象。Dep 对象（依赖容器）负责收集所有与该属性相关的 Watcher 对象（观察者）。当属性被访问时，Dep 会将当前的 Watcher 对象添加到其依赖列表中，实现依赖收集。\n\n总结一下，Watcher 对象主要在编译模板和手动监控表达式或计算属性时创建。Dep 对象主要在 Vue 组件实例化时为 data 对象中的每个属性创建。这两种对象共同构成了 Vue.js 的响应式系统，实现数据与视图之间的双向绑定。\n\n\n\n### vue3相比vue2新增了什么？\n\nVue3 相对于 Vue2 引入了许多新特性和优化，这些变化使得 Vue3 在性能、可扩展性和易用性方面有了很大提升。以下是 Vue3 相比于 Vue2 的主要新增内容：\n\n1. Composition API：Vue3 引入了组合式 API，这是一种新的组件逻辑组织方式，允许更灵活地复用和组合组件逻辑。相比于 Vue2 的选项式 API，组合式 API 更容易让我们在大型项目中管理和维护代码。\n2. 更好的性能：Vue3 在性能方面进行了很多优化，包括更小的打包体积、更快的渲染速度以及更高效的组件更新。这些优化使得 Vue3 的性能比 Vue2 更强大。\n3. 更小的体积：Vue3 的编译器和运行时都经过了优化，使得打包后的体积更小。此外，Vue3 支持 tree-shaking，可以进一步减小最终构建文件的大小。\n4. 更好的 TypeScript 支持：Vue3 的源代码完全使用 TypeScript 重写，因此 Vue3 提供了更好的 TypeScript 支持和类型推导。\n5. 新的生命周期钩子和更改：Vue3 为了与组合式 API 保持一致，对生命周期钩子进行了一些重命名，例如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。同时，Vue3 引入了 setup 函数来代替 beforeCreate 和 created 生命周期钩子。\n6. 更强大的响应式系统：Vue3 使用 Proxy 对象重写了响应式系统，解决了 Vue2 中的一些限制（例如，对象属性的动态添加和删除）。新的响应式系统还提供了更好的性能和内存管理。\n7. Fragment 和 Teleport：Vue3 支持 Fragment（片段），允许一个组件具有多个根元素。此外，Vue3 引入了 Teleport 组件，可以将子组件渲染到 DOM 中的任意位置，解决了一些特殊场景下的渲染问题。\n8. Suspense：Vue3 引入了 Suspense 组件，允许我们在异步组件加载时展示一个 fallback 内容。这使得异步组件的加载和错误处理变得更加简单和优雅。\n\n总结：Vue3 相比于 Vue2 引入了许多新特性和优化，包括组合式 API、更好的性能、更小的体积、更好的 TypeScript 支持、新的生命周期钩子和更改、更强大的响应式系统、Fragment 和 Teleport 组件以及 Suspense 组件。这些变化使得 Vue3 在性能、可扩展性和易用性方面有了很大提升。\n\n\n\n### 谈谈你对Vuex以及Pinia的理解，以及它们之间的区别\n\nVuex 和 Pinia 都是 Vue.js 的状态管理库，它们帮助我们在 Vue 应用中管理和维护共享状态。这两者有一定的相似性，但也存在一些关键的区别。\n\n1. Vuex：\n\nVuex 是 Vue 官方推荐的状态管理库，适用于 Vue2 和 Vue3。它提供了一种集中式存储来管理应用程序中所有组件的状态。Vuex 的核心概念包括：\n\n- State：存储应用程序的状态数据。\n- Getters：从 state 中派生出新的状态，类似于计算属性。\n- Mutations：用于更改 state 的同步方法。\n- Actions：用于执行异步操作（例如 API 调用）并触发 mutations。\n\nVuex 遵循严格的单向数据流，确保状态更改的可预测性。同时，Vuex 还提供了一些开发者工具，帮助我们在开发过程中跟踪和调试状态更改。\n\n2. Pinia：\n\nPinia 是一个轻量级的状态管理库，专为 Vue3 设计。它充分利用了 Vue3 的组合式 API 和响应式系统，使得状态管理更加简洁和灵活。Pinia 的核心概念包括：\n\n- Store：存储应用程序的状态数据和相关方法。\n- State：用于存储状态的响应式对象。\n- Actions：用于执行异步操作和更改 state。\n\nPinia 的使用方法与 Vuex 类似，但其 API 更简洁，易于学习和使用。此外，Pinia 同样支持开发者工具，方便我们跟踪和调试状态更改。\n\n3. 区别：\n\n- 适用范围：Vuex 适用于 Vue2 和 Vue3，而 Pinia 专为 Vue3 设计。\n- API 设计：Pinia 的 API 更简洁，易于学习和使用。它充分利用了 Vue3 的组合式 API 和响应式系统。\n- 状态更新：Vuex 通过 mutations 和 actions 分别处理同步和异步状态更新，而 Pinia 将这两者合并为 actions。\n- 体积：Pinia 是一个轻量级库，相比于 Vuex 有更小的体积。\n- 生命周期：Pinia store 支持更好的生命周期管理，如 onBeforeMount、onMounted 等。\n\n总结：Vuex 和 Pinia 都是 Vue 的状态管理库，用于管理和维护共享状态。它们之间的主要区别在于适用范围、API 设计、状态更新方式、体积和生命周期管理。对于 Vue3 项目，Pinia 可能是一个更轻量、更简洁的选择，但 Vuex 作为官方推荐的库，在稳定性和生态方面仍具有优势。\n\n\n\n### 谈谈你对vue2以及vue3中diff算法的理解\n\nVue 的 diff 算法是用于在虚拟 DOM（Virtual DOM）更新过程中比较新旧两个虚拟节点树的差异，从而仅对有差异的部分进行真实 DOM 的更新，以提高性能。Vue2 和 Vue3 中的 diff 算法都基于 Snabbdom 库，但在 Vue3 中，diff 算法进行了一些优化，使得性能更高。\n\n以下是对 Vue2 和 Vue3 中 diff 算法的理解：\n\n1. Vue2 diff 算法：\n\nVue2 的 diff 算法主要通过同级节点之间的比较来进行。在对比新旧虚拟节点时，它采用**双端比较**的策略。首先分别比较新旧虚拟节点树的头部和尾部节点，通过四种可能的情况进行节点的移动、删除和创建。具体步骤如下：\n\n- 如果新旧头部节点相同，将两个头部节点向后移动。\n- 如果新旧尾部节点相同，将两个尾部节点向前移动。\n- 如果旧头部节点和新尾部节点相同，将旧头部节点移动到尾部。\n- 如果旧尾部节点和新头部节点相同，将旧尾部节点移动到头部。\n\n如果以上四种情况都不满足，Vue2 会创建一个新的 key 到 index 的映射表，然后遍历新的子节点，查找旧节点中是否存在相同的 key。如果找到相同的 key，将旧节点移动到正确的位置。否则，创建一个新节点并插入到正确的位置。最后，删除旧节点中未匹配的节点。\n\n2. Vue3 diff 算法：\n\nVue3 的 diff 算法在 Vue2 的基础上进行了优化。Vue3 利用**了静态节点和动态节点**的概念，通过对静态节点进行跳过，减少了不必要的比较。此外，Vue3 对于静态节点和动态节点的处理也进行了优化。在处理动态节点时，Vue3 使用了一个名为 `lis`（Longest Increasing Subsequence，最长递增子序列）的算法，通过查找最长递增子序列，找到需要移动的最少节点数量，从而减少节点移动操作，提高性能。\n\n总结：Vue 的 diff 算法用于比较新旧虚拟节点树的差异，从而实现高效的 DOM 更新。Vue2 和 Vue3 的 diff 算法都基于 Snabbdom 库，采用双端比较策略。Vue3 在 Vue2 的基础上进行了优化，引入了静态节点和动态节点的概念，通过跳过静态节点的比较和使用 lis 算法减少节点移动操作，提高了性能。\n\n尽管 Vue3 的 diff 算法相较于 Vue2 进行了优化，但在实际应用中，性能提升的程度还取决于组件的结构和数据变化。以下是一些建议，可以帮助我们在使用 Vue 时充分利用 diff 算法的优势：\n\n1. 使用 key：为列表中的每个节点分配唯一的 key，可以帮助 diff 算法更快地找到相应的节点，从而提高性能。尽量避免使用不稳定的值（例如随机数或索引）作为 key。\n2. 避免不必要的节点更新：尽量避免在没有实际更改的情况下触发组件的重新渲染。可以使用计算属性、watchers 和 Vue 的性能优化功能（如 `shouldComponentUpdate` 和 `keep-alive`）来减少不必要的渲染。\n3. 合理划分组件：将大型组件拆分为更小的子组件，以便更好地控制组件的更新。当某个子组件的状态发生变化时，只需更新该子组件，而不会影响其他子组件。\n4. 优化动态节点：在 Vue3 中，利用静态节点和动态节点的概念，确保动态节点的数量和位置合理。这可以帮助减少 diff 算法的计算量，提高性能。\n\n通过了解 Vue2 和 Vue3 中的 diff 算法原理，并结合实际项目中的组件结构和数据变化情况，我们可以更好地利用 Vue 的性能优势，构建高效的前端应用。\n\n\n\n### 为什么虚拟DOM会提高性能？\n\n虚拟 DOM（Virtual DOM）是一种**在内存中表示真实 DOM 的数据结构**。它允许我们在内存中对 DOM 进行操作，而不是直接操作真实的 DOM。虚拟 DOM 的主要优势是性能提升，原因如下：\n\n1. 减少 DOM 操作次数：真实 DOM 的操作（如创建、更新、删除元素）通常比内存操作更耗时。虚拟 DOM 允许我们在内存中进行大量操作，然后一次性将这些操作应用到真实 DOM 上，减少了对真实 DOM 的操作次数。\n2. 最小化更新范围：虚拟 DOM 结合 diff 算法，可以找出新旧虚拟 DOM 之间的差异，从而仅对有差异的部分进行真实 DOM 的更新。这可以减少不必要的 DOM 操作，提高性能。\n3. 批量更新：当有多个更改需要应用到真实 DOM 时，虚拟 DOM 可以将这些更改合并为一次更新。这有助于避免因多次操作导致的布局抖动（Layout Thrashing）和重绘，从而提高性能。\n4. 更好的跨平台兼容性：虚拟 DOM 不仅可以表示 Web 页面中的 DOM，还可以表示其他平台的 UI（例如移动应用或桌面应用）。这意味着使用虚拟 DOM 的框架（如 Vue 或 React）可以更容易地实现跨平台应用程序，而不必为每个平台编写特定的代码。\n\n虚拟 DOM 的性能提升并非绝对，它主要适用于大型应用和频繁更新的场景。对于简单的应用或更新较少的情况，虚拟 DOM 可能带来一定的开销。然而，在许多情况下，虚拟 DOM 提供了一种有效的方法来减少真实 DOM 操作，从而提高应用程序的性能。\n\n\n\n### react生命周期有哪些？\n\nReact 的生命周期方法可分为三个主要阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。以下是 React 的类组件生命周期方法。需要注意的是，React 16.3 版本后引入了新的生命周期方法，废弃了一些旧的方法。\n\n1. 挂载阶段（Mounting）： 这个阶段涉及到组件在 DOM 中创建和插入的过程。\n\n- constructor：构造函数，用于初始化组件的状态（state）和绑定事件处理器。\n- static getDerivedStateFromProps：在组件实例创建后和渲染前调用。根据传入的 props 计算出新的状态，返回一个用于更新状态的对象。这是一个静态方法，不能在其中使用 `this`。\n- render：用于创建虚拟 DOM，并返回要渲染的 JSX 结构。这是一个纯函数，不应在其中执行任何副作用操作。\n- componentDidMount：在组件挂载到 DOM 后立即调用。常用于触发 AJAX 请求、DOM 操作、添加事件监听等副作用操作。\n\n2. 更新阶段（Updating）： 当组件的状态（state）或属性（props）发生变化时，组件将重新渲染。这个阶段涉及到组件的更新过程。\n\n- static getDerivedStateFromProps：与挂载阶段中的相同，当组件接收到新的属性时调用。\n- shouldComponentUpdate：在重新渲染之前调用，可以根据变化的状态和属性来决定是否需要重新渲染。返回一个布尔值，如果为 false，则阻止组件更新。\n- render：与挂载阶段中的相同，重新渲染组件。\n- getSnapshotBeforeUpdate：在 DOM 更新之前获取快照，用于在 componentDidUpdate 中比较新旧 DOM。返回一个值或 null，作为 componentDidUpdate 的第三个参数。\n- componentDidUpdate：在组件更新并重新渲染后调用。常用于触发 AJAX 请求、DOM 操作、更新事件监听等副作用操作。\n\n3. 卸载阶段（Unmounting）： 当组件从 DOM 中移除时，进入卸载阶段。\n\n- componentWillUnmount：在组件卸载前调用。用于清理组件产生的副作用，如取消 AJAX 请求、移除事件监听等。\n\n需要注意的是，React 16.8 引入了 Hooks，它允许在函数组件中使用状态和生命周期特性。使用 `useState`、`useEffect` 和其他 Hooks 可以在函数组件中实现类似的生命周期行为。\n\n\n\n### 谈谈你对受控组件和非受控组件的理解\n\n在React中，表单元素的类型可以被划分为受控组件和非受控组件。\n\n**受控组件：**\n\n受控组件是指表单元素（如`<input>`，`<textarea>`，`<select>`等）的值被React的state控制的组件。换句话说，对于一个受控组件，其输入的值总是由React的state驱动的。我们通过设置组件的状态，并在每次用户交互时（如输入文本，选择下拉选项等）更新这个状态，来控制这个组件的值。\n\n例如，以下是一个受控组件的例子：\n\n```jsx\nclass ControlledForm extends React.Component {\n  state = {\n    inputValue: \'\'\n  };\n\n  handleInputChange = (event) => {\n    this.setState({ inputValue: event.target.value });\n  };\n\n  render() {\n    return <input type=\"text\" value={this.state.inputValue} onChange={this.handleInputChange} />;\n  }\n}\n```\n\n受控组件通常有更好的灵活性，因为你可以直接控制输入的内容，例如进行格式化、验证等。\n\n**非受控组件：**\n\n非受控组件则不通过state来控制输入的值。相反，它们使用原生的DOM API来获取或修改表单元素的值。通常，我们使用React的`ref`来获取DOM元素，然后从该元素上读取或设置值。\n\n以下是一个非受控组件的例子：\n\n```jsx\nclass UncontrolledForm extends React.Component {\n  myInput = React.createRef();\n\n  handleSubmit = (event) => {\n    event.preventDefault();\n    console.log(this.myInput.current.value);\n  };\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input type=\"text\" ref={this.myInput} />\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}\n```\n\n非受控组件的优点是它们更简单，更接近传统的HTML形式，但它们通常不能提供受控组件那样的灵活性。你需要使用DOM API来获取或设置值，这可能使得代码更难理解和维护。\n\n在大多数情况下，推荐使用受控组件，因为它们使得应用的状态更可预测，并且更易于实现复杂的功能，如实时验证和输入限制。然而，在某些情况下，非受控组件可能更简单或更方便，例如当处理大量输入和动态输入时。\n\n\n\n### 讲讲react组件之间的通信\n\nReact 组件之间的通信主要依赖于属性（props）和上下文（context）。以下是 React 组件间通信的几种常见方式：\n\n1. 父组件向子组件传递数据（Props）： 父组件通过属性（props）将数据传递给子组件。子组件通过 `this.props`（类组件）或函数参数（函数组件）访问传递的数据。这是 React 中最常见的通信方式。\n\n   ```jsx\n   function ChildComponent(props) {\n     return <div>{props.message}</div>;\n   }\n   \n   class ParentComponent extends React.Component {\n     render() {\n       const message = \"Hello from parent!\";\n       return <ChildComponent message={message} />;\n     }\n   }\n   ```\n\n2. 子组件向父组件传递数据（回调函数）： 子组件不能直接修改父组件的状态。为了让子组件向父组件传递数据，父组件可以将一个回调函数作为属性传递给子组件。子组件调用该回调函数时，可以将数据作为参数传递，从而实现向父组件传递数据。\n\n   ```jsx\n   function ChildComponent(props) {\n     return (\n       <button onClick={() => props.handleMessage(\"Hello from child!\")}>\n         Send Message\n       </button>\n     );\n   }\n   \n   class ParentComponent extends React.Component {\n     handleMessage(message) {\n       console.log(message);\n     }\n   \n     render() {\n       return <ChildComponent handleMessage={this.handleMessage.bind(this)} />;\n     }\n   }\n   ```\n\n3. 兄弟组件间通信： 兄弟组件间的通信需要依赖于它们共同的父组件。父组件可以通过状态（state）和回调函数将兄弟组件间的数据传递。\n\n   ```jsx\n   class ParentComponent extends React.Component {\n     state = {\n       message: \"\",\n     };\n   \n     handleMessage(message) {\n       this.setState({ message });\n     }\n   \n     render() {\n       return (\n         <div>\n           <ChildComponent1 handleMessage={this.handleMessage.bind(this)} />\n           <ChildComponent2 message={this.state.message} />\n         </div>\n       );\n     }\n   }\n   ```\n\n4. 使用上下文（Context）： 当多层嵌套的组件需要通信时，逐层传递属性可能变得繁琐。这时可以使用 React 的上下文（Context）API。Context 提供了一种在组件树中共享数据的方式，而无需显式地传递属性。\n\n   ```jsx\n   const MessageContext = React.createContext();\n   \n   class ParentComponent extends React.Component {\n     state = {\n       message: \"Hello from context!\",\n     };\n   \n     render() {\n       return (\n         <MessageContext.Provider value={this.state.message}>\n           <ChildComponent />\n         </MessageContext.Provider>\n       );\n     }\n   }\n   \n   function ChildComponent() {\n     return (\n       <MessageContext.Consumer>\n         {(message) => <div>{message}</div>}\n       </MessageContext.Consumer>\n     );\n   }\n   ```\n\n5. 使用状态管理库（如 Redux）： 在大型应用程序中，组件之间的通信可能变得复杂。使用状态管理库（如 Redux）可以集中管理应用程序的状态，简化组件间的通信。组件可以通过连接到状态管理库（如 Redux）来访问和更新全局状态。\n\n   使用 Redux 管理状态可以让你更好地处理大型应用程序中的组件间通信和共享状态。在实际项目中，你可能还需要使用一些额外的工具和技术，例如 Redux Toolkit、Redux Thunk 或 Redux Saga。\n\n\n\n### 谈谈你对纯函数的理解\n\n在React中，纯函数指的是给定相同的输入，始终返回相同的输出，而且没有副作用的函数。它们不会改变其输入，也不会影响到系统的任何其他部分，例如修改全局变量、修改传入的对象等。\n\n在React中，纯函数特别重要，因为当父组件的状态或属性改变时，React会重新渲染整个组件树。如果组件内部存在副作用，那么每次渲染时都会重新触发这些副作用，导致性能下降。而纯函数则不会有这个问题，它只会在必要的情况下被调用，从而优化了应用程序的性能。\n\n\n\n### 为什么useState不推荐放在if判断里面\n\n因为React依赖于hook调用的顺序和频率始终保持不变，以正确地跟踪和关联状态和副作用。\n\n当在组件渲染过程中调用useState，React会保留这个状态的值，直到下一次渲染。React保持一个内部的\"记忆\"，通过这个记忆，它知道在每次渲染时，状态值应该对应哪个useState调用。如果在if语句中调用useState，那么hook的调用可能会在不同的渲染中跳过或者重复，导致React无法正确地追踪状态值。\n\n为了遵循 Hooks 的使用规则，确保在函数式组件的顶层调用 `useState`。如果需要根据条件判断来决定是否使用状态，可以考虑将组件拆分成多个子组件，并在相应的子组件中使用 `useState`。这样可以保持 Hooks 的调用顺序一致，同时满足组件的逻辑需求。\n\n\n\n### 谈谈你对函数式组件和类组件的理解\n\n在React中，有两种主要的组件类型：函数式组件（Functional Component）和类组件（Class Component）。下面分别介绍它们的特点和区别。\n\n函数式组件：\n\n1. 通过定义一个纯JavaScript函数来创建的，接收props作为参数并返回React元素。\n2. 在React 16.8之前，函数式组件仅支持接收props，不支持state和生命周期方法。\n3. 自React 16.8引入Hooks后，函数式组件可以使用`useState`和`useEffect`等Hooks来实现状态管理和生命周期方法的功能。\n4. 函数式组件通常更简洁，易于阅读和测试。\n5. 在性能方面，由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。\n\n类组件：\n\n1. 是通过定义一个继承自`React.Component`的JavaScript类来创建的，该类包含一个`render`方法，接收props和state作为输入，并返回React元素。\n2. 支持state和生命周期方法，如`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`等。\n3. 需要通过`this`关键字来访问props和state。\n4. 类组件通常相对复杂，可能难以理解和测试。\n5. 在性能方面，由于有生命周期方法和实例化过程，类组件在某些情况下可能比函数式组件稍慢。\n\n两者之间的主要区别：\n\n1. 定义方式：函数式组件是纯函数，而类组件是继承自`React.Component`的类。\n2. 状态管理：在React 16.8之前，只有类组件可以使用state。自React 16.8引入Hooks后，函数式组件也可以使用`useState`来管理状态。\n3. 生命周期方法：在React 16.8之前，只有类组件支持生命周期方法。自React 16.8引入Hooks后，函数式组件可以使用`useEffect`等Hooks来实现生命周期方法的功能。\n4. 语法和结构：函数式组件通常更简洁，而类组件可能相对复杂。\n5. 性能：由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。\n\n总的来说，随着React Hooks的引入，函数式组件的功能已经基本与类组件相当。在实际开发中，建议优先使用函数式组件，以保持代码简洁和易于维护。当然，在一些特定场景下，例如需要使用到生命周期方法或者需要访问组件实例（如使用refs）时，类组件仍然具有一定的优势。\n\n\n\n### 在React中元素和组件有什么区别？\n\nReact中的元素和组件是两个非常核心的概念，理解它们的区别对于理解React非常重要。以下是我对这两者的理解：\n\n1. **React元素**：React元素是描述了你在屏幕上想看到的内容的普通对象。元素包含了组件应该渲染什么的信息，你可以将它们看作是DOM节点或者组件的“快照”。React元素是不可变的，一旦创建，你就不能改变它的子元素或属性。一个元素就像一帧电影——它代表了某一特定的时间点的UI。\n\n2. **React组件**：组件则可以视为函数或类，它们接受输入（即\"props\"），并返回React元素树，描述屏幕上应该显示什么。组件使你可以将UI拆分成独立的、可重用的部分，你可以独立地考虑每个部分。组件可以是React内置的组件，如`<div />`，也可以是自定义的组件，如`<MyComponent />`。\n\n简单来说，元素是你在代码中看到的，它描述了你想在屏幕上看到什么。而组件则是函数或者类，它决定了屏幕上应该展示什么。组件可以接受参数（props）并返回React元素，也可以包含自己的状态。因此，你可以说组件是动态的——它们描述了如何将输入（props和状态）转换为UI输出。\n\n\n\n### 谈谈你对React合成事件的理解\n\nReact 的合成事件系统（Synthetic Event）是 React 对原生浏览器事件进行的一层封装，主要是为了保证在所有浏览器中事件的行为是一致的，解决了浏览器之间对事件处理的差异问题。\n\n以下是我对React合成事件的一些理解：\n\n1. **跨浏览器的一致性**：不同的浏览器可能有不同的事件模型，对同一事件可能有不同的行为。React合成事件为所有的事件提供了一套统一的接口，保证了在所有浏览器中事件行为的一致性。例如，所有的React事件处理函数都会接收到一个合成事件对象，你可以通过这个对象的`event.preventDefault()`和`event.stopPropagation()`等方法来控制事件的行为。\n\n2. **事件委派**：React 使用事件委派来提高性能。在 React 中，不是直接把事件处理函数绑定到真实的节点上，而是所有的事件都被绑定到文档的根节点上。当事件发生并冒泡到根节点时，React 会根据事件的信息找到对应的组件并执行相应的事件处理函数。\n\n3. **池化**：React为了提高性能，会复用合成事件对象。事件回调被调用后，所有的事件属性都会被清空并放入事件池中。这就意味着你无法异步访问事件对象。如果你需要异步访问事件对象，你必须调用`event.persist()`来从池中移除合成事件对象，这样React就不会清空这个对象的属性。\n\n4. **合成事件和原生事件的交互**：虽然React事件被封装在合成事件中，但你仍然可以通过`event.nativeEvent`访问到浏览器的原生事件。\n\n5. **完全的事件支持**：React合成事件提供了对所有常见的DOM事件的支持，包括鼠标、键盘、剪贴板、触摸等事件。\n\n总的来说，React的合成事件系统提供了一种处理浏览器事件的高效、一致且跨浏览器的方式，它是React中一项非常重要的特性。\n\n\n\n### 请解释一下React Fiber是什么，以及它的主要作用和优势\n\nReact Fiber 是 React 16 中新的协调引擎或者说是重新实现的堆栈，它主要**解决在大型应用中由于大量的更新导致的性能问题**。Fiber 的目标是增强React在动画、布局和手势等领域的适应性，以及在不牺牲应用响应能力的前提下，使其具有更好的可扩展性。\n\n主要的改进和优势包括：\n\n1. **增量渲染（Incremental Rendering）：** 这是Fiber最大的改进。之前React的 reconciler（协调器） 是同步的，这意味着一旦开始就必须完成整个渲染树。相比之下，Fiber引入了增量渲染，它**将工作分割成多个小任务并将其在浏览器主线程空闲时进行**。这就意味着React不会阻塞主线程太长时间，保持应用更流畅。\n2. **能够暂停、终止、重用或者重启渲染工作：** 这是通过引入了一个新的数据结构Fiber，来跟踪组件的状态以及描述工作过程的。\n3. **优先级处理：** Fiber 引入了任务优先级的概念。不同类型的更新可以有不同的优先级，使得一些高优先级的任务（例如动画和手势）能够打断低优先级的任务（如数据同步）的执行，这样可以保证用户界面的流畅性。\n4. **并发和错误边界处理：** Fiber的架构为React的并发模式和错误边界提供了基础。这使得在未来React可以在异步渲染和错误处理等方面有更好的发展。\n\n这就是React Fiber的基本概念和主要优势。然而，大多数开发者可能并不需要直接与Fiber接触，因为它是React内部的实现细节，React的公共API在引入Fiber后并没有显著改变。但是理解Fiber的工作原理，可以帮助我们理解React如何处理更新，以及如何提高性能。\n\n\n\n### 请描述一下React的Reconciliation（调和）和Diffing算法\n\nReact的调和（Reconciliation）和Diffing算法是React在更新UI时决定什么需要改变的核心技术。\n\n**调和（Reconciliation）**\n\n调和是React用来通过比较新旧两个虚拟DOM树，确定要进行哪些更新的过程。当组件的state或props发生变化时，React会创建一个新的虚拟DOM树，并将其与旧的虚拟DOM树进行比较。这就是调和过程。\n\n**Diffing算法**\n\nDiffing算法是调和过程的一部分，用于确定具体要对DOM做出哪些修改。React在两棵树间进行diffing时，首先比较两棵树的根节点。如果根节点的类型不同，React会销毁旧的树并构建一个全新的树。如果根节点的类型相同，React会递归地对子节点进行diffing。\n\nReact使用两个假设来优化这个过程：\n\n1. 不同类型的元素会产生不同类型的树。例如，`<a>`元素会产生与`<img>`元素不同的树。\n\n2. 开发者可以通过`key` prop来指示哪些子元素在不同的渲染下能保持稳定。\n\n**React Fiber**\n\n需要注意的是，从React 16（Fiber架构）开始，React的调和过程变得更加复杂。Fiber引入了能够分割渲染工作的新算法，使得React能够根据优先级在渲染过程中暂停和继续渲染工作，从而提高了大型应用的性能。\n\n以上就是关于React的调和（Reconciliation）和Diffing算法的基本概述，实际上这个过程包含的细节和优化要复杂得多。\n\n\n\n### 怎样在React应用中实现Server-Side Rendering(SSR)？\n\nServer-Side Rendering (SSR) 指的是将应用在服务器端渲染成HTML字符串，然后发送到客户端的技术。这样做的好处是首屏加载更快，对SEO更友好。\n\n在React中实现SSR主要通过以下步骤：\n\n1. 使用 `ReactDOMServer.renderToString()` 方法将React组件转换成HTML字符串。这个方法会渲染React元素到其初始HTML。React返回的HTML将在浏览器中加载，然后React将连接（hydrate）到这些标记，使其成为完全交互式的。\n\n    示例代码如下：\n    ```jsx\n    import { renderToString } from \'react-dom/server\';\n    const html = renderToString(<App />);\n    ```\n\n2. 将生成的HTML字符串插入服务器的模板中，然后发送给客户端。\n\n3. 客户端收到服务器返回的HTML并加载到浏览器中，同时也会加载React代码，React会在客户端“接管”（hydrate）应用。\n\n4. 为了避免客户端在接管应用时重新获取数据和重新渲染，我们需要在服务器端将数据序列化并嵌入到页面中，然后在客户端将数据反序列化并提供给React应用。\n\n实现SSR需要处理许多细节，包括路由、数据预加载、代码分割、CSS管理等。针对这些问题，有一些库（例如Next.js）提供了开箱即用的解决方案。\n\n\n\n### 请解释一下Higher Order Components(HOC)和Render Props的工作原理。\n\n高阶组件（HOC）是接收一个组件并返回一个新组件的函数。HOC在React中常用于代码复用，逻辑抽象和渲染劫持。HOC不会修改接收的组件，也不会使用继承来复制它的行为。相反，HOC通过组合来实现功能。它是纯函数，无副作用。\n\n例如，下面这个`withLoader`就是一个HOC，它显示一个加载中状态，直到WrappedComponent获取到所需数据：\n\n```jsx\nfunction withLoader(WrappedComponent) {\n    return class extends React.Component {\n        render() {\n            if (this.props.isLoading) {\n                return <div>Loading...</div>;\n            }\n            return <WrappedComponent {...this.props} />;\n        }\n    };\n}\n```\n\n**Render Props**\n\nRender Props是一个在React组件中用于共享代码的简单技术。更具体的说，一个Render Props是一个函数，这个函数返回一个React元素并由我们的组件执行。\n\n例如，下面这个`DataLoader`组件使用Render Props模式。它获取数据并使用一个函数作为子元素（children prop）来渲染结果：\n\n```jsx\nclass DataLoader extends React.Component {\n    state = { data: null };\n\n    componentDidMount() {\n        fetchData(this.props.url).then(data => this.setState({ data }));\n    }\n\n    render() {\n        return this.props.children(this.state.data);\n    }\n}\n```\n\n使用该组件的方式如下：\n\n```jsx\n<DataLoader url=\"/api/data\">\n    {data => (\n        <div>\n            {/* Render the data */}\n        </div>\n    )}\n</DataLoader>\n```\n\n这两种模式在许多情况下可以互换使用，但它们各有优点。HOC适合用于抽象和操作props和state，而Render Props更适合用于动态决定要渲染什么。\n\n\n\n### react和vue在列表渲染时都需要提供key，请问key有什么作用？\n\n在 React 和 Vue 中，当你使用列表渲染时，需要为每个列表项提供一个唯一的 key。key 的作用主要有两点：\n\n1. 提高性能：\n\n在列表渲染时，当列表中的元素发生变化（例如添加、删除或重新排序）时，React 和 Vue 都使用 diff 算法来比较新旧虚拟 DOM 树。通过为列表项分配唯一的 key，框架可以更快地识别和追踪每个元素的变化。这样，在列表更新时，只需重新渲染有所变化的元素，而不是整个列表，从而提高渲染性能。\n\n2. 保持组件状态：\n\n在 React 和 Vue 中，组件实例的状态（state）和列表项是相关联的。如果列表项没有分配唯一的 key，框架将很难正确追踪组件实例与列表项之间的关系。这可能导致组件状态在更新时出现错误或丢失。\n\n例如，如果你有一个包含输入框的列表，用户在输入框中输入了一些内容。当列表发生变化时，没有分配 key 的情况下，输入框的值可能会显示在错误的列表项中，或者完全丢失。\n\n因此，为列表项分配唯一的 key 可以确保列表更新时，框架能够正确地追踪和保持组件实例的状态。\n\n总之，在 React 和 Vue 中使用列表渲染时，为每个列表项提供一个唯一的 key 可以提高性能，并确保组件状态在更新过程中保持正确。通常，我们使用从后端获取的数据中的唯一标识（如 ID）作为 key，如果没有唯一标识，可以使用其他可靠且唯一的值。避免使用数组的索引作为 key，因为它可能会导致性能问题和状态错误。\n\n\n\n### 你如何在React应用中处理错误？什么是错误边界(Error Boundaries)？\n\n错误处理是任何应用程序必不可少的一部分，React 也不例外。在 React 中，错误处理的主要工具是错误边界(Error Boundaries)。\n\n**错误边界（Error Boundaries）** 是一种 React 组件，它可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。\n\n创建错误边界组件需要定义一个新的生命周期方法 `getDerivedStateFromError` 或 `componentDidCatch`。这两个生命周期方法用于捕获子组件树中的错误。\n\n这是一个简单的错误边界组件的例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n    state = { hasError: false };\n\n    static getDerivedStateFromError(error) {\n        // 更新 state，下一次渲染将会显示 fallback UI\n        return { hasError: true };\n    }\n\n    componentDidCatch(error, info) {\n        // 你同样可以将错误日志上报给服务器\n        logErrorToMyService(error, info);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            // 你可以渲染任何自定义的 fallback UI\n            return <h1>Something went wrong.</h1>;\n        }\n\n        return this.props.children;\n    }\n}\n```\n\n你可以在任何可能需要的地方使用它：\n\n```jsx\n<ErrorBoundary>\n    <MyWidget />\n</ErrorBoundary>\n```\n\n这样，如果 `MyWidget` 组件出错，`ErrorBoundary` 组件就会捕获到这个错误，并渲染备用 UI，而不是让整个应用崩溃。\n\n\n\n### 请解释下React的Context API的工作原理，以及它如何用于全局状态管理？\n\nReact的Context API是一个创建全局状态的方式，可以让数据在组件树中传递，而不需要手动地一层一层传递props。\n\n首先，我们使用`React.createContext`来创建一个Context对象：\n\n```jsx\nconst MyContext = React.createContext(defaultValue);\n```\n\n然后，我们可以通过Context的Provider组件将状态传递到组件树中：\n\n```jsx\n<MyContext.Provider value={/* 某个值 */}>\n```\n\n任何在`Provider`内部的组件都可以通过Context的Consumer组件来订阅这个状态，或者如果这个组件是函数组件，也可以使用`useContext` Hook：\n\n```jsx\n<MyContext.Consumer>\n  {value => /* 根据Context value渲染某些内容 */}\n</MyContext.Consumer>\n```\n\n或\n\n```jsx\nconst value = useContext(MyContext);\n```\n\n虽然Context API提供了管理全局状态的方法，但它并没有提供一种在应用状态发生变化时通知React重新渲染的方式。因此，通常我们会将Context与React组件的state或者其他状态管理库（如Redux，MobX等）结合使用，以便当状态改变时，可以通知React进行重新渲染。\n\n注意，虽然Context可以让我们很方便的进行全局状态管理，但并不意味着我们应该尽可能的使用它。因为使用Context会使得组件的重用变得困难，而且也会使得组件的测试变得复杂。因此，除非你需要在很多不同层级的组件间共享状态，否则应该优先使用组件的props和state。\n\n\n\n### 如何进行React性能优化？\n\nReact是一个非常强大的前端JavaScript库，用于构建用户界面。然而，随着应用规模的扩大，可能会遇到一些性能问题。下面是一些优化React性能的技术：\n\n1. **使用PureComponent或shouldComponentUpdate：** React.PureComponent通过对props和state的浅对比来实现shouldComponentUpdate()。这可以帮助你避免不必要的render，从而提高性能。\n\n2. **利用React.memo：** 对于函数式组件，你可以使用React.memo进行优化，这也是一种避免不必要render的方式。\n\n3. **避免使用匿名函数或bind：** 在render方法中使用箭头函数或者bind会创建一个新的函数实例，导致无效的重新渲染。\n\n4. **合理使用key：** 在动态渲染元素时，应为每一个元素设置唯一的key，这样可以帮助React识别哪些元素发生了变化。\n\n5. **懒加载：** 对于大型项目，可以采用代码分割和懒加载的方式，减少首次加载时的数据量。\n\n6. **使用虚拟化长列表：** 当你需要处理大量的数据并显示在列表中时，可以使用虚拟化（virtualization）。这可以有效减少页面元素的数量，提高性能。\n\n7. **使用Web Workers处理复杂计算：** Web Workers允许你在后台线程中运行JavaScript，从而不阻塞用户界面。\n\n8. **合理使用第三方库：** 一些大型的第三方库可能会影响React应用的性能，所以在选择时应充分考虑其性能和大小。\n\n9. **优化图片和媒体内容：** 确保你的图片和媒体内容已经过优化，以尽可能减少他们的文件大小。\n\n10. **使用React Profiler进行性能分析：** React DevTools提供了一个Profiler插件，可以帮助你找出应用中的性能瓶颈。\n\n以上就是一些React性能优化的方法，当然这只是一部分。你可能还需要根据具体的应用场景，结合多种方法进行优化。\n\n\n\n### 为什么多个 JSX 标签需要被一个父元素包裹？\n\nJSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你**不能在一个函数中返回多个对象**，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。\n\n\n\n### 请描述一下React中的Virtual DOM是如何工作的？\n\nReact使用一种名为\"Virtual DOM\"的技术来帮助提高应用程序的性能。Virtual DOM（虚拟DOM）实际上是一个或多个JS对象的树形结构，它表示了真实DOM的结构。当数据变化时，React使用虚拟DOM来优化和最小化真实DOM的更新。以下是虚拟DOM工作原理的简单描述：\n\n1. **创建虚拟DOM：** 当你编写React组件并使用JSX时，React会为每个组件和元素创建一个虚拟DOM节点。这些虚拟节点构成了一个虚拟DOM树。\n\n2. **更新虚拟DOM：** 当应用程序的状态变化时，React会创建一个新的虚拟DOM树。这个过程非常快，因为它发生在内存中，不涉及浏览器的布局、样式计算或绘制阶段。\n\n3. **差异化（Diffing）：** 接下来，React会比较新旧两个虚拟DOM树，找出需要更新的最小修改。这个过程称为\"差异化\"。\n\n4. **重新渲染：** 最后，React将这些变化应用到真实的DOM树上。React尽可能地减少DOM操作，这有助于保持应用程序的性能，因为真实的DOM操作通常比虚拟DOM操作要昂贵得多。\n\n这就是虚拟DOM的基本工作原理。其主要优点是，通过减少直接操作DOM的次数，避免了昂贵的DOM操作，从而提高了性能。它也使得React可以在非浏览器环境（如服务器端渲染或者React Native）中运行。\n\n\n\n### 为什么我们在构造函数中绑定`this`？\n\n在JavaScript中，`this`的上下文依赖于函数的调用方式。当我们在类的方法中使用`this`时，我们期望`this`引用的是类的实例。但是，由于事件处理程序等可能更改上下文，`this`可能不会按照我们预期的方式工作。\n\nReact类组件的方法不会自动绑定`this`到实例。这意味着，当我们将一个方法作为回调传递（例如作为一个事件处理函数）时，`this`不会指向当前组件的实例。如果在该方法中我们尝试访问`this.props`或`this.state`，会导致错误，因为`this`的上下文已经丢失。\n\n考虑下面的例子：\n\n```jsx\nclass ExampleComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { message: \'Hello, world!\' };\n    }\n\n    showMessage() {\n        alert(this.state.message);\n    }\n\n    render() {\n        return (\n            <button onClick={this.showMessage}>Click me</button>\n        );\n    }\n}\n```\n\n在这个例子中，当我们点击按钮时，`showMessage`方法会被调用，但`this`的上下文并不是`ExampleComponent`的实例，所以`this.state`是`undefined`，这将导致运行时错误。\n\n为了解决这个问题，我们需要在构造函数中绑定`this`到我们的方法上。这可以确保无论方法在哪里被调用，`this`都将始终引用组件实例：\n\n```jsx\nclass ExampleComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { message: \'Hello, world!\' };\n\n        // Bind \'this\' to our method\n        this.showMessage = this.showMessage.bind(this);\n    }\n\n    showMessage() {\n        alert(this.state.message);\n    }\n\n    render() {\n        return (\n            <button onClick={this.showMessage}>Click me</button>\n        );\n    }\n}\n```\n\n这样，无论`showMessage`方法在何处被调用，`this`都将正确地引用`ExampleComponent`实例，我们就可以在该方法中安全地访问`this.state`和`this.props`。\n\n此外，也可以使用箭头函数来自动绑定`this`，因为箭头函数不会创建自己的`this`上下文，而是继承它们被定义时的上下文。\n\n```jsx\nclass ExampleComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { message: \'Hello, world!\' };\n    }\n\n    showMessage = () => {\n        alert(this.state.message);\n    }\n\n    render() {\n        return (\n            <button onClick={this.showMessage}>Click me</button>\n        );\n    }\n}\n```\n\n但是，箭头函数可能会引入一些其它问题（例如优化问题），所以在构造函数中显式地绑定`this`仍然是推荐的方式。\n\n\n\n### 怎样在React中阻止组件重新渲染？\n\n在React中，如果希望阻止一个组件在某些情况下重新渲染，可以使用 `shouldComponentUpdate` 生命周期方法或者 `React.memo` 函数。\n\n1. **shouldComponentUpdate:** 该方法只在类组件中有效。该方法接收两个参数，即新的 props 和新的 state，它默认返回 `true`。如果返回 `false`，那么React将跳过这次的渲染及之后的整个更新过程。\n2. **React.memo:** 对于函数组件，我们没有 `shouldComponentUpdate` 这个生命周期方法。不过，我们可以使用 `React.memo` 来实现类似的效果。`React.memo` 是一个高阶组件，它与 `shouldComponentUpdate` 有相似的作用，它“记住”了你的组件并且只有当 props 发生变化时才会重新渲染。\n\n\n\n### 描述下React中不可变性的重要性\n\n在React中，不可变性（Immutability）是一种重要的编程技巧，它有助于提高应用程序的性能并简化程序的复杂性。以下是不可变性在React中的重要性：\n\n1. **性能优化：** 在React中，当组件的状态或属性更改时，组件会重新渲染。为了防止不必要的渲染，React提供了`shouldComponentUpdate`生命周期方法（或者在PureComponent和React.memo中的自动浅比较）。通过比较新旧状态或属性，我们可以决定组件是否需要重新渲染。如果我们使用不可变数据，那么这个比较过程就变得非常简单和快速，因为我们只需要进行身份比较（`===`），而不是深度比较。如果引用没有变，那么数据就没有变。\n\n2. **简化编程模型：** 不可变性使得复杂的特性，如撤销/重做，更容易实现。如果我们不直接修改数据，而是生成新的数据版本，那么我们可以保留旧的数据版本，以便稍后使用。\n\n3. **更容易跟踪变化：** 当我们使用不可变数据时，任何数据的变化都将导致新的对象的产生。这使得我们可以利用React Dev Tools或Redux Dev Tools等开发工具，更容易地追踪状态的变化。\n\n总的来说，不可变性在React中的重要性在于它可以帮助我们写出更清晰、更易维护的代码，并且提高应用程序的性能。因此，在React和使用React的库（如Redux）中，都强烈推荐使用不可变数据。\n\n\n\n### React的纯组件(PureComponent)是什么？在什么情况下你会使用它？\n\nReact.PureComponent 和 React.Component 非常类似，不同之处在于 React.PureComponent 实现了 `shouldComponentUpdate()` 方法，这个方法对 props 和 state 进行了浅对比。这意味着，如果你的组件的 props 或 state 变化了（即引用变化，不是内部属性变化），那么组件将会重新渲染；否则，它就不会重新渲染。\n\n使用 PureComponent 的主要情况包括：\n\n1. **组件的重新渲染依赖于 props 和 state：** 如果你的组件完全依赖于 props 和 state，而且你可以保证 props 和 state 的引用在需要重新渲染时才会改变，那么使用 PureComponent 可以帮助你避免不必要的渲染，从而提高性能。\n\n2. **组件的 props 和 state 结构较为简单：** PureComponent 通过浅对比来检查 props 和 state 是否变化。这意味着，如果你的 props 或 state 是嵌套的对象，那么即使对象的深层属性没有变，只要顶层对象的引用变了，PureComponent 也会触发重新渲染。因此，如果你的 props 和 state 结构较为简单，或者你能保证嵌套对象在需要重新渲染时引用才会改变，那么使用 PureComponent 可以帮助你提高性能。\n\n然而，也要注意 PureComponent 并不是万能的，它并不适合所有场景。在一些情况下，使用 PureComponent 反而可能带来性能问题。例如，如果你的 props 或 state 经常改变，那么 PureComponent 在每次渲染前都会进行浅对比，这可能会带来额外的性能开销。同时，由于 PureComponent 只做浅对比，如果 props 或 state 中包含复杂的嵌套数据结构，可能会导致误判，无法准确地识别出 props 或 state 是否真正变化。\n\n在使用 PureComponent 时，你需要了解它的工作原理，以及何时使用它才能真正提高应用的性能。\n\n\n\n### 解释React的同步和异步setState\n\nReact的`setState`方法在某些情况下是异步的，而在其他情况下是同步的。理解这一点很重要，因为它可以帮助我们理解和预测React的行为。\n\n**异步的setState:**\n\n在大多数情况下，`setState`的行为是异步的。当我们在React的事件处理程序（例如onClick、onSubmit等）中调用`setState`时，React会将更新排入队列，然后在稍后的时间以最有效的方式批量应用这些更新。这种方法可以增加应用的性能，因为它避免了不必要的重新渲染。\n\n**同步的setState:**\n\n然而，在某些特定情况下，`setState`的行为是同步的。如果我们在React的生命周期方法（如`componentDidMount`或`componentDidUpdate`）或者在`setTimeout`或`setInterval`的回调函数中调用`setState`，那么它就会立即触发组件的重新渲染。\n\n了解`setState`的这种行为对于编写预测性和可调试性的React代码非常重要。\n\n\n\n### 在React中使用Portals的场景是什么？\n\nReact Portals 提供了一种将子节点渲染到存在于父组件 DOM 层次结构之外的 DOM 节点的方式。\n\n以下是一些使用 Portals 的典型场景：\n\n1. **模态对话框（Modals）和弹出窗口（Popovers）：** 当你创建一个模态对话框或弹出窗口时，你可能希望它能覆盖整个页面，而不是仅仅覆盖父组件的范围。你也可能希望模态对话框或弹出窗口能够独立于其父组件的 Z-index。通过使用 Portals，你可以将模态对话框或弹出窗口渲染到 DOM 树的顶层，使其可以覆盖整个页面。\n\n2. **全局通知和提示：** 类似于模态对话框，你可能希望全局通知或提示能够显示在页面的顶层，并且不受任何父组件的影响。通过使用 Portals，你可以将这些元素渲染到任何你想要的位置。\n\n3. **避免某些 CSS 问题：** 在某些情况下，父组件的 CSS（例如，overflow 或 z-index）可能会影响或限制子组件的显示。在这种情况下，你可以使用 Portals 将子组件渲染到父组件的 DOM 结构之外，以避免这些 CSS 问题。\n\n总的来说，React Portals 是一种强大的工具，它可以帮助你在需要在 DOM 结构上“跳出”父组件边界的时候进行渲染。然而，使用 Portals 也需要注意一些问题，例如，你需要确保正确地管理和清理在 Portals 中渲染的元素，以避免内存泄漏等问题。\n\n\n\n### 在React中使用Redux和MobX的主要区别是什么？\n\nRedux和MobX都是用于管理React应用状态的流行库，但他们的方法和概念差异较大。\n\n**Redux**:\n\nRedux基于Flux架构，使用单向数据流，并且维护一个不可变的全局状态树。在Redux中，所有的状态改变都通过分发（dispatching）预定义的操作（actions）来触发，并由纯函数（reducer）处理。\n\nRedux的主要特点：\n\n- **单一的状态树**：所有的应用状态都存储在一个大的对象中。\n- **不可变状态**：状态不能直接修改，只能通过分发操作并处理reducer函数来改变。\n- **纯函数和可预测性**：reducer函数必须是纯函数，给定相同的输入，总是返回相同的输出。\n\n**MobX**:\n\n相比之下，MobX采用更加直观和灵活的方式管理状态。它通过**反应性系统自动跟踪状态改变**，并更新相关的组件。\n\nMobX的主要特点：\n\n- **可观察的状态**：你可以声明应用状态为可观察的（observable），并将React组件转化为观察者（observer）。\n- **自动的派生**：当状态改变时，MobX会自动更新依赖这些状态的函数、计算值和组件。\n- **直接修改状态**：你可以直接修改状态，而不需要分发操作或使用reducer函数。\n\n**Redux和MobX的选择**:\n\n选择使用Redux或MobX主要取决于你的团队和项目的需求。\n\n如果你想要一个严格的、可预测的数据流和状态管理，那么Redux可能是更好的选择。Redux的严格性使得它非常适合于大型的、复杂的项目，或者需要处理一致性问题的项目。\n\n相反，如果你需要更快的开发速度和更高的灵活性，或者你的项目并不需要处理复杂的状态管理问题，那么MobX可能是更好的选择。MobX的简洁和直观使得它更易于理解和使用，尤其是对于那些不熟悉Flux架构或者函数式编程的开发者。\n\n\n\n### 谈谈你对Flux的理解\n\nFlux是Facebook为其React视图库创建的应用架构模式，用于处理数据流动。\n\nFlux架构的核心是一个单向数据流，其中包含四个主要部分：Dispatcher、Stores、Views（React组件）和Actions。\n\n1. **Actions**：Actions是一个简单的JavaScript对象，它描述了应用中发生的事件，但不指定应用状态如何更新。Action对象可以由用户交互、网络响应等产生，然后被分发（dispatched）给Store。\n\n2. **Dispatcher**：Dispatcher是Flux应用中的中央枢纽。当Action被触发时，Dispatcher会将Action分发到所有注册在其上的Store。\n\n3. **Stores**：Stores负责存储应用的状态和逻辑。每个Store都维护一个特定领域内的状态，例如用户的登录状态或购物车的内容。当Store接收到Dispatcher分发来的Action时，会根据Action的类型更新其状态。Store状态的更新通常通过switch-case语句或者if-else逻辑来实现。\n\n4. **Views**：Views（通常是React组件）从Store中读取状态并显示。当Store的状态发生变化时，会通知Views，然后Views重新渲染。\n\n这四个部分构成了Flux的单向数据流：Actions被分发到Store，Store处理Action并更新状态，然后通知Views重新渲染。\n\nFlux架构的主要优点是其数据流动的明确性和可预测性。因为数据总是按照一个固定的方向流动，所以在调试和理解应用的行为时更容易追踪数据。这特别对于构建大型、复杂的前端应用非常有用。\n\n\n\n### vue和react框架之间有什么不同？\n\nVue 和 React 都是现代前端框架，分别由 Evan You 和 Facebook 团队开发。它们旨在帮助开发者构建高效、可维护的用户界面。尽管它们有许多相似之处，但在一些关键方面存在一些不同。以下是 Vue 和 React 之间的一些主要差异：\n\n1. 模板语法和 JSX：\n\nVue 使用模板语法，将 HTML、CSS 和 JavaScript 集成在一起。Vue 的模板是基于 HTML 的，这使得它们对于前端开发者来说非常熟悉。Vue 提供了一些特殊的属性和指令（如 v-for、v-if 等），以便于操作 DOM 和组件。\n\nReact 使用 JSX（JavaScript XML），它是一种 JavaScript 语法扩展，允许在 JavaScript 代码中编写类似 HTML 的结构。与 Vue 的模板语法不同，JSX 更接近于 JavaScript，需要熟悉 JavaScript 语法的开发者。\n\n2. 数据绑定：\n\nVue 提供了双向数据绑定，通过 v-model 指令可以轻松实现。这使得在表单元素和数据之间建立双向绑定变得非常简单。\n\nReact 默认使用单向数据流，父组件通过属性（props）将数据传递给子组件。实现双向数据绑定需要编写更多的代码，通常需要使用回调函数或状态管理库（如 Redux）。\n\n3. 组件通信：\n\nVue 为组件通信提供了内置的事件系统（通过 $emit 和 $on），以及 props。这使得在 Vue 应用中实现组件间通信相对简单。\n\nReact 使用 props 和回调函数进行组件间通信。虽然它没有内置的事件系统，但可以使用第三方库（如 Redux 或 MobX）来实现更复杂的通信。\n\n4. 生态系统：\n\nVue 拥有一个相对更小但紧密的生态系统。Vue 的官方库（如 Vuex、Vue Router 等）为开发者提供了许多功能。Vue 社区也积极维护了许多插件和库。\n\nReact 拥有一个庞大的生态系统，可以为开发者提供各种各样的解决方案。React 社区很大，拥有大量的库和插件，可以满足不同的需求。但是，这也意味着在选择最佳实践和工具时可能需要进行更多的研究。\n\n5. 学习曲线：\n\nVue 通常被认为具有较低的学习曲线，尤其是对于那些熟悉 HTML、CSS 和 JavaScript 的前端开发者。Vue 的文档易于理解，模板语法直观，使得初学者更容易上手。\n\nReact 的学习曲线可能会略高一些，因为 JSX 和函数式编程概念需要一些时间适应。然而，React 的文档也相当详细，并有大量的社区资源可供参考。\n\n6. 可扩展性：\n\nVue 为开发者提供了灵活的选项，可以根据项目的需求进行配置。Vue 提供了许多内置功能和官方库，有助于保持一致性和实现快速开发。\n\nReact 本身非常灵活，可以很好地与各种库和工具集成。这使得 React 更容易适应不同类型的项目。然而，这种灵活性也意味着开发者需要在选择最佳实践和工具时进行更多的研究。\n\n7. 性能：\n\nVue 和 React 都具有出色的性能。它们都使用虚拟 DOM 技术，通过高效地比较新旧虚拟 DOM 来实现最小化的真实 DOM 更新。尽管在大多数情况下性能差异不大，但根据应用程序的具体需求和实现方式，两者之间可能存在一些差异。\n\n8. 企业和社区支持：\n\nReact 由 Facebook 开发和维护，拥有大量的企业和社区支持。这使得 React 成为一个非常稳定和可靠的选择，特别是对于大型企业级应用程序。\n\nVue 是一个独立的开源项目，由 Evan You 和一个活跃的社区维护。Vue 在亚洲市场尤其受欢迎，但在全球范围内也越来越受到认可。虽然它可能没有 React 那样庞大的支持，但 Vue 仍然是一个非常可靠和稳定的框架。\n\n总结：\n\nVue 和 React 分别有各自的优势和特点。Vue 的模板语法和双向数据绑定使其易于上手和快速开发，而 React 提供了高度灵活的架构和庞大的生态系统。在选择框架时，需要根据项目需求、团队经验和个人偏好来决定使用哪一个。\n\n\n\n### vue的diff算法，遍历Vdom使用的是深度优先遍历还是广度优先遍历？\n\nVue 3 使用了虚拟 DOM (Vdom)，并采用深度优先遍历 (Depth-First Traversal) 来进行比较和更新。这种遍历方式沿着每个分支尽可能深地遍历节点树，然后回溯。\n\n当渲染一个新的视图时，Vue 3 会创建一颗新的虚拟 DOM 树并将其与旧的虚拟 DOM 树进行比较。这一比较过程通过深度优先遍历实现，从而找出两棵树之间的差异，然后将这些差异应用到实际的 DOM 树上，从而有效地更新视图。\n\n深度优先遍历可以更容易地检测具体子树的更改，这对于在更新过程中维护组件的状态和生命周期很重要。这也与 React 的 diff 算法相似，都是倾向于采用深度优先遍历。\n\n\n\n### MVC和MVVM框架的区别？\n\nMVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）都是软件架构设计模式，用于分离应用程序的关注点，以提高可维护性和可扩展性。尽管它们有相似之处，但它们的实现方式和组件之间的交互有所不同。\n\n1. MVC（Model-View-Controller）：\n\n- Model：代表应用程序的数据模型和业务逻辑。它负责处理数据存储和检索。\n- View：代表用户界面，展示数据给用户，并接收用户输入。\n- Controller：处理用户输入，将用户操作转换为 Model 更新，并通知 View 更新。\n\n在 MVC 架构中，View 和 Controller 之间存在较强的依赖关系。用户输入由 Controller 处理，Controller 更新 Model，然后 Model 通知 View 更新。这样的双向通信使得 View 和 Controller 的耦合度较高。\n\n1. MVVM（Model-View-ViewModel）：\n\n- Model：与 MVC 中的 Model 相同，代表应用程序的数据模型和业务逻辑。\n- View：代表用户界面，负责展示数据和接收用户输入。但在 MVVM 架构中，View 不直接与 Model 交互。\n- ViewModel：扮演 View 和 Model 之间的中介，负责将 Model 中的数据转换为 View 可以显示的数据，同时将 View 的用户输入转换为 Model 可以理解的操作。\n\nMVVM 架构的关键特点是数据绑定（Data Binding），它允许 View 和 ViewModel 之间自动同步数据。这样，当 Model 数据发生变化时，View 会自动更新；当用户在 View 中进行操作时，ViewModel 会自动更新 Model。这种自动同步减少了 View 和 ViewModel 之间的直接交互，降低了它们之间的耦合度。\n\n总结：MVC 和 MVVM 都是用于分离关注点的架构设计模式。MVC 通过 Controller 来处理用户输入并更新 Model 和 View，而 MVVM 利用 ViewModel 作为 Model 和 View 之间的中介，实现数据绑定。MVVM 架构相较于 MVC，降低了组件之间的耦合度，使得代码更易于维护和扩展。许多现代前端框架（如 Vue 和 React）采用了类似 MVVM 的设计模式。\n\n\n\n<hr />\n\n## 前端工程化\n\n### 对Webpack做过哪些优化？\n\nWebpack 是一个非常强大的模块打包器，它可以帮助开发者处理代码依赖、打包、压缩等任务。在使用 Webpack 的过程中，我们可以通过一些方法优化项目，提高性能和用户体验。以下是一些常见的 Webpack 优化方法：\n\n1. Tree shaking：通过此技术，Webpack 可以消除未使用的代码，从而减少最终包的大小。为了实现这一点，确保在 package.json 文件中设置 \"sideEffects\" 选项。\n2. 代码分割（Code Splitting）：将代码分割成不同的 chunks，从而实现按需加载和并行加载。这可以减少首次加载时间和浏览器解析时间。可以使用 SplitChunksPlugin 和动态 import() 实现代码分割。\n3. 懒加载（Lazy Loading）：懒加载是一种按需加载策略，只有在实际需要时才加载某些代码。这可以显著减少首屏加载时间。\n4. 使用缓存：通过设置 cache-loader、HardSourceWebpackPlugin 或其他缓存插件，可以利用缓存加快构建速度。\n5. 压缩代码：使用插件如 TerserPlugin（用于 JavaScript）和 MiniCssExtractPlugin（用于 CSS）对代码进行压缩，减少代码体积，提高加载速度。\n6. 使用 DLL：通过使用 DllPlugin 和 DllReferencePlugin，可以将第三方库与应用程序代码分离，从而减少构建时间。\n7. 配置 resolve.alias：通过配置 resolve.alias，可以缩短查找模块的路径，从而提高构建速度。\n8. 使用 Web Workers 或 Service Workers：通过将一些任务放在后台线程中处理，可以提高应用程序的性能。\n9. 提取 CSS：通过使用 MiniCssExtractPlugin，可以将 CSS 从 JS 中分离出来，提高加载性能。\n10. 使用 Loaders 和 Babel：通过配置不同的 loaders 和 Babel 插件，可以在构建过程中优化代码，例如转换 ES6 语法、移除 console.log 等。\n11. 配置性能提示：通过配置 performance.hints 和 performance.assetFilter，可以监控和优化构建产物的大小。\n12. 使用 Webpack Bundle Analyzer：通过这个插件，可以分析和可视化 Webpack 输出的文件，从而帮助发现潜在的优化点。\n\n这些是在使用 Webpack 时可以采取的一些优化方法。针对具体项目，可能还需要结合实际情况进行更多优化。\n\n\n\n### Wepback的生命周期有哪些？\n\nWebpack 的生命周期主要由以下几个阶段组成：\n\n1. 初始化（Initialization）：在这个阶段，Webpack 会读取配置文件（如：webpack.config.js）和命令行参数，然后创建一个新的 Compiler 实例。这个实例包含了整个构建过程中的配置、插件、Loaders 等相关信息。\n2. 解析（Resolution）：Webpack 根据入口文件（entry）开始逐层解析依赖关系。对于每个解析到的模块文件，Webpack 都会检查是否需要使用对应的 Loaders 进行转换和处理。此阶段的主要目的是创建一个依赖图（Dependency Graph），其中包含了项目中所有模块及其相互依赖关系。\n3. 编译（Compilation）：在这个阶段，Webpack 开始根据依赖图逐个编译模块。对于每个模块，Webpack 会首先执行预编译任务（如使用 Babel 转换 ES6 语法），然后调用相应的 Loaders 处理模块内容。编译完成后，Webpack 会生成一个中间表示（Intermediate Representation，简称 IR），这是一个包含所有模块及其处理结果的对象。\n4. 输出（Emit）：Webpack 将 IR 转换为最终的输出文件（如：bundle.js）。在这个阶段，Webpack 会执行优化任务（如代码压缩、文件名哈希化），并将处理后的文件写入磁盘。输出完成后，Webpack 会触发相应的钩子（如：onEmit、afterEmit），以便插件可以执行自定义操作。\n5. 完成（Done）：构建流程完成后，Webpack 会触发一系列完成钩子（如：onDone、afterDone），以便插件可以执行清理和统计任务。此时，Webpack 会输出构建结果，包括处理后的文件、错误、警告等信息。\n\n这些阶段概述了 Webpack 的生命周期。在这个过程中，Webpack 会调用许多内置的插件和钩子函数来处理文件和资源。开发者还可以通过自定义插件和钩子来扩展和控制 Webpack 的行为。\n\n\n\n### Webpack有哪些常见的Loader？\n\n1. babel-loader：用于将 ES6/ES7 语法转换为浏览器兼容的 ES5 语法。\n2. css-loader：解析 CSS 文件中的 `@import` 和 `url()`，将 CSS 转换为 JavaScript 模块。\n3. style-loader：将 CSS 作为样式标签插入到 HTML 文档中。\n4. less-loader：将 Less 代码转换为 CSS 代码。\n5. sass-loader：将 Sass/SCSS 代码转换为 CSS 代码。\n6. postcss-loader：使用 PostCSS 对 CSS 进行处理，如自动添加浏览器前缀、压缩 CSS 等。\n7. file-loader：处理文件引用，将文件复制到输出目录，并返回文件的 URL。\n8. url-loader：将文件以 base64 编码的形式内联到代码中，可以减少 HTTP 请求次数。\n9. image-webpack-loader：压缩和优化图像文件。\n10. ts-loader：将 TypeScript 转换为 JavaScript。\n\n\n\n### Webpack有哪些常见的Plugin？\n\n1. HtmlWebpackPlugin：生成一个 HTML 文件，并自动引入所有生成的脚本和样式。\n2. MiniCssExtractPlugin：将 CSS 提取为单独的文件，而不是将其内联到 JavaScript 中。\n3. CleanWebpackPlugin：在每次构建前清理输出目录。\n4. DefinePlugin：允许在编译时创建全局常量，用于在开发和生产环境中区分不同的行为。\n5. TerserPlugin：压缩和优化 JavaScript 代码。\n6. OptimizeCSSAssetsPlugin：压缩和优化 CSS 文件。\n7. HotModuleReplacementPlugin：实现模块热替换，用于开发环境。\n8. CopyWebpackPlugin：将静态资源复制到输出目录。\n9. SplitChunksPlugin：实现代码分割，提高加载性能。\n10. CompressionWebpackPlugin：使用 Gzip 或 Brotli 压缩生成的资源文件。\n\n\n\n### Webpack中Loader和Plugin的区别？\n\n1. Loader 用于转换和处理模块。它是一个函数，接收源文件作为输入，并输出处理后的结果。Loader 的作用是对源代码进行处理，例如编译、压缩、转换等。常见的 Loader 任务包括：将 Sass/SCSS 转换为 CSS、将 ES6 代码转换为浏览器兼容的代码等。\n2. Plugin 是用于扩展 Webpack 功能的插件。它可以在构建流程中的不同阶段执行不同的任务，如清理输出目录、生成 HTML 文件等。Plugin 的作用范围更广泛，它可以访问 Webpack 的整个编译过程，从而实现各种复杂的功能。\n\nLoader 主要负责对模块的转换和处理，而 Plugin 负责完成更广泛的任务，包括编译过程中的各种钩子和自定义功能。\n\n\n\n### Wepback5有哪些新特性？\n\n1. 持久缓存：Webpack 5 引入了文件系统缓存，可以在多次构建之间持久存储中间结果。这可以显著提高重复构建的速度。\n2. 模块联邦（Module Federation）：这是一个允许多个独立构建共享代码的新特性。模块联邦可以在不牺牲性能的情况下实现微前端架构。\n3. 更好的 Tree Shaking：Webpack 5 改进了 Tree Shaking，可以更有效地移除无用代码。\n4. 默认支持 Content Hash：现在默认为输出文件名添加内容哈希，以实现长期缓存优化。\n5. 更小的运行时代码：Webpack 5 的运行时代码更小，有助于减小最终生成的包的大小。\n6. 改进的代码分割策略：Webpack 5 对 SplitChunksPlugin 的默认配置进行了优化，以更好地支持公共代码的提取。\n7. 移除了一些过时的特性：Webpack 5 移除了一些不推荐使用的特性，如 Node.js 的 polyfill。\n\n\n\n### 谈谈你对Source map的理解，生产环境如何使用？\n\nSource Map 是一种映射文件，用于将压缩、转换后的代码映射回原始源代码。这可以帮助开发者在浏览器中调试压缩、转换后的代码。Source Map 文件通常具有 `.map` 扩展名，与生成的代码文件一起分发。浏览器可以解析这些 Source Map 文件，从而在调试时显示原始代码。\n\n在生产环境中，你可能希望隐藏源代码或者避免额外的 HTTP 请求。一种方法是将 Source Map 上传到错误跟踪服务（如 Sentry），这样只有当出现错误时，错误跟踪服务才会下载并使用 Source Map。另一种方法是将 Source Map 内联到生成的代码文件中，这样可以避免额外的 HTTP 请求。然而，这会增加生成的文件大小，可能会影响性能。\n\n\n\n### 谈谈你对热更新的理解\n\n热更新（Hot Module Replacement，简称 HMR）是一种用于提高开发效率的技术。在应用程序运行过程中，HMR 可以实时替换、添加或删除模块，而无需刷新整个页面。这样，开发者可以立即看到更改的效果，而不会丢失应用程序的状态。Webpack 的 HotModuleReplacementPlugin 插件可以实现 HMR 功能。\n\n\n\n### 谈谈你对Babel的理解，并说下它的原理\n\nBabel 是一个 JavaScript 编译器，用于将最新的 JavaScript 语法（如 ES6、ES7）转换为浏览器兼容的 ES5 语法。Babel 的主要功能是确保你编写的代码在所有浏览器中都能正常运行，不受浏览器对新特性支持程度的影响。\n\nBabel 的原理：\n\n1. 解析（Parsing）：Babel 首先将源代码解析为一个抽象语法树（Abstract Syntax Tree，简称 AST）。解析过程中，Babel 将源代码分解成词素（Tokens），然后根据语法规则将词素组合成 AST。AST 是一种树状结构，用于表示源代码的语法结构。\n2. 转换（Transforming）：在 AST 的基础上，Babel 使用插件（plugins）和预设（presets）进行转换。插件是用于实现具体语法转换或优化的功能模块，例如将箭头函数转换为普通函数。预设是一组插件的集合，用于处理一组相关的语法特性，如 ES2015+ 的新特性。\n3. 生成（Generating）：在转换阶段完成后，Babel 将修改后的 AST 转换回 JavaScript 代码。生成阶段可以保留原始代码中的格式和注释，或者使用压缩插件对代码进行优化。\n\nBabel 允许开发者使用最新的 JavaScript 语法和特性，同时确保代码在各种浏览器中兼容。通过对代码进行转换和优化，Babel 可以提高代码的可维护性和性能。\n\n\n\n### 谈谈你对Vite的理解\n\nVite（法语单词，意为“快速”的意思）是一种现代化的前端构建工具，由 Vue.js 作者尤雨溪（Evan You）创建。Vite 的目标是为现代浏览器提供一个更轻量级、快速的开发和构建工具。它主要解决了一些传统构建工具（如 Webpack）在开发过程中的瓶颈问题，从而提高了开发者的效率。\n\nVite 的主要特点和优势包括：\n\n1. 基于浏览器原生 ES modules：Vite 利用浏览器原生支持的 ES modules 功能，实现了按需加载和快速的开发服务器。这消除了开发环境中构建和热更新的瓶颈，从而大幅提高了开发速度。\n2. 快速冷启动：与 Webpack 等传统构建工具相比，Vite 具有更快的冷启动速度。这是因为 Vite 在开发环境下无需进行整体构建，而是直接为请求的模块提供服务。\n3. 轻量级：Vite 的核心功能非常轻量，使得它在下载、安装和运行时更加高效。\n4. 热模块替换（HMR）：Vite 支持 HMR，这使得开发者在开发过程中可以在不刷新页面的情况下看到更改的结果，从而提高开发效率。\n5. 构建性能优化：虽然 Vite 旨在提供快速的开发环境，但它也支持高效的生产环境构建。Vite 使用 Rollup 进行生产环境构建，可以实现 Tree Shaking、代码分割等优化功能。\n6. 插件系统：Vite 提供了一个简单易用的插件系统，可以方便地扩展和定制 Vite 的功能。许多社区插件可以满足不同需求，如 CSS 处理、图片优化等。\n7. 框架支持：Vite 不仅支持 Vue.js，还支持 React、Preact、Svelte 等其他流行的前端框架。\n8. 开箱即用的特性：Vite 集成了一些常用的开发工具和特性，如 CSS 预处理器支持（Sass、Less等）、TypeScript 支持等，无需额外配置即可使用。\n\n总之，Vite 是一种新型的前端构建工具，它提供了快速的开发环境、高效的构建性能和易用的插件系统。尤其对于开发现代前端应用程序，Vite 可以大大提高开发效率。\n\n\n\n### 谈谈你对Gulp的理解\n\nGulp 是一个流行的前端自动化构建工具，通过它可以自动执行各种重复性、繁琐的任务，从而提高开发效率。Gulp使用流（stream）来处理文件，这样可以减少磁盘 I/O，提高任务执行速度。\n\n以下是关于 Gulp 的一些主要理解：\n\n1. 简单易用：Gulp 的 API 非常简单直观，只需要几个主要的方法（如 src、dest、watch、task 和 series/parallel）就可以编写自动化任务。Gulpfile.js（Gulp 配置文件）通常是易于阅读和维护的。\n2. 插件生态：Gulp 拥有丰富的插件生态系统，可以通过安装和配置插件来实现各种任务，如编译 SASS、压缩 JavaScript、优化图片等。\n3. 基于流（Stream）：Gulp 的核心特点是使用 Node.js 流来处理文件，这使得 Gulp 可以在内存中处理文件，避免了不必要的磁盘读写。这种处理方式使得 Gulp 任务执行速度更快。\n4. 代码即配置：与基于配置文件的构建工具（如 Webpack、Grunt）不同，Gulp 使用代码来定义任务。这使得 Gulpfile.js 更加灵活和可定制，可以根据项目需求编写特定的任务。\n5. 自动化任务管理：Gulp 可以监视文件变化，当检测到变化时自动执行相关任务。这可以确保开发过程中，项目始终处于最新状态，提高开发效率。\n6. 并行和串行任务执行：Gulp 提供了 series() 和 parallel() 方法，可以方便地组合任务，实现串行或并行执行。这可以最大程度地利用多核 CPU 的性能，提高任务执行速度。\n\n尽管现在前端构建工具有很多选择，如 Webpack、Parcel 和 Vite 等，但 Gulp 仍然在一些特定场景下具有优势。例如，对于一些简单的前端项目，或者需要灵活、定制化的构建流程，Gulp 是一个很好的选择。\n\n\n\n### 谈谈Webpack、Vite和Gulp三者之间的区别\n\nWebpack、Vite 和 Gulp 是三种流行的前端构建工具，它们之间有一些显著的区别：\n\n1. Webpack：\n   - Webpack 是一个模块打包器，主要用于 JavaScript 应用程序的打包和优化。\n   - 它支持各种资源（如 JS、CSS、图片、字体等）的加载和处理。\n   - Webpack 支持代码分割、懒加载、Tree Shaking 等优化策略，有助于提高应用程序的性能。\n   - 通过插件系统，Webpack 可以进行高度定制，满足各种项目需求。\n   - 缺点是配置相对复杂，构建速度在某些情况下较慢。\n2. Vite：\n   - Vite 是一个基于 ES modules 的开发服务器和构建工具，由 Vue.js 作者尤雨溪创建。\n   - Vite 利用原生 ES 模块（ESM）特性，实现快速开发服务器和按需编译。\n   - Vite 支持 HMR（热模块替换），提高开发效率。\n   - Vite 使用 Rollup 进行生产环境构建，具有出色的 Tree Shaking 能力。\n   - Vite 配置相对简单，易于上手，但某些场景下可能没有 Webpack 那么灵活。\n3. Gulp：\n   - Gulp 是一个基于流（stream）的任务运行器，主要用于自动化处理前端资源。\n   - Gulp 通过编写任务，可以实现各种复杂的构建流程，如编译 SASS、压缩 JS 等。\n   - Gulp 的核心优势在于其流式处理，减少磁盘 I/O，提高任务执行速度。\n   - Gulp 使用代码定义任务，具有很好的灵活性，适用于简单项目或高度定制化的构建需求。\n   - 缺点是 Gulp 不支持模块打包，需要与其他工具（如 Webpack、Rollup）结合使用以实现完整的构建流程。\n\n总结：\n\nWebpack、Vite 和 Gulp 之间的主要区别在于它们的使用场景、核心功能和处理方式。Webpack 是一个功能丰富的模块打包器，适用于各种类型的项目。Vite 是一个轻量级、高性能的开发服务器和构建工具，尤其适用于现代框架项目。Gulp 是一个灵活的任务运行器，用于处理前端资源和自动化工作流。在实际项目中，开发者可以根据需求选择合适的工具，甚至将它们组合使用以实现最佳的构建流程。\n\n\n\n<hr />\n\n## 前端性能优化\n\n### 前端常见的性能优化有哪些？\n\n前端性能优化是为了提高用户体验和页面响应速度的一种手段。以下是一些常见的前端性能优化方法：\n\n1. 优化图片：对图片进行压缩、使用合适的格式（例如，WebP）和尺寸，以及利用图片懒加载技术。\n2. 使用CDN（内容分发网络）：将静态资源分发到全球各地的服务器，减少用户加载资源的延迟。\n3. 缓存策略：利用浏览器缓存策略，如Cache-Control和ETag，减少重复请求。\n4. 代码压缩与优化：通过压缩和移除不必要的代码，减小文件大小。同时优化代码逻辑，提高代码执行效率。\n5. 异步加载：使用异步加载技术（如，async和defer属性）减少阻塞渲染的脚本。\n6. 利用浏览器渲染优化：避免强制同步布局，减少重排和重绘。\n7. 使用CSS3硬件加速：利用GPU加速，提高动画和页面渲染性能。\n8. 优化CSS选择器：使用简洁、高效的CSS选择器，提高渲染速度。\n9. 代码分割与按需加载：通过代码分割和按需加载技术，降低首次页面加载时间。\n10. 使用Web Workers：利用Web Workers进行后台处理，避免阻塞主线程。\n11. 服务端渲染（SSR）与预渲染：利用服务端渲染和预渲染技术，加快首屏渲染速度。\n12. 优化字体加载：减少字体文件大小，使用字体加载策略避免阻塞渲染。\n13. 使用HTTP/2：使用HTTP/2协议，实现多路复用，降低网络延迟。\n14. 优化资源优先级：利用`<link rel=\"preload\">` 和 `<link rel=\"prefetch\">` 标签，优化资源加载顺序。\n15. 使用事件委托，利用冒泡机制处理事件。\n16. 使用防抖、节流处理频繁触发的事件。\n\n以上只是一部分常见的前端性能优化方法，实际应用时还需要根据项目具体需求和场景来选择合适的优化策略。\n\n\n\n### 讲下虚拟列表的原理\n\n虚拟列表（Virtual List）又称无限滚动列表或者长列表优化，是一种前端性能优化技术。其主要目的是在处理大量数据列表时，提高用户体验和页面性能。以下是虚拟列表的基本原理：\n\n1. 渲染可视区域的列表项：虚拟列表的核心思想是仅渲染可见部分的列表项。当用户滚动列表时，根据可视区域的大小，计算需要显示的列表项，然后只渲染这些列表项。\n2. 列表项的位置计算：虚拟列表需要计算每个列表项的位置信息，以便在滚动过程中正确地显示列表项。这通常通过索引和固定高度（或者预估高度）来实现。\n3. 复用列表项DOM元素：为了减少创建和销毁DOM元素的性能开销，虚拟列表通常会复用列表项的DOM元素。当一个列表项滚出可视区域时，它的DOM元素会被重新利用，用于显示新的列表项。\n4. 占位元素：虚拟列表通常会使用一个占位元素（如一个空的div）来模拟整个列表的高度。这样可以使滚动条保持正确的位置和大小，使用户能够像正常列表一样进行滚动操作。\n5. 事件监听与更新：虚拟列表需要监听滚动事件，以便在用户滚动时实时更新可视区域的列表项。此外，如果列表数据发生变化，虚拟列表还需要重新计算位置信息并更新可视区域的列表项。\n\n通过上述原理，虚拟列表能够显著减少大量列表项的渲染成本，从而提高页面的性能和用户体验。在实际应用中，根据项目的具体需求和场景，可能还需要对虚拟列表进行一定的定制和优化。\n\n\n\n### 讲讲常见的性能指标有哪些？它们分别对应的作用是什么？\n\nWeb前端性能指标是衡量一个网站或Web应用程序加载速度、交互性和用户体验的关键因素。以下是一些常见的Web前端性能指标及其解释：\n\n1. 首次绘制（FP，First Paint）：页面在用户设备上开始渲染的时间点。这个指标可以用来衡量页面加载速度的初步感知。\n\n2. 首次内容绘制（FCP，First Contentful Paint）：页面上的任何内容（如文字、图片等）首次渲染的时间点。这个指标可以用来衡量用户看到页面内容的速度。\n\n3. 首次有效绘制（FMP，First Meaningful Paint）：页面主要内容呈现给用户的时间点。这个指标可以用来衡量页面的视觉完整度。\n\n4. 首次输入延迟（FID，First Input Delay）：用户首次与页面交互（如点击按钮、输入等）所需时间。这个指标可以用来衡量页面的交互性。\n\n5. 速度指数（SI，Speed Index）：描述页面加载过程中的视觉体验的一个指标。速度指数越低，用户体验越好。\n\n6. 大致加载时间（TTFB，Time To First Byte）：从用户发出请求到接收到服务器响应的第一个字节所需的时间。这个指标可以用来衡量网络延迟和服务器处理速度。\n\n7. 页面完全加载时间（Load Time）：从用户发出请求到页面完全加载所需的时间。这个指标可以用来衡量页面加载速度的综合体验。\n\n8. 页面体积：页面的所有资源（HTML、CSS、JavaScript等）的总大小。页面体积越小，加载速度越快。\n\n9. 请求次数：加载页面所需的网络请求次数。请求次数越少，加载速度越快。\n\n10. 首次CPU空闲时间（First CPU Idle）：页面首次达到CPU空闲状态的时间点。这个指标可以用来衡量页面在何时可以响应用户输入。\n\n11. 最大潜在首次输入延迟（Max Potential FID）：一个预测性指标，衡量在页面首次可交互之前可能发生的最大输入延迟。\n\n12. 累计布局偏移（CLS，Cumulative Layout Shift）：页面在加载过程中元素位置变化的总和。这个指标可以用来衡量页面的视觉稳定性。\n\n\n\n<hr />\n\n## 前端监控\n\n### 前端如何做性能监控？\n\n前端性能监控是指收集、分析和报告前端性能数据的过程。在前端开发中，性能监控可以帮助我们了解用户在实际使用过程中的体验，发现和解决性能瓶颈。以下是一些前端性能监控的方法：\n\n1. 利用浏览器提供的性能API，例如Navigation Timing API、Resource Timing API、User Timing API等，收集页面加载、资源加载和自定义性能指标的数据。\n2. 使用PerformanceObserver API来监听性能数据的变化，实时收集性能指标。\n3. 监控页面的错误信息，包括JavaScript错误、资源加载失败等。可以使用window.onerror和window.addEventListener(\'error\')进行捕获。\n4. 监控用户的交互事件，如点击、滚动、输入等，以了解用户在使用过程中可能遇到的性能问题。\n5. 使用Long Tasks API来检测可能导致页面卡顿的长时间任务，例如运行时间较长的JavaScript代码。\n6. 利用Web Vitals库来监控核心性能指标，如Largest Contentful Paint（LCP）、First Input Delay（FID）和Cumulative Layout Shift（CLS）等。\n7. 将收集到的性能数据发送到服务器端进行存储和分析。可以使用XMLHttpRequest或Fetch API进行数据上报。\n8. 使用开源或商业的应用性能监控（APM）工具，如Google Analytics、Sentry、New Relic等，进行性能数据的收集、分析和可视化展示。\n9. 对收集到的性能数据进行定期分析，找出性能瓶颈，优化前端代码和架构，提高用户体验。\n\n性能监控是前端优化的重要环节，通过不断地监控、分析和优化，我们可以确保用户在使用过程中获得良好的体验。\n\n\n\n### 前端如何做错误监控？\n\n前端错误监控是指捕获、记录和上报用户在实际使用过程中遇到的错误。错误监控有助于开发者发现和修复潜在的问题，提高应用的稳定性。以下是前端错误监控的一些建议：\n\n1. 监控JavaScript运行时错误：可以使用`window.onerror` 或 `window.addEventListener(\'error\')`来捕获JavaScript运行时错误。\n\n   ```js\n   window.onerror = function(message, source, lineno, colno, error) {\n     // 处理错误信息\n   };\n   \n   window.addEventListener(\'error\', function(event) {\n     // 处理错误信息\n   });\n   ```\n\n2. 捕获Promise异常：使用`window.addEventListener(\'unhandledrejection\')`来捕获未处理的Promise异常。\n\n   ```js\n   window.addEventListener(\'unhandledrejection\', function(event) {\n     // 处理错误信息\n   });\n   ```\n\n3. 捕获资源加载错误：通过监听`error`事件，捕获例如图片、样式表、脚本等资源加载失败的错误。\n\n   ```js\n   document.addEventListener(\'error\', function(event) {\n     if (event.target.tagName === \'IMG\' || event.target.tagName === \'LINK\' || event.target.tagName === \'SCRIPT\') {\n       // 处理错误信息\n     }\n   }, true);\n   ```\n\n4. AJAX请求错误：当使用XMLHttpRequest或Fetch API进行AJAX请求时，可能会遇到网络错误或服务器错误。可以在请求的错误回调或catch方法中捕获：\n\n   ```js\n   fetch(\'https://example.com/data\').then(response => {\n     if (!response.ok) {\n       throw new Error(\'Network response was not ok\');\n     }\n     return response.json();\n   }).catch(error => {\n     // 处理错误信息\n   });\n   ```\n\n\n\n<hr />\n\n## 前端安全\n\n### 谈一谈你对XSS攻击理解\n\n跨站脚本攻击（XSS，Cross-site Scripting）是一种常见的网络安全漏洞，它允许攻击者将恶意代码注入到受害者访问的网站中。这种攻击通常通过JavaScript来实现，但也可能涉及到其他脚本语言。在XSS攻击中，攻击者的目标是利用用户对网站的信任，进而窃取用户的数据、破坏网站的功能或者进行其他恶意行为。\n\nXSS攻击可以分为三种类型：\n\n1. 存储型XSS攻击（Stored XSS）：攻击者将恶意代码提交到目标网站的数据库中，当其他用户访问受影响的页面时，恶意代码将被加载并执行。这种类型的XSS攻击是最危险的，因为攻击者可以长期控制受害者的浏览器。\n2. 反射型XSS攻击（Reflected XSS）：攻击者通过创建一个包含恶意代码的URL，诱使受害者点击这个链接。当受害者访问这个URL时，恶意代码会在其浏览器中执行。这种类型的XSS攻击需要用户的互动，因此相对存储型XSS攻击来说，风险较低。\n3. DOM型XSS攻击（DOM-based XSS）：这种类型的XSS攻击是通过操作网页的Document Object Model（DOM）来实现的。攻击者会寻找可以用来插入恶意代码的DOM节点，当用户访问受影响的页面时，恶意代码将被执行。这种类型的攻击与反射型XSS相似，但更难以检测和防御。\n\n为了防范XSS攻击，网站开发者和运维人员可以采取以下措施：\n\n1. 对用户输入进行过滤和验证：确保所有的用户输入都经过适当的验证和过滤，以防止恶意代码的注入。\n2. 使用安全的编码方法：对用户输入的数据进行编码，将特殊字符转换为HTML实体，以防止代码在浏览器中被解析和执行。\n3. 设置Content Security Policy（CSP）：使用CSP可以限制浏览器加载和执行外部资源，降低XSS攻击的风险。\n4. 使用HttpOnly Cookies：将敏感信息（如会话ID）存储在HttpOnly Cookies中，以防止恶意脚本通过浏览器窃取这些信息。\n5. 保持软件和库的更新：确保使用的开发工具、库和框架是最新的，并修复已知的安全漏洞。\n\n\n\n### 谈一谈你对CSRF攻击理解\n\n跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种常见的网络安全漏洞，攻击者通过诱使受害者执行不知情的操作来利用受害者在网站上的身份。这种攻击是基于用户在其他网站上的登录状态和网站的信任机制。\n\n在CSRF攻击中，攻击者创建一个恶意网站或发送一个包含恶意代码的电子邮件。当受害者访问恶意网站或查看电子邮件时，浏览器会在后台向目标网站发送伪造的请求。由于受害者已经在目标网站上登录，因此这些请求将带有有效的凭据（如cookies），使攻击者能够以受害者的身份执行操作。\n\n为了防范CSRF攻击，网站开发者和运维人员可以采取以下措施：\n\n1. 使用CSRF令牌：在用户提交表单或执行敏感操作时，为每个请求生成一个随机的、唯一的CSRF令牌。将这个令牌与用户的会话关联，并在请求中包含该令牌。服务器端需要验证每个请求的令牌，确保它与用户会话的令牌匹配。这样可以防止攻击者伪造有效的请求。\n2. 验证请求来源：检查请求的来源，例如HTTP的Referer头或Origin头，确保请求来自于合法的域名。这有助于防止跨域的CSRF攻击。\n3. 使用SameSite Cookies属性：设置SameSite属性为“Strict”或“Lax”，可以防止浏览器在跨站请求时发送cookies。这可以降低CSRF攻击的风险，但可能不适用于所有场景。\n4. 要求用户重新验证身份：在执行敏感操作（如修改密码或执行交易）时，要求用户重新输入密码或进行二次验证。这可以降低CSRF攻击的成功率。\n5. 提高安全意识：教育用户识别和避免钓鱼网站、恶意邮件等，以降低CSRF攻击的成功率。\n\n\n\n### 谈谈你对SQL注入的理解\n\nSQL注入（SQL Injection）是一种网络安全漏洞，它允许攻击者通过在输入数据中插入恶意SQL代码，来控制或操纵应用程序与数据库之间的交互。这种攻击通常发生在应用程序未对用户输入进行充分验证和过滤的情况下。攻击者可以利用SQL注入漏洞来窃取、篡改或删除数据，甚至可能获得对整个数据库系统的控制权。\n\nSQL注入攻击的常见类型包括：\n\n1. 联合查询注入（Union-based SQL Injection）：攻击者通过构造包含UNION语句的恶意SQL查询，使其与原始查询合并，从而获取额外的数据。\n2. 基于错误的SQL注入（Error-based SQL Injection）：攻击者利用数据库在执行恶意查询时产生的错误信息，获取有关数据库结构和数据的信息。\n3. 盲注SQL注入（Blind SQL Injection）：攻击者通过逐步尝试不同的输入值，并根据应用程序的响应来推断数据库结构和数据。这种攻击方式较为缓慢，但在目标系统没有显示具体错误信息的情况下仍然有效。\n\n为了防止SQL注入攻击，开发者和运维人员可以采取以下措施：\n\n1. 使用预编译语句和参数化查询：预编译语句和参数化查询可以将SQL代码与数据分离，从而避免恶意代码的注入。这是防止SQL注入的最有效方法。\n2. 对用户输入进行验证和过滤：确保所有用户输入都经过适当的验证和过滤，以防止恶意代码的注入。使用白名单验证策略，仅允许已知安全的输入值。\n3. 最小权限原则：为应用程序的数据库账户分配最小必要权限，以减少潜在的损害。例如，如果应用程序仅需要读取数据，不应给予其写入和删除权限。\n4. 数据库错误信息处理：避免在应用程序中显示详细的数据库错误信息，以防攻击者利用这些信息进行攻击。可以使用自定义错误页面或者错误日志来记录错误信息，以便进行调试。\n5. 定期进行安全审计和更新：定期检查应用程序和数据库的安全设置，修复已知的漏洞，确保使用的软件和库是最新的。进行代码审查和安全测试，以发现潜在的安全漏洞。\n\n\n\n## 跨端开发\n\n### 微信小程序\n\n#### 简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?\n\n微信小程序中，这些 API 用于页面跳转和导航，它们之间的主要区别如下：\n\n1. wx.navigateTo(): 这个方法用于跳转到一个新页面，保留当前页面，新页面会被添加到页面栈中。用户可以点击返回按钮回到原页面。适用于多级页面的跳转。\n2. wx.redirectTo(): 此方法用于跳转到一个新页面，但不保留当前页面，即不允许用户返回。适用于无需返回上一页面的场景。\n3. wx.switchTab(): 这个方法用于切换到 tabBar 页面，并关闭其他非 tabBar 页面。tabBar 页面是小程序底部导航栏的页面，可以方便用户在不同页面之间切换。\n4. wx.navigateBack(): 此方法用于返回上一页面或多级页面。可以指定返回的层数，默认为1，即返回上一页面。这个方法是从页面栈中删除相应页面实现返回功能的。\n5. wx.reLaunch(): 这个方法用于关闭所有页面，打开到应用内的某个页面。适用于需要清空页面栈，重新启动小程序的场景。\n\n\n\n#### 谈谈微信小程序的架构以及为什么要用到双线程？\n\n微信小程序的架构主要分为两部分：逻辑层（App Service）和渲染层（Webview）。这两个部分运行在不同的线程中，形成了双线程架构。\n\n1. 逻辑层（App Service）： 逻辑层主要负责处理数据、业务逻辑和页面事件等。在这一层中，开发者编写 JavaScript 代码来实现小程序的功能。逻辑层运行在一个独立的线程中，通常称为 JSCore 线程。微信客户端提供了一些基础库，使得开发者可以调用相关 API 来实现小程序的各种功能。\n2. 渲染层（Webview）： 渲染层主要负责展示小程序的界面。在这一层中，开发者使用 WXML（类似于 HTML）和 WXSS（类似于 CSS）来定义页面结构和样式。每一个页面对应一个 Webview，每个 Webview 独立运行在各自的线程中。\n\n双线程架构的主要原因是为了实现逻辑层和渲染层的分离，提高小程序的性能。\n\n1. 性能优化：通过将业务逻辑和页面渲染分离到不同的线程中，可以有效避免渲染线程的阻塞，提高小程序的运行性能。当逻辑层进行计算或处理数据时，渲染层不会受到影响，能够保持流畅的用户体验。\n2. 安全性：双线程架构可以隔离 DOM 操作和 JavaScript 代码的执行，增强了小程序的安全性。由于小程序不允许直接操作 DOM，开发者只能通过官方提供的 API 来实现页面的交互和数据绑定。这样可以避免一些潜在的安全问题，例如跨站脚本攻击（XSS）。\n3. 简化开发：双线程架构使得开发者可以专注于业务逻辑和页面渲染，而无需关心它们之间的通信。微信小程序提供了丰富的 API 和组件，帮助开发者快速搭建高性能的应用。\n\n综上所述，双线程架构有助于提高微信小程序的性能、安全性和易用性。\n\n\n\n#### 微信小程序体积压缩的方案？\n\n为了提高微信小程序的加载速度和运行性能，开发者可以采取一些压缩和优化措施。以下是一些常见的微信小程序体积压缩方案：\n\n1. 代码压缩与混淆：对小程序的 JavaScript 代码进行压缩和混淆，可以有效地减小文件体积。使用诸如 UglifyJS、Terser 等工具可以实现这一目标。\n2. 压缩 WXML 和 WXSS：对 WXML（类似于 HTML）和 WXSS（类似于 CSS）文件进行压缩，移除不必要的空格、换行和注释，以减小文件大小。可以使用一些构建工具，如 Gulp、Webpack 等，结合相应的插件实现自动化压缩。\n3. 优化图片资源：对图片资源进行压缩和优化，以减少图片文件的大小。可以使用一些在线工具或构建工具插件，如 TinyPNG、ImageOptim、imagemin 等，对图片进行有损或无损压缩。此外，尽量使用小程序支持的 WebP 格式，以获得更好的压缩效果。\n4. 按需加载：对于不是首次渲染必须的资源，可以采用按需加载的策略，以减小初始加载的文件体积。例如，可以使用小程序的分包加载功能，将不同页面或功能的代码和资源拆分成多个子包，实现按需加载。\n5. 减少不必要的资源：审查小程序中的资源文件，移除不必要的图片、字体、图标等资源。同时，尽量避免使用大型的第三方库，只引入所需的模块。\n6. 使用云开发：利用微信提供的云开发功能，将一些资源放在云端，而不是打包到小程序中。例如，将图片、音频和视频等资源存储在云存储中，按需获取。\n7. 代码拆分：避免在同一个文件中编写过多的代码，可以将功能模块化，拆分成多个文件。这样不仅可以提高代码的可维护性，还能避免加载过多不必要的代码。\n8. 优化数据请求：减少数据请求的频率和数据量，尽量在后端完成数据处理和筛选。此外，可以使用缓存策略，减少不必要的数据请求。\n\n通过这些方案，可以有效地减小微信小程序的体积，提高加载速度和运行性能。在开发过程中，结合具体的项目需求，灵活采用这些优化措施。\n\n\n\n#### 微信小程序的生命周期函数\n\n微信小程序的生命周期函数是指在小程序运行过程中，框架自动执行的一些函数。这些函数主要用于监听页面或应用的生命周期事件，如页面的加载、显示、隐藏等。以下是微信小程序中的主要生命周期函数：\n\n1. 应用生命周期函数（App 对象）：\n   - onLaunch：当小程序启动时触发，全局只触发一次。可用于初始化全局数据、检查用户登录状态等。\n   - onShow：当小程序从后台进入前台显示时触发。可以在此函数中获取用户数据、更新页面数据等。\n   - onHide：当小程序从前台进入后台时触发。可以在此函数中暂停计时器、保存数据等。\n2. 页面生命周期函数（Page 对象）：\n   - onLoad：页面加载时触发。一个页面只会调用一次，可在此函数中获取页面参数、请求数据等。\n   - onShow：页面显示时触发。每次打开页面都会调用一次。可以在此函数中更新页面数据、开启计时器等。\n   - onReady：页面初次渲染完成时触发。一个页面只会调用一次。可以在此函数中获取已渲染的 DOM 节点等。\n   - onHide：页面隐藏时触发。当页面离开前台或被其他页面覆盖时触发。可以在此函数中暂停计时器、保存数据等。\n   - onUnload：页面卸载时触发。当页面被关闭时触发。可以在此函数中清理页面数据、监听器等。\n3. 组件生命周期函数（Component 对象）：\n   - created：组件实例刚刚被创建时触发。可以在此函数中初始化组件数据。\n   - attached：组件实例被插入页面节点树时触发。可以在此函数中进行数据绑定等操作。\n   - ready：组件布局完成后触发。可以在此函数中操作子组件、获取组件节点信息等。\n   - moved：组件实例被移动到另一个节点树时触发。可以在此函数中处理组件的移动。\n   - detached：组件实例被从页面节点树移除时触发。可以在此函数中进行清理工作，如移除事件监听器、销毁对象等。\n\n根据不同的场景，开发者可以在这些生命周期函数中执行相应的操作。注意，部分生命周期函数的执行顺序是固定的，例如页面的 onLoad 一定在 onShow 之前执行。在编写代码时，需要注意生命周期函数的执行顺序和相应的作用。\n\n\n\n#### 微信小程序的优劣势\n\n微信小程序作为一种轻量级的应用形式，具有一定的优势和劣势。下面是一些主要的优劣势：\n\n优势：\n\n1. 低成本：与传统的原生应用相比，小程序的开发成本较低，开发周期较短，可以快速实现产品上线。\n2. 无需安装：用户无需下载安装即可使用，节省了用户的时间和设备存储空间。\n3. 跨平台：微信小程序基于微信客户端，可以在 Android 和 iOS 平台上运行，实现了一定程度的跨平台兼容性。\n4. 更新迅速：小程序的更新不需要用户进行手动操作，每次打开都会获取最新版本，方便开发者快速迭代和修复问题。\n5. 流量入口多样：微信小程序可以通过微信内搜索、公众号、朋友圈、小程序码等多种渠道进行推广，便于吸引用户。\n6. 安全性：微信小程序不允许直接操作 DOM，限制了一些潜在的安全风险，如跨站脚本攻击（XSS）。\n7. 丰富的 API 和组件：微信提供了丰富的 API 和组件，方便开发者快速实现功能和界面，提高开发效率。\n\n劣势：\n\n1. 功能受限：相较于原生应用，小程序的功能和权限受到限制，某些复杂的功能可能无法实现。\n2. 性能：由于小程序运行在微信客户端内，性能可能不如原生应用。尤其是在低端设备上，性能问题可能更加明显。\n3. 用户粘性较低：用户使用小程序的门槛较低，但与此同时，用户流失的风险也相对较高。\n4. 依赖微信生态：微信小程序完全依赖于微信生态，受制于微信的政策和规则。一旦微信生态发生变化，小程序可能受到影响。\n5. 跨平台局限性：虽然小程序具有一定的跨平台特性，但在不同平台上可能仍存在兼容性和性能差异。同时，小程序无法在非微信环境下运行。\n\n根据具体的业务需求和场景，开发者可以权衡微信小程序的优劣势，选择是否采用小程序作为应用开发的方式。\n\n\n\n#### bindtap和catchtap的区别是什么?\n\nbindtap是普通的点击事件绑定，而catchtap是阻止事件冒泡的点击事件绑定。简单来说，如果有多个嵌套的组件都绑定了tap事件，使用catchtap可以只触发当前组件的tap事件，而不会触发其父级组件的tap事件。而使用bindtap则可能会触发其父级组件、祖先级组件的tap事件。\n\n\n\n<hr />\n\n## 数据结构与算法\n\n### 深度优先遍历和广度优先遍历的区别是什么？\n\n深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）都是用于遍历或搜索树或图的算法。这两种方法各有其优缺点：\n\n### 深度优先遍历 (DFS)：\n\n#### 优点：\n\n1. **空间效率**：在树的深度远小于广度时，DFS通常更加空间效率。因为它只需要存储一个路径的信息，而不是存储整个层的信息。\n2. **寻找深度解**：当问题需要找到深度解（例如求解迷宫的一条路径）时，DFS是一个很好的选择。\n3. **实现相对简单**：使用递归或堆栈，DFS相对容易实现。\n4. **可以找到连通分量**：对于图的分析，DFS可以被用来识别图的连通分量。\n\n#### 缺点：\n\n1. **可能不完整**：在无限或非常大的搜索空间中，DFS可能永远不会结束，或者可能会错过更优解。\n2. **可能找到非最优解**：不同于BFS，DFS可能找到一个解，但并不是最优解。\n3. **使用递归可能导致栈溢出**：如果搜索树非常深，递归实现可能会导致栈溢出。\n\n### 广度优先遍历 (BFS)：\n\n#### 优点：\n\n1. **找到最优解**：如果存在多个解，BFS会找到最少步骤的解，因为它首先检查所有的近邻节点。\n2. **完整性**：即使在无限或非常大的搜索空间中，BFS也可以保证找到解（如果存在）。\n3. **适用于广度大于深度的情况**：如果树或图的广度远小于深度，BFS可能更加高效。\n\n#### 缺点：\n\n1. **空间消耗**：因为BFS需要存储所有扩展节点的信息，所以空间消耗可能非常大，特别是当广度远大于深度时。\n2. **可能较慢找到深度解**：如果解在较深的层，BFS可能需要更多时间来找到它，因为它需要逐层搜索。\n\n### 总结\n\n选择DFS还是BFS主要取决于问题的具体要求和搜索空间的结构。如果你需要找到最优解并且广度相对较小，BFS可能是更好的选择。如果你只需要找到一个解，或者如果深度相对较小，DFS可能更加适合。在实际应用中，深度优先搜索和广度优先搜索的选择可能还取决于其他许多因素，如问题的特殊性质和可用资源。\n\n\n\n<hr />\n\n## 测试\n\n### 你觉得编写测试的好处是什么？\n\n编写测试的好处有很多，以下是其中的一些关键优势：\n\n1. 保证代码质量：编写测试可以帮助确保代码的质量，因为它会检查代码的正确性和功能性。通过发现潜在的错误和问题，我们可以更快地修复它们，确保代码的稳定性和可靠性。\n2. 防止回归：当对现有代码进行修改或扩展时，测试可以确保这些更改不会导致之前解决的问题再次出现。这称为“防止回归”，有助于维护代码的长期稳定性。\n3. 提高开发效率：测试可以帮助开发者更快地识别和解决问题，从而提高开发效率。自动化测试还可以在开发过程中减轻人工测试的负担，使开发者可以集中精力编写更多的功能代码。\n4. 易于重构和优化：测试可以让开发者在重构或优化代码时更有信心，因为他们知道任何潜在的问题都会被测试捕捉到。这使得代码更具可维护性，可以更轻松地进行优化和改进。\n5. 提升团队协作：编写测试有助于确保代码对其他团队成员更具可读性和可理解性。测试可以作为代码的文档，帮助其他开发者了解代码的预期行为和功能。这在团队合作中尤为重要，可以提高整个团队的生产力。\n6. 客户信任：具有全面测试的软件项目更容易赢得客户的信任，因为它们展示了开发团队对质量的关注和承诺。这有助于提高客户满意度并为未来的项目创造良好的声誉。\n7. 减少错误成本：及时发现和解决问题可以降低错误的长期成本。在项目后期发现问题的成本通常比在开发过程中早期发现和修复的成本要高得多。通过编写测试，我们可以在项目早期发现和解决问题，降低整体成本。\n\n总之，编写测试对于确保软件质量、提高开发效率、优化代码、增强团队协作和赢得客户信任等方面具有重要作用。\n\n\n\n### ATDD、TDD和BDD的区别？\n\nATDD（接受测试驱动开发）、TDD（测试驱动开发）和BDD（行为驱动开发）都是软件开发的实践方法，它们之间有一定的关联，但各有侧重点和特点。\n\n1. TDD（测试驱动开发）： TDD 是一种敏捷开发实践，它要求开发者在编写功能代码之前先编写测试用例。开发者首先编写一个失败的测试，然后编写实现功能的最少量代码以使测试通过，最后重构代码以提高质量。TDD 的核心原则是“红-绿-重构”（红色表示失败的测试，绿色表示通过的测试，重构表示改进代码质量）。TDD 的主要目的是通过编写简洁、可维护的代码来提高软件质量。\n2. ATDD（接受测试驱动开发）： ATDD 与 TDD 类似，但关注的是从用户的角度编写测试。开发者在实现功能之前，先与客户、产品经理和测试人员合作，共同确定功能的验收标准和测试用例。这些测试用例描述了应用程序应该如何满足用户需求和期望。然后，开发者使用 TDD 的方法来实现功能，确保满足这些验收标准。ATDD 的主要目的是确保软件满足用户需求和业务目标。\n3. BDD（行为驱动开发）： BDD 是一种介于 TDD 和 ATDD 之间的开发实践，它关注于使用通用的、自然语言描述的行为规范来编写测试。BDD 强调与非技术人员（如产品经理、业务分析师等）的沟通和协作，确保团队对软件行为有共同的理解。BDD 测试用例描述了给定特定情境下，软件应该如何响应。这些用例通常遵循“给定-当-那么”（Given-When-Then）的格式。BDD 的主要目的是提高团队间的沟通和协作，确保软件满足业务需求。\n\n总结一下，TDD 主要关注代码质量和功能的正确性，ATDD 关注软件满足用户需求和业务目标，而 BDD 关注团队间的沟通和协作，以及确保软件符合业务需求。在实际项目中，这三种方法可以相互结合使用，以达到更好的软件开发效果。\n\n\n\n<hr />\n\n## 运维\n\n### 什么是正向代理和反向代理？\n\n正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同类型的代理服务器。它们在网络架构中发挥着重要的作用，具体来说：\n\n1. 正向代理： 正向代理位于客户端与目标服务器之间，充当客户端与目标服务器之间的中间人。客户端发起请求时，请求首先到达正向代理服务器，然后代理服务器将请求转发到目标服务器。正向代理的主要作用包括：\n\n- 为内部网络客户端提供对外部资源的访问能力\n- 提供缓存功能，加速对常用资源的访问\n- 对客户端身份进行匿名化\n- 实现负载均衡\n- 实施安全策略和访问控制\n\n1. 反向代理： 反向代理位于客户端与目标服务器之间，充当目标服务器与客户端之间的中间人。客户端发起请求时，请求首先到达反向代理服务器，然后代理服务器将请求转发到后端服务器。反向代理的主要作用包括：\n\n- 提供负载均衡，将客户端请求分发到多个后端服务器\n- 提供SSL加密和解密功能，实现安全通信\n- 提供缓存功能，加速对常用资源的访问\n- 实现应用服务器的隔离，保护后端服务器免受恶意攻击\n- 集中处理和监控客户端请求，实现统一的访问控制和安全策略\n\n简言之，正向代理主要面向客户端，帮助客户端访问互联网上的资源；反向代理主要面向服务器，帮助服务器处理来自客户端的请求。\n\n\n\n### 为什么Nginx性能这么高？\n\nNginx 的高性能可以归因于其独特的设计和架构。以下是 Nginx 高性能的关键因素：\n\n1. 事件驱动、异步非阻塞架构：Nginx 使用了事件驱动的异步非阻塞 I/O 模型。这种模型允许 Nginx 在单个进程中处理大量并发连接，而无需为每个连接创建一个新的线程或进程。这大大降低了上下文切换和内存分配的开销，提高了性能。\n2. 轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。这使得 Nginx 在处理请求时能够更高效地利用系统资源。\n3. 高效的静态文件处理：Nginx 对静态文件的处理能力非常出色，它可以利用 sendfile 系统调用、TCP_CORK 和 TCP_NOPUSH 套接字选项等高级 I/O 功能，以高效地为静态资源提供服务。\n4. Keep-Alive 连接：Nginx 支持 HTTP Keep-Alive 连接，这意味着多个请求可以在同一连接上进行，减少了连接建立和关闭的开销。\n5. 内建的负载均衡和反向代理：Nginx 提供了功能强大的反向代理和负载均衡功能，可以在多个后端服务器之间分发请求，提高整体性能。\n6. 缓存功能：Nginx 提供了缓存功能，可以将后端服务器的响应进行缓存，加速对常用资源的访问，减轻后端服务器的负担。\n7. 可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块，定制 Nginx 以满足特定需求。\n8. 稳定性：Nginx 的稳定性非常高，即使在高负载情况下也能保持稳定运行。这使得 Nginx 能够在生产环境中提供可靠的服务。\n\n这些因素共同使得 Nginx 成为一个高性能的 Web 服务器和反向代理服务器。其优异的性能表现吸引了许多大型网站和互联网公司将 Nginx 作为首选的 Web 服务器和反向代理服务器。\n\n\n\n### Nginx的优缺点？Nginx应用场景？\n\nNginx 是一个高性能、轻量级的 Web 服务器和反向代理服务器。它广泛用于网站和网络应用的开发，其优缺点如下：\n\n优点：\n\n1. 高性能：Nginx 使用事件驱动的异步非阻塞架构，可以支持大量并发连接。相较于其他传统服务器，例如 Apache，Nginx 在并发场景下具有更低的资源消耗和更高的性能。\n2. 轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。\n3. 反向代理：Nginx 提供了功能强大的反向代理功能，可以实现负载均衡、缓存、SSL 加密解密等。\n4. 静态文件处理：Nginx 对静态文件的处理能力非常出色，能高效地为静态资源提供服务。\n5. 可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块。\n6. 稳定性高：Nginx 有着很高的稳定性，被广泛应用于生产环境。\n\n缺点：\n\n1. 动态语言支持较弱：与 Apache 相比，Nginx 对动态语言的支持不够完善，通常需要与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用。\n2. 模块更新和扩展：Nginx 模块需要在编译时集成，无法像 Apache 那样通过动态加载模块。当需要更新或添加模块时，通常需要重新编译 Nginx。\n3. 社区支持：虽然 Nginx 社区不断发展，但与 Apache 等老牌 Web 服务器相比，其社区支持相对较弱。\n\nNginx 应用场景：\n\n1. 静态资源服务器：Nginx 非常擅长处理静态文件，如图片、CSS、JavaScript 等。在很多场景下，Nginx 作为静态资源服务器可以减轻应用服务器的负担，提高响应速度。\n2. 反向代理和负载均衡：Nginx 提供了强大的反向代理和负载均衡功能，可以将客户端请求分发到多个后端服务器，提高服务的可用性和扩展性。\n3. SSL 终端：Nginx 支持 SSL/TLS 加密和解密，可作为 HTTPS 服务的终端，保证数据的安全传输。\n4. 缓存服务器：Nginx 可以作为缓存服务器，对后端服务器的响应进行缓存，加速对常用资源的访问，提高用户体验。\n5. Web 应用服务器：虽然 Nginx 对动态语言支持的不足，但它仍然可以与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用，共同组成 Web 应用的整体架构。例如，Nginx 可以作为反向代理服务器，将动态请求转发给 PHP-FPM 处理，同时负责静态文件的处理。\n\n总之，Nginx 的高性能、轻量级和稳定性使其在众多应用场景中得到广泛应用，特别是在处理静态文件、反向代理和负载均衡等方面表现出色。然而，对于动态语言支持和模块扩展方面，Nginx 仍然需要与其他应用服务器配合使用以获得更好的效果。\n\n\n\n### 如何用Nginx解决前端跨域问题？\n\n要使用 Nginx 解决前端跨域问题，您可以通过配置 Nginx 为您的 Web 服务添加 CORS（跨域资源共享）相关的响应头。以下是一个简单的示例，展示如何在 Nginx 配置文件中实现 CORS 配置：\n\n1. 打开 Nginx 配置文件，通常位于 `/etc/nginx/nginx.conf` 或 `/etc/nginx/sites-available/your_site_config`。\n\n2. 在配置文件中找到您想要添加 CORS 支持的 `location` 块。如果没有，您可以创建一个。\n\n3. 在 `location` 块中添加以下配置：\n\n   ```nginx\n   location / {\n       # ...原有配置...\n   \n       # 添加CORS相关的响应头\n       if ($request_method = \'OPTIONS\') {\n           add_header \'Access-Control-Allow-Origin\' \'*\';\n           add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\n           add_header \'Access-Control-Allow-Headers\' \'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization\';\n           add_header \'Access-Control-Max-Age\' 1728000;\n           add_header \'Content-Type\' \'text/plain; charset=utf-8\';\n           add_header \'Content-Length\' 0;\n           return 204;\n       }\n       if ($request_method = \'GET\') {\n           add_header \'Access-Control-Allow-Origin\' \'*\';\n           add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\n           add_header \'Access-Control-Allow-Headers\' \'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization\';\n           add_header \'Access-Control-Expose-Headers\' \'Content-Length,Content-Range\';\n       }\n   }\n   ```\n\n   在这个示例中，我们为 `OPTIONS` 请求和 `GET` 请求添加了 CORS 相关的响应头。您可以根据实际需求调整允许的请求方法和其他配置。\n\n4. 保存配置文件并重新加载 Nginx 以使更改生效：\n\n现在，Nginx 已经为您的 Web 服务添加了 CORS 支持，应该可以解决前端跨域问题。请注意，上面的示例中使用了通配符 `*` 作为 `Access-Control-Allow-Origin` 的值，这意味着允许所有域进行跨域访问。在实际生产环境中，您可能需要将其替换为特定的域名以提高安全性。\n\n\n\n### 谈谈你对Docker的理解\n\nDocker是一个开源的容器平台，它可以帮助开发者和运维人员轻松地打包、分发和运行应用。它基于容器化技术，让应用程序和其依赖环境作为一个整体打包在一起，实现了环境与应用程序的隔离。Docker的核心思想是将应用程序与底层基础设施分离，从而使开发和部署过程更加简单、高效和可靠。\n\nDocker的主要特点包括：\n\n1. 轻量级：Docker使用容器来运行应用，这些容器共享宿主机的操作系统内核，因此容器的开销小于虚拟机。它们启动快速，占用的资源更少。\n2. 易于打包和分发：Docker可以将应用程序及其依赖项一起打包成一个镜像，这使得应用程序可以在不同的环境中轻松移植和复制。Docker Hub等仓库提供了便利的镜像分发和管理。\n3. 隔离性：每个容器运行在自己的命名空间中，拥有独立的文件系统、网络和进程空间，这意味着容器之间相互隔离，可以在同一台机器上运行多个互不干扰的应用。\n4. 可扩展性：Docker支持容器的水平扩展和垂直扩展，可以根据需要快速添加或删除容器实例，以应对不同的负载需求。\n5. DevOps友好：Docker支持持续集成与持续部署（CI/CD），使得开发、测试和生产环境更加统一，有助于提高开发和运维团队的协作效率。\n6. 生态系统丰富：Docker拥有庞大的社区和丰富的插件生态系统，包括Docker Compose、Docker Swarm、Kubernetes等，这些工具可以帮助用户更好地管理和协调多个容器。\n\n总之，Docker是一个强大的容器化技术平台，它使应用程序的开发、部署和运维更加简单、高效和可靠。\n\n\n\n### Docker如何批量清理临时镜像文件？\n\n在Docker中，可以使用以下命令批量清理临时镜像文件：\n\n```\ndocker image prune -a\n```\n\n该命令将删除所有未被使用的镜像和标签。如果你只想删除未被使用的镜像，可以使用以下命令：\n\n```\ndocker image prune\n```\n\n\n\n### Docker本地的镜像文件都存放在哪里？\n\n在 Docker 中，本地的镜像文件存储在 Docker 的文件系统中，一般位于宿主机的`/var/lib/docker`目录下。在该目录下有多个子目录和文件，其中比较重要的有：\n\n- `containers/`：存储容器的文件系统和元数据。\n- `image/`：存储镜像文件和元数据。\n- `volumes/`：存储 Docker 卷的数据。\n- `networks/`：存储 Docker 网络的配置和状态。\n\n在`image/`目录下，有一个子目录`overlay2/`（在使用 overlay2 存储驱动的情况下），它包含了所有的镜像文件和元数据，每个镜像对应一个目录。例如，如果有一个名为`nginx:latest`的镜像，则它的文件存储路径为`/var/lib/docker/image/overlay2/<hash>/merged/`，其中`<hash>`是镜像的 SHA256 哈希值。\n\n请注意，这些路径可能因为 Docker 版本、存储驱动等因素而有所不同。如果想要确定本地 Docker 存储的路径，可以使用以下命令查看 Docker 的配置信息：\n\n```\ndocker info\n```\n\n其中会列出 Docker 存储的根目录和数据子目录。\n\n\n\n### Docker如何停止所有正在运行的容器？\n\n要停止所有正在运行的容器，可以使用以下命令：\n\n```\ndocker stop $(docker ps -q)\n```\n\n该命令使用`docker ps -q`命令列出所有正在运行的容器的 ID，然后将其传递给`docker stop`命令以停止这些容器。这样就可以一次性停止所有正在运行的容器。\n\n如果你希望删除所有停止的容器，可以使用以下命令：\n\n```\ndocker container prune\n```\n\n该命令将删除所有已经停止的容器。请注意，这些命令将永久删除容器，因此在使用之前请确保你确实想要删除这些容器。\n\n\n\n### 构建Docker镜像应该遵循哪些原则？\n\n构建Docker镜像时，应遵循一些原则以保证镜像的高质量、安全性和可维护性。以下是一些建议：\n\n1. 使用官方基础镜像：尽可能使用官方提供的基础镜像，因为它们经过了广泛测试且得到了良好的支持。\n2. 保持镜像轻量化：减少镜像大小，只包含运行应用程序所需的最小依赖。这将提高镜像的传输速度和部署时间。\n3. 使用多阶段构建：通过多阶段构建，可以在一个Dockerfile中使用多个构建阶段，以便更有效地处理构建过程。这有助于减少镜像大小和优化构建时间。\n4. 缩小镜像攻击面：确保镜像中只包含必要的组件，避免安装不必要的软件包，以降低安全风险。\n5. 使用.dockerignore文件：使用.dockerignore文件排除不需要的文件和目录，以减小镜像大小并加快构建速度。\n6. 标签和版本控制：为镜像使用清晰、有意义的标签，并进行版本控制。这有助于跟踪和管理不同版本的镜像。\n7. 缓存和层次化：充分利用Docker构建缓存，并将Dockerfile中的指令合理分层。这有助于加速构建过程并提高可维护性。\n8. 设置适当的用户权限：避免使用root用户运行容器，以降低潜在的安全风险。\n9. 指定资源限制：设置适当的资源限制，如CPU和内存，以防止容器消耗过多宿主机资源。\n10. 文档化：为Dockerfile和镜像提供清晰的文档，以便其他人了解如何使用和维护它们。\n\n遵循这些原则有助于创建高质量、安全且易于维护的Docker镜像。\n\n\n\n### 谈谈你对Docker-Compose的理解\n\nDocker Compose是一个用于定义和运行多容器Docker应用程序的工具。它允许用户使用YAML文件（通常命名为`docker-compose.yml`）来描述一个完整的应用程序环境，包括服务、网络和卷等配置。通过Docker Compose，开发者可以轻松地管理复杂的多容器应用，实现一键式启动、停止和重新部署。\n\n以下是Docker Compose的一些主要特点：\n\n1. 服务定义：使用YAML语法定义应用程序的各个服务。每个服务都基于一个Docker镜像，并且可以配置其端口映射、环境变量、依赖关系等。\n2. 网络管理：Docker Compose允许用户定义应用程序内部的网络，以便实现服务之间的隔离和通信。默认情况下，Docker Compose会创建一个网络，并将所有服务连接到该网络。\n3. 卷管理：Docker Compose支持定义和管理持久化存储卷，以便在容器之间共享数据。这对于数据库等需要持久化存储的应用非常有用。\n4. 依赖管理：Docker Compose可以管理服务之间的依赖关系，确保服务按照正确的顺序启动和关闭。这可以通过`depends_on`关键字来实现。\n5. 一键操作：使用`docker-compose up`命令，可以一次性启动定义在YAML文件中的所有服务。同样地，`docker-compose down`命令可以一次性停止所有服务。\n6. 开发和生产环境配置：Docker Compose支持使用多个YAML文件来覆盖和扩展配置，这使得开发者可以针对开发、测试和生产环境使用不同的配置。\n\nDocker Compose大大简化了多容器应用程序的管理，使开发者可以专注于编写应用程序代码，而无需关心底层的容器管理和编排。然而，需要注意的是，虽然Docker Compose适用于开发和测试环境，但在生产环境中，可能需要更强大的容器编排工具，如Kubernetes。\n\n\n\n### 谈谈你对K8S的理解\n\nKubernetes（简称K8s）是一个开源的容器编排平台，旨在自动化部署、扩展和管理容器化应用程序。它最初由Google开发，后来成为Cloud Native Computing Foundation（CNCF）的一部分。Kubernetes提供了一种声明式的方式来描述应用程序的部署和运行状态，使得复杂的容器化应用程序可以在多个主机上进行分布式部署和管理。\n\n以下是Kubernetes的一些主要特点：\n\n1. 高可用性：Kubernetes支持容器在集群的不同节点上进行分布式部署，以实现负载均衡和故障转移。这有助于提高应用程序的可用性和性能。\n2. 水平可扩展：Kubernetes可以根据负载需求自动扩展或缩减容器实例数量。这可以通过Deployment资源中的副本数（Replicas）进行配置。\n3. 自我修复：Kubernetes监控容器状态，当容器出现故障时，它可以自动重新启动容器、替换容器或重新调度容器到其他节点上，从而确保应用程序始终处于健康状态。\n4. 声明式配置：Kubernetes使用YAML或JSON文件描述应用程序的部署和运行状态，这些配置文件可以与源代码一起存储和管理，从而实现基础设施即代码（Infrastructure as Code）。\n5. 服务发现和负载均衡：Kubernetes提供了内置的服务发现和负载均衡机制，可以将流量自动分发到不同的容器实例上，以实现高可用性和性能。\n6. 存储管理：Kubernetes支持多种持久化存储解决方案，如NFS、iSCSI、GlusterFS等。它允许用户为容器动态配置和管理持久化存储卷。\n7. 密钥和配置管理：Kubernetes可以管理应用程序的敏感信息（如密码、密钥等）和配置文件，使得这些信息可以在不同的容器实例之间安全地共享。\n8. 强大的生态系统：Kubernetes拥有丰富的插件和扩展生态系统，例如Helm（用于包管理）、Prometheus（用于监控）等，这些工具可以帮助用户更好地管理和监控Kubernetes集群。\n\n总之，Kubernetes是一个功能强大的容器编排平台，它提供了一种高度自动化和可扩展的方式来管理容器化应用程序。尽管Kubernetes的学习曲线较陡峭，但对于大型、复杂的应用程序，它是一个非常有价值的工具。\n\n\n\n<hr />\n\n## 数据结构与算法\n\n### 排序\n\n#### 快速排序（Quick Sort）\n\n```typescript\nfunction quickSort(arr: number[], low: number, high: number): void {\n  if (low < high) {\n    // 获取分区索引\n    const partitionIndex = partition(arr, low, high);\n\n    // 递归调用\n    quickSort(arr, low, partitionIndex - 1);\n    quickSort(arr, partitionIndex + 1, high);\n  }\n}\n\nfunction partition(arr: number[], low: number, high: number): number {\n  // 选择基准值\n  const pivot = arr[high];\n\n  // 初始化分区索引\n  let i = low - 1;\n\n  // 将小于等于基准值的元素放到基准值的左侧\n  for (let j = low; j < high; j++) {\n    if (arr[j] <= pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // 交换基准值和分区索引+1位置的元素\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n\n  // 返回分区索引+1作为新的基准值索引\n  return i + 1;\n}\n\n// 测试用例\nconst arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nquickSort(arr, 0, arr.length - 1);\nconsole.log(arr);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 归并排序（Merge Sort）\n\n```typescript\nfunction mergeSort(arr: number[]): number[] {\n  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n\n  // 分割数组\n  const mid = Math.floor(len / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  // 递归调用并合并结果\n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left: number[], right: number[]): number[] {\n  const result: number[] = [];\n\n  // 合并两个已排序的数组\n  while (left.length && right.length) {\n    if (left[0] <= right[0]) {\n      result.push(left.shift()!);\n    } else {\n      result.push(right.shift()!);\n    }\n  }\n\n  // 将剩余的元素添加到结果数组\n  return result.concat(left, right);\n}\n\n// 测试用例\nconst arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nconsole.log(mergeSort(arr));  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 堆排序（Heap Sort）\n\n```typescript\nfunction heapSort(arr: number[]): void {\n  let n = arr.length;\n\n  // 构建大顶堆\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n\n  // 逐个提取元素并调整堆结构\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    n--;\n    heapify(arr, n, 0);\n  }\n}\n\nfunction heapify(arr: number[], n: number, i: number): void {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n\n  if (left < n && arr[left] > arr[largest]) {\n    largest = left;\n  }\n\n  if (right < n && arr[right] > arr[largest]) {\n    largest = right;\n  }\n\n  if (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\n// 测试用例\nconst arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nheapSort(arr);\nconsole.log(arr);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 冒泡排序（Bubble Sort）\n\n```typescript\nfunction bubbleSort(arr: number[]): void {\n  const n = arr.length;\n  let swapped;\n\n  for (let i = 0; i < n - 1; i++) {\n    swapped = false;\n\n    for (let j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        swapped = true;\n      }\n    }\n\n    // 如果没有发生交换，说明数组已经有序\n    if (!swapped) {\n      break;\n    }\n  }\n}\n\n// 测试用例\nconst arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nbubbleSort(arr);\nconsole.log(arr);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 选择排序（Selection Sort）\n\n```typescript\nfunction selectionSort(arr: number[]): void {\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    let minIndex = i;\n\n    // 寻找最小元素的索引\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n\n    // 交换最小元素与当前元素\n    if (minIndex !== i) {\n      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n  }\n}\n\n// 测试用例\nconst arr1 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nselectionSort(arr1);\nconsole.log(arr1);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 插入排序（Insertion Sort）\n\n```typescript\nfunction insertionSort(arr: number[]): void {\n  const n = arr.length;\n\n  for (let i = 1; i < n; i++) {\n    const key = arr[i];\n    let j = i - 1;\n\n    // 将大于 key 的元素向后移动\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n\n    // 插入 key 到正确位置\n    arr[j + 1] = key;\n  }\n}\n\n// 测试用例\nconst arr2 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\ninsertionSort(arr2);\nconsole.log(arr2);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 希尔排序（Shell Sort）\n\n```typescript\nfunction shellSort(arr: number[]): void {\n  const n = arr.length;\n\n  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < n; i++) {\n      const temp = arr[i];\n      let j;\n\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n        arr[j] = arr[j - gap];\n      }\n\n      arr[j] = temp;\n    }\n  }\n}\n\n// 测试用例\nconst arr3 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nshellSort(arr3);\nconsole.log(arr3);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 计数排序（Counting Sort）\n\n```typescript\nfunction countingSort(arr: number[]): number[] {\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const range = max - min + 1;\n  const count: number[] = new Array(range).fill(0);\n  const output: number[] = new Array(arr.length);\n\n  // 统计元素出现次数\n  arr.forEach((value) => {\n    count[value - min]++;\n  });\n\n  // 累加计数\n  for (let i = 1; i < range; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // 生成结果数组\n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n\n  return output;\n}\n\n// 测试用例\nconst arr4 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nconsole.log(countingSort(arr4));  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 基数排序（Radix Sort）\n\n```typescript\nfunction radixSort(arr: number[]): void {\n  const max = Math.max(...arr);\n  let exp = 1;\n\n  while (Math.floor(max / exp) > 0) {\n    countingSortForRadix(arr, exp);\n    exp *= 10;\n  }\n}\n\nfunction countingSortForRadix(arr: number[], exp: number): void {\n  const n = arr.length;\n  const output: number[] = new Array(n).fill(0);\n  const count: number[] = new Array(10).fill(0);\n\n  // 统计个位数字出现的次数\n  for (let i = 0; i < n; i++) {\n    count[Math.floor(arr[i] / exp) % 10]++;\n  }\n\n  // 累加计数\n  for (let i = 1; i < 10; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // 生成结果数组\n  for (let i = n - 1; i >= 0; i--) {\n    output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];\n    count[Math.floor(arr[i] / exp) % 10]--;\n  }\n\n  // 将结果复制回原数组\n  for (let i = 0; i < n; i++) {\n    arr[i] = output[i];\n  }\n}\n\n// 测试用例\nconst arr5 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nradixSort(arr5);\nconsole.log(arr5);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 桶排序（Bucket Sort）\n\n```typescript\nfunction bucketSort(arr: number[], bucketSize = 5): number[] {\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n  const buckets: number[][] = new Array(bucketCount).fill(0).map(() => []);\n\n  // 将元素分配到桶中\n  for (let i = 0; i < arr.length; i++) {\n    const index = Math.floor((arr[i] - min) / bucketSize);\n    buckets[index].push(arr[i]);\n  }\n\n  // 对每个桶进行排序\n  for (let i = 0; i < buckets.length; i++) {\n    buckets[i].sort((a, b) => a - b);\n  }\n\n  // 将桶中的元素合并到结果数组\n  return ([] as number[]).concat(...buckets);\n}\n\n// 测试用例\nconst arr6 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nconsole.log(bucketSort(arr6));  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 二叉树排序（Binary Tree Sort）\n\n二叉树排序是指利用二叉搜索树（Binary Search Tree，BST）的特性进行排序的算法。二叉搜索树是一种特殊的二叉树，对于树中的每个节点，其左子树中的所有节点值均小于该节点值，其右子树中的所有节点值均大于该节点值。通过中序遍历二叉搜索树，可以得到一个有序的序列。\n\n```typescript\n// 定义一个二叉搜索树节点类\nclass TreeNode {\n  value: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 定义一个二叉搜索树类，包含插入和中序遍历方法\nclass BinarySearchTree {\n  root: TreeNode | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value: number): void {\n    if (this.root === null) {\n      this.root = new TreeNode(value);\n    } else {\n      this._insertNode(this.root, value);\n    }\n  }\n\n  private _insertNode(node: TreeNode, value: number): void {\n    if (value < node.value) {\n      if (node.left === null) {\n        node.left = new TreeNode(value);\n      } else {\n        this._insertNode(node.left, value);\n      }\n    } else {\n      if (node.right === null) {\n        node.right = new TreeNode(value);\n      } else {\n        this._insertNode(node.right, value);\n      }\n    }\n  }\n\n  inOrderTraversal(): number[] {\n    const result: number[] = [];\n    this._inOrderTraversalNode(this.root, result);\n    return result;\n  }\n\n  private _inOrderTraversalNode(node: TreeNode | null, result: number[]): void {\n    if (node !== null) {\n      this._inOrderTraversalNode(node.left, result);\n      result.push(node.value);\n      this._inOrderTraversalNode(node.right, result);\n    }\n  }\n}\n\nfunction binaryTreeSort(arr: number[]): number[] {\n  const bst = new BinarySearchTree();\n\n  // 将数组中的值插入二叉搜索树\n  arr.forEach((value) => {\n    bst.insert(value);\n  });\n\n  // 中序遍历二叉搜索树，得到排序后的数组\n  return bst.inOrderTraversal();\n}\n\n// 测试用例\nconst arr8 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nconsole.log(binaryTreeSort(arr8));  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n\n```\n\n注意，二叉搜索树在极端情况下可能导致不平衡，这会影响排序性能。为了解决这个问题，可以使用平衡二叉搜索树（如 AVL 树或红黑树）进行排序。\n\n\n\n#### 鸽巢排序（Pigeonhole Sort）\n\n```typescript\nfunction pigeonholeSort(arr: number[]): number[] {\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const range = max - min + 1;\n  const pigeonholes: number[][] = new Array(range).fill(0).map(() => []);\n\n  // 将元素放入对应的鸽巢\n  for (const value of arr) {\n    pigeonholes[value - min].push(value);\n  }\n\n  // 从鸽巢中取出元素，拼接成排序后的数组\n  return ([] as number[]).concat(...pigeonholes);\n}\n\n// 测试用例\nconst arr7 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nconsole.log(pigeonholeSort(arr7));  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 侏儒排序（Gnome Sort）\n\n```typescript\nfunction gnomeSort(arr: number[]): void {\n  let i = 1;\n  let j = 2;\n\n  while (i < arr.length) {\n    if (arr[i - 1] <= arr[i]) {\n      i = j;\n      j++;\n    } else {\n      [arr[i - 1], arr[i]] = [arr[i], arr[i - 1]];\n      i -= 1;\n      if (i === 0) {\n        i = j;\n        j++;\n      }\n    }\n  }\n}\n\n// 测试用例\nconst arr9 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\ngnomeSort(arr9);\nconsole.log(arr9); // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n#### 猴子排序（Bogo Sort）\n\n```typescript\nfunction isSorted(arr: number[]): boolean {\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i - 1] > arr[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction shuffle(arr: number[]): void {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}\n\nfunction bogosort(arr: number[]): void {\n  while (!isSorted(arr)) {\n    shuffle(arr);\n  }\n}\n\n// 测试用例\nconst arr11 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\nbogosort(arr11);\nconsole.log(arr11); // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]\n```\n\n\n\n### 查找\n\n#### 二分查找（Binary Search）\n\n```typescript\nfunction binarySearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return mid;\n    }\n\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}\n\n// 测试用例\nconst sortedArr = [2, 3, 5, 6, 7, 9, 10, 11, 12, 14];\nconsole.log(binarySearch(sortedArr, 10)); // 输出：6\nconsole.log(binarySearch(sortedArr, 4));  // 输出：-1\n```\n\n\n\n#### 插值查找（Interpolation Search）\n\n```typescript\nfunction interpolationSearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right && target >= arr[left] && target <= arr[right]) {\n    if (left === right) {\n      return arr[left] === target ? left : -1;\n    }\n\n    const position = left + Math.floor(((target - arr[left]) * (right - left)) / (arr[right] - arr[left]));\n\n    if (arr[position] === target) {\n      return position;\n    }\n\n    if (arr[position] < target) {\n      left = position + 1;\n    } else {\n      right = position - 1;\n    }\n  }\n\n  return -1;\n}\n\n// 测试用例\nconst sortedArr3 = [2, 3, 5, 6, 7, 9, 10, 11, 12, 14];\nconsole.log(interpolationSearch(sortedArr3, 10)); // 输出：6\nconsole.log(interpolationSearch(sortedArr3, 4));  // 输出：-1\n```\n\n\n\n#### 斐波那契查找（Fibonacci Search）\n\n```typescript\nfunction fibonacciSearch(arr: number[], target: number): number {\n  const fib = [0, 1];\n  while (fib[fib.length - 1] < arr.length) {\n    fib.push(fib[fib.length - 1] + fib[fib.length - 2]);\n  }\n\n  let offset = -1;\n\n  while (fib[fib.length - 1] > 1) {\n    const index = Math.min(offset + fib[fib.length - 2], arr.length - 1);\n\n    if (target > arr[index]) {\n      fib.pop();\n      offset = index;\n    } else if (target < arr[index]) {\n      fib.pop();\n      fib.pop();\n    } else {\n      return index;\n    }\n  }\n\n  if (fib[fib.length - 1] && arr[offset + 1] === target) {\n    return offset + 1;\n  }\n\n  return -1;\n}\n\n// 测试用例\nconst sortedArr4 = [2, 3, 5, 6, 7, 9, 10, 11, 12, 14];\nconsole.log(fibonacciSearch(sortedArr4, 10)); // 输出：6\nconsole.log(fibonacciSearch(sortedArr4, 4));  // 输出：-1\n```\n\n\n\n#### 指数查找（Exponential Search）\n\n```typescript\nfunction exponentialSearch(arr: number[], target: number): number {\n  if (arr[0] === target) {\n    return 0;\n  }\n\n  let i = 1;\n  while (i < arr.length && arr[i] <= target) {\n    i *= 2;\n  }\n\n  return binarySearch(arr.slice(i / 2, Math.min(i, arr.length)), target);\n}\n\nfunction binarySearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return mid;\n    }\n\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}\n\n\n// 测试用例\nconst sortedArr5 = [2, 3, 5, 6, 7, 9, 10, 11, 12, 14];\nconsole.log(exponentialSearch(sortedArr5, 10)); // 输出：6\nconsole.log(exponentialSearch(sortedArr5, 4));  // 输出：-1\n```\n\n\n\n#### 哈希查找（Hashing）\n\n```typescript\nclass HashTable {\n  storage: Map<number, number>;\n\n  constructor() {\n    this.storage = new Map<number, number>();\n  }\n\n  insert(key: number, value: number): void {\n    this.storage.set(key, value);\n  }\n\n  search(key: number): number | null {\n    return this.storage.has(key) ? this.storage.get(key) : null;\n  }\n}\n\nconst hashTable = new HashTable();\nconst arr6 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\n\n// 将数组中的值作为键，索引作为值存储到哈希表中\narr6.forEach((value, index) => {\n  hashTable.insert(value, index);\n});\n\n// 测试用例\nconsole.log(hashTable.search(10)); // 输出：8\nconsole.log(hashTable.search(4));  // 输出：null\n```\n\n\n\n#### 二叉查找树（Binary Search Tree）\n\n```typescript\nclass TreeNode {\n  value: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  root: TreeNode | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value: number): void {\n    if (this.root === null) {\n      this.root = new TreeNode(value);\n    } else {\n      this._insertNode(this.root, value);\n    }\n  }\n\n  private _insertNode(node: TreeNode, value: number): void {\n    if (value < node.value) {\n      if (node.left === null) {\n        node.left = new TreeNode(value);\n      } else {\n        this._insertNode(node.left, value);\n      }\n    } else {\n      if (node.right === null) {\n        node.right = new TreeNode(value);\n      } else {\n        this._insertNode(node.right, value);\n      }\n    }\n  }\n\n  search(value: number): boolean {\n    return this._searchNode(this.root, value);\n  }\n\n  private _searchNode(node: TreeNode | null, value: number): boolean {\n    if (node === null) {\n      return false;\n    }\n\n    if (value < node.value) {\n      return this._searchNode(node.left, value);\n    } else if (value > node.value) {\n      return this._searchNode(node.right, value);\n    } else {\n      return true;\n    }\n  }\n}\n\nconst bst = new BinarySearchTree();\nconst arr7 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\n\n// 向二叉查找树中插入数组中的值\narr7.forEach(value => {\n  bst.insert(value);\n});\n\n// 测试用例\nconsole.log(bst.search(10)); // 输出：true\nconsole.log(bst.search(4));  // 输出：false\n```\n\n\n\n#### 平衡二叉查找树（Balanced Binary Search Tree），如AVL树、红黑树\n\n```typescript\nclass AVLTreeNode extends TreeNode {\n  height: number;\n\n  constructor(value: number) {\n    super(value);\n    this.height = 1;\n  }\n}\n\nclass AVLTree extends BinarySearchTree {\n  insert(value: number): void {\n    this.root = this._insertNode(this.root as AVLTreeNode, value);\n  }\n\n  private _insertNode(node: AVLTreeNode | null, value: number): AVLTreeNode {\n    if (node === null) {\n      return new AVLTreeNode(value);\n    }\n\n    if (value < node.value) {\n      node.left = this._insertNode(node.left as AVLTreeNode, value);\n    } else if (value > node.value) {\n      node.right = this._insertNode(node.right as AVLTreeNode, value);\n    } else {\n      return node;\n    }\n\n    node.height = 1 + Math.max(this._height(node.left), this._height(node.right));\n    const balance = this._getBalance(node);\n\n    if (balance > 1) {\n      if (value < (node.left as AVLTreeNode).value) {\n        return this._rotateRight(node);\n      } else {\n        node.left = this._rotateLeft(node.left as AVLTreeNode);\n        return this._rotateRight(node);\n      }\n    }\n\n    if (balance < -1) {\n      if (value > (node.right as AVLTreeNode).value) {\n        return this._rotateLeft(node);\n      } else {\n        node.right = this._rotateRight(node.right as AVLTreeNode);\n        return this._rotateLeft(node);\n      }\n    }\n\n    return node;\n  }\n\n  private _height(node: TreeNode | null): number {\n    if (node === null) {\n      return 0;\n    }\n    return (node as AVLTreeNode).height;\n  }\n\n  private _getBalance(node: AVLTreeNode): number {\n    return this._height(node.left) - this._height(node.right);\n  }\n\n  private _rotateLeft(z: AVLTreeNode): AVLTreeNode {\n    const y = z.right as AVLTreeNode;\n    const T2 = y.left;\n\n    y.left = z;\n    z.right = T2;\n\n    z.height = 1 + Math.max(this._height(z.left), this._height(z.right));\n    y.height = 1 + Math.max(this._height(y.left), this._height(y.right));\n\n    return y;\n  }\n\n  private _rotateRight(y: AVLTreeNode): AVLTreeNode {\n    const x = y.left as AVLTreeNode;\n    const T2 = x.right;\n\n    x.right = y;\n    y.left = T2;\n\n    y.height = 1 + Math.max(this._height(y.left), this._height(y.right));\n    x.height = 1 + Math.max(this._height(x.left), this._height(x.right));\n\n    return x;\n  }\n}\n\nconst avl = new AVLTree();\nconst arr8 = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];\n\n// 向平衡二叉查找树中插入数组中的值\narr8.forEach(value => {\n  avl.insert(value);\n});\n\n// 测试用例\nconsole.log(avl.search(10)); // 输出：true\nconsole.log(avl.search(4)); // 输出：false\n```\n\n\n\n<hr />\n\n## 设计模式\n\n### 谈谈你对设计模式的理解，为什么需要设计模式？\n\n设计模式是针对软件设计中反复出现的问题所提出的通用解决方案。它们是在大量实际软件开发经验中总结出的优秀设计实践，描述了在特定场景下解决问题的方法和思路。设计模式旨在提高代码的可复用性、可扩展性和可维护性，使软件具有更好的灵活性和稳定性。\n\n设计模式的重要性主要体现在以下几个方面：\n\n1. 高效解决问题：设计模式为软件设计中常见问题提供了成熟、可靠的解决方案，使开发者能够更高效地解决问题，避免重复发明轮子。\n2. 促进代码复用：设计模式是通用的设计结构，可以在不同的场景和项目中复用，提高了代码的可复用性，减少了开发时间和成本。\n3. 提高代码质量：设计模式强调模块间的低耦合、高内聚，有助于提高代码的可读性、可维护性和稳定性，降低了软件的错误率。\n4. 促进团队协作：设计模式提供了一套通用的设计语言，使得团队成员在交流和理解代码时能够更加顺畅，提高了团队协作效率。\n5. 有益于个人成长：学习和熟练运用设计模式有助于提高开发者的设计能力和编程水平，使得开发者能够在面对复杂问题时更加从容应对。\n\n设计模式主要分为三大类：\n\n1. 创建型模式（Creational Patterns）：关注对象的创建过程，如工厂模式、单例模式、原型模式和建造者模式。\n2. 结构型模式（Structural Patterns）：关注类和对象的组合，如适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式和代理模式。\n3. 行为型模式（Behavioral Patterns）：关注对象间的通信，如责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。\n\n需要注意的是，设计模式并非万能的，它们只是解决特定问题的方法和思路。在实际开发中，应根据具体需求和场景选择合适的设计模式，并且不要过度追求设计模式，以免引入不必要的复杂性。\n\n\n\n### 谈谈你对工厂模式的理解\n\n工厂模式（Factory Pattern）是一种创建型设计模式，它的核心思想是将对象的创建过程封装起来，让客户端不直接与具体类进行交互，而是通过一个统一的接口来创建所需的对象。这样，当需要修改或者扩展对象的创建逻辑时，我们只需要修改工厂类，而不需要修改客户端的代码，从而达到降低耦合度和提高代码可维护性的目的。\n\n工厂模式主要分为以下几种类型：\n\n1. 简单工厂模式（Simple Factory Pattern）：一个工厂类根据传入的参数创建对应的对象。这种模式的缺点是，当需要添加新的产品时，需要修改工厂类的代码，违反了开放封闭原则。\n2. 工厂方法模式（Factory Method Pattern）：定义一个工厂接口，让各个具体工厂类实现这个接口，负责创建对应的产品。客户端只需要与工厂接口进行交互，而不关心具体的工厂和产品类。这种模式遵循了开放封闭原则，当需要添加新的产品时，只需添加相应的具体工厂类，不需要修改其他代码。\n3. 抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式可以应对更复杂的场景，比如创建多个产品族的产品。客户端同样只需与抽象工厂接口进行交互，实现了对象创建过程的解耦。\n\n工厂模式的优点：\n\n1. 降低了客户端与具体产品类之间的耦合度，提高了代码可维护性。\n2. 代码结构清晰，易于扩展和修改。\n3. 可以实现对象的复用，节省资源。\n\n工厂模式的缺点：\n\n1. 工厂类职责过重，当产品种类繁多时，代码可能变得复杂。\n2. 增加了系统的抽象性和理解难度。\n\n总之，工厂模式通过封装对象的创建过程，降低了客户端与具体产品类之间的耦合度，提高了代码的可维护性和扩展性。在实际开发中，可以根据项目的具体需求来选择适用的工厂模式类型。\n\n\n\n### 谈谈你对单例模式的理解\n\n单例模式（Singleton Pattern）是一种创建型设计模式，其核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这种模式适用于那些在整个系统中需要唯一实例的场景，如数据库连接池、配置管理器、日志记录器等。单例模式可以确保系统中该类的实例具有全局唯一性，避免了多次创建和销毁实例带来的资源浪费和潜在的错误。\n\n实现单例模式的关键点包括：\n\n1. 将构造方法私有化，以防止客户端通过 new 关键字创建实例。\n2. 在类内部创建一个静态私有实例变量。\n3. 提供一个公共的静态方法（通常命名为 getInstance()）来获取该实例。\n\n单例模式有多种实现方式，主要包括以下几种：\n\n1. 懒汉式：实例在第一次调用 getInstance() 方法时创建。这种方式的优点是实现了延迟加载，缺点是在多线程环境下可能出现线程安全问题，需要通过加锁等手段解决。\n2. 饿汉式：实例在类加载时创建。这种方式的优点是线程安全，缺点是没有实现延迟加载，如果实例的创建过程比较耗时或资源消耗较大，可能会导致性能问题。\n3. 双重检查锁定（Double-Checked Locking）：结合懒汉式和同步锁，在 getInstance() 方法内部进行双重判断，确保线程安全且避免了不必要的同步开销。\n4. 静态内部类：利用 Java 的静态内部类特性，在静态内部类中创建单例实例，实现了延迟加载且线程安全。\n5. 枚举：使用枚举类型实现单例，这种方式是线程安全的，而且代码简洁易懂。这也是《Effective Java》一书推荐的实现方式。\n\n单例模式的优点：\n\n1. 保证了实例的全局唯一性，避免了资源浪费和潜在的错误。\n2. 可以实现全局访问，方便使用。\n\n单例模式的缺点：\n\n1. 单例类的职责过重，可能违反单一职责原则。\n2. 若实例需要扩展，可能会引入修改困难。\n\n总之，单例模式通过确保一个类只有一个实例，并提供一个全局访问点来获取该实例，可以在一定程度上提高系统的性能和资源利用率。在实际开发中，应根据具体需求选择合适的单例模式实现方式。\n\n\n\n### 谈谈你对策略模式的理解\n\n策略模式（Strategy Pattern）是一种行为型设计模式，其核心思想是定义一系列算法，将它们封装成策略类，并使它们可以相互替换。策略模式使得算法可以独立于使用它的客户端而变化，这样可以实现在不修改客户端代码的情况下，灵活地改变和扩展算法。策略模式将算法的定义和使用分离，降低了算法之间的耦合，提高了代码的可扩展性和可维护性。\n\n策略模式通常包含以下几个部分：\n\n1. 策略接口（Strategy Interface）：定义一个公共接口，用于声明所有策略类需要实现的方法。\n2. 具体策略类（Concrete Strategy）：实现策略接口，封装具体的算法和行为。\n3. 上下文类（Context）：持有一个策略接口的引用，用于调用具体策略类的方法。客户端可以通过修改上下文类持有的策略引用来改变算法。\n\n策略模式的优点：\n\n1. 算法和客户端解耦：策略模式将算法的定义和使用分离，使得客户端与具体算法解耦，降低了模块间的耦合度。\n2. 易于扩展和替换：策略模式将每个算法封装成独立的策略类，可以方便地添加新的策略或替换现有策略，而无需修改客户端代码。\n3. 提高代码可读性：策略模式将不同的算法和行为封装到具体策略类中，使得代码结构更加清晰，提高了代码的可读性和可维护性。\n4. 遵循开放封闭原则：通过策略模式，可以在不修改客户端代码的前提下，灵活地改变和扩展算法，符合开放封闭原则。\n\n策略模式的缺点：\n\n1. 增加了代码数量：每个策略都需要定义一个具体策略类，当策略较多时，会导致类数量的增加。\n2. 客户端需要了解策略的区别：虽然策略模式将算法的使用与实现分离，但客户端仍需要了解不同策略之间的区别，以便选择合适的策略。\n\n总之，策略模式通过将算法封装成策略类并定义一个统一的策略接口，实现了算法和客户端的解耦，提高了代码的复用性。\n\n\n\n### 谈谈你对观察者模式的理解\n\n观察者模式（Observer Pattern），又称发布-订阅模式（Publish-Subscribe Pattern），是一种行为型设计模式。它定义了对象之间的一对多依赖关系，当一个对象（被观察者）的状态发生改变时，所有依赖于它的对象（观察者）都会得到通知并自动更新。观察者模式用于实现事件驱动的架构，降低了对象之间的耦合，提高了代码的灵活性和可扩展性。\n\n观察者模式主要包含以下几个部分：\n\n1. 抽象被观察者（Subject）：定义了添加、删除和通知观察者的方法。被观察者维护一个观察者列表，用于存储所有注册的观察者。\n2. 具体被观察者（Concrete Subject）：实现抽象被观察者的接口，具有一些状态，当这些状态发生变化时，通知所有注册的观察者。\n3. 抽象观察者（Observer）：定义一个更新方法，用于接收被观察者状态变化的通知。\n4. 具体观察者（Concrete Observer）：实现抽象观察者的接口，当接收到被观察者状态变化的通知时，执行相应的更新操作。\n\n观察者模式的优点：\n\n1. 降低耦合度：观察者模式使得被观察者与观察者之间的依赖关系变得松散，它们可以独立地变化和复用，提高了代码的灵活性。\n2. 支持事件驱动：观察者模式可以实现基于事件的通知机制，使得对象之间可以相互通知和响应，有助于实现复杂的事件驱动架构。\n3. 易于扩展：通过添加新的观察者，可以方便地扩展系统的功能，而无需修改被观察者的代码。\n\n观察者模式的缺点：\n\n1. 可能引发循环调用：在实际应用中，如果观察者与被观察者之间存在循环依赖关系，可能会引发循环调用，导致系统崩溃。\n2. 通知顺序不可控：被观察者通知观察者的顺序是不可控的，这可能导致一些依赖于通知顺序的问题。\n\n总之，观察者模式通过定义对象之间的一对多依赖关系，实现了事件驱动的架构，降低了对象间的耦合，提高了代码的灵活性和可扩展性。在实际开发中，观察者模式广泛应用于实现各种事件监听和通知机制，如用户界面的事件处理、消息推送、日志记录等。\n\n在使用观察者模式时，还需要注意以下几点：\n\n1. 避免循环调用：确保被观察者和观察者之间不存在循环依赖关系，以防止循环调用导致的问题。\n2. 考虑性能问题：观察者模式的通知机制可能会导致大量的观察者被通知，从而影响系统性能。在设计时，应合理选择观察者的数量和通知策略，以减轻性能压力。\n3. 封装通知逻辑：为了让被观察者更加通用，可以考虑将通知观察者的逻辑封装到一个单独的类中，使得被观察者聚焦于自身业务逻辑。\n4. 使用现有框架：许多现代编程语言和框架都提供了对观察者模式的支持，如 Java 中的 `java.util.Observable` 和 `java.util.Observer` 类，C# 中的事件和委托机制等。在实际开发中，可以充分利用这些现有功能，避免重复造轮子。\n\n综上所述，观察者模式是一种实用且灵活的设计模式，它提供了一种有效的方式来解决对象间的通信和依赖问题。在实际开发中，应根据具体需求和场景选择合适的观察者模式实现方式，并注意避免可能存在的问题。\n\n\n\n### 谈谈你对命令模式的理解\n\n命令模式（Command Pattern）是一种行为型设计模式，它将请求封装为一个对象，从而使客户端可以用不同的请求对接收者进行参数化。命令模式还支持可撤销的操作，可以将请求的发送者与接收者解耦，使得请求的发送者不需要知道接收者的具体实现。命令模式可以提高代码的灵活性和可扩展性，广泛应用于实现任务队列、事务处理、日志记录等功能。\n\n命令模式主要包含以下几个部分：\n\n1. 抽象命令类（Command）：定义一个抽象的接口，用于声明执行操作的方法。通常包含一个或多个抽象方法，如 `execute()`、`undo()` 等。\n2. 具体命令类（Concrete Command）：实现抽象命令类的接口，封装接收者和一组行为。具体命令类通常包含一个接收者（Receiver）的引用，并在 `execute()` 方法中调用接收者的相应方法。\n3. 接收者（Receiver）：实现具体的业务逻辑，提供命令类需要执行的方法。\n4. 调用者（Invoker）：持有一个命令对象的引用，负责调用命令对象的 `execute()` 方法。调用者可以是客户端代码，也可以是一个中间类，负责接收客户端的请求并调用命令对象。\n\n命令模式的优点：\n\n1. 解耦请求发送者与接收者：命令模式将请求封装成命令对象，使得发送者与接收者之间的依赖关系变得松散，提高了代码的灵活性。\n2. 易于扩展：通过添加新的具体命令类，可以方便地扩展系统功能，而无需修改现有代码。\n3. 支持撤销操作：命令模式可以通过实现 `undo()` 方法来支持撤销操作，使得客户端可以撤销已执行的命令。\n4. 方便实现任务队列、事务和日志记录：命令模式可以将命令对象存储在队列中，实现任务调度和事务处理；同时，可以将命令对象序列化到日志文件中，实现日志记录和恢复功能。\n\n命令模式的缺点：\n\n1. 增加了类的数量：每个具体命令都需要定义一个类，当命令较多时，会导致类数量的增加，增加了系统的复杂性。\n2. 可能增加系统开销：由于命令对象的创建和调用，命令模式可能会导致额外的开销，尤其是在高性能要求的场景下。\n\n总之，命令模式通过将请求封装为命令对象，实现了请求的发送者与接收者之间的解耦，提高了代码的灵活性和可扩展性。在实际开发中，命令模式可以应用于以下场景：\n\n1. 需要将请求发送者与接收者解耦的场景：当请求发送者不需要知道接收者的具体实现时，可以使用命令模式将请求封装为命令对象，从而实现解耦。\n2. 需要支持撤销操作的场景：命令模式可以通过实现 `undo()` 方法来支持撤销操作，使客户端可以方便地撤销已执行的命令。\n3. 需要实现任务队列、事务处理或日志记录的场景：命令模式可以将命令对象存储在队列中，实现任务调度和事务处理；同时，可以将命令对象序列化到日志文件中，实现日志记录和恢复功能。\n\n在使用命令模式时，需要注意以下几点：\n\n1. 合理划分命令类：为了降低系统的复杂性，应该合理地划分命令类，避免创建过多的具体命令类。\n2. 注意性能开销：由于命令对象的创建和调用可能导致额外的开销，因此在高性能要求的场景下，应考虑是否适合使用命令模式。\n3. 使用现有框架：许多现代编程语言和框架都提供了对命令模式的支持，如 C# 中的委托和命令绑定等。在实际开发中，可以充分利用这些现有功能，避免重复造轮子。\n\n总之，命令模式是一种实用且灵活的设计模式，它提供了一种有效的方式来解决请求发送者与接收者之间的解耦问题。在实际开发中，应根据具体需求和场景选择合适的命令模式实现方式，并注意避免可能存在的问题。\n\n\n\n### 谈谈你模板方法模式的理解\n\n模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将算法的具体步骤延迟到子类中实现。模板方法模式允许子类在不改变算法结构的情况下，重新定义算法的某些步骤。这种模式可以帮助我们提高代码的复用性和封装性，降低了系统的复杂性。\n\n模板方法模式主要包含以下几个部分：\n\n1. 抽象类（Abstract Class）：定义了一个模板方法，它包含了算法的骨架。模板方法由一系列具体方法和抽象方法组成，具体方法由抽象类实现，抽象方法由子类实现。抽象类可以定义一些钩子方法（Hook Methods），用于在特定情况下让子类改变算法的行为。\n2. 具体子类（Concrete Class）：实现抽象类中的抽象方法，提供算法的具体实现。子类可以根据需求，覆盖或扩展抽象类中的钩子方法。\n\n模板方法模式的优点：\n\n1. 代码复用：通过将通用的算法骨架定义在抽象类中，子类可以复用这些代码，降低了代码的重复度。\n2. 封装性：模板方法模式将具体实现细节封装在子类中，使得客户端只需要关注抽象类的接口，提高了系统的封装性。\n3. 扩展性：子类可以覆盖或扩展抽象类中的钩子方法，从而实现对算法的灵活扩展。\n4. 易于维护：将算法骨架和具体实现分离，有利于维护和修改。\n\n模板方法模式的缺点：\n\n1. 类数量增加：对于每个实现不同的算法，都需要定义一个具体子类，这可能导致类数量的增加。\n2. 需要继承：模板方法模式依赖于继承关系，可能会导致子类过于庞大，影响代码的可读性和维护性。\n\n总之，模板方法模式是一种实用且灵活的设计模式，它通过定义算法的骨架，将具体实现延迟到子类中，实现了代码复用和封装性。在实际开发中，模板方法模式适用于以下场景：\n\n1. 算法骨架固定，但具体实现可能不同的场景。\n\n2. 当需要在不改变算法结构的情况下，重新定义算法的某些步骤。\n\n3. 当子类需要复用父类的某些通用行为，但又希望保留扩展和覆盖的能力时。\n\n在使用模板方法模式时，需要注意以下几点：\n\n   1. 合理划分抽象方法和具体方法：为了保持代码的清晰和易于维护，应合理地划分抽象方法和具体方法，将可复用的代码放入抽象类中，将具体实现放入子类中。\n   2. 合理使用钩子方法：钩子方法可以让子类有机会改变算法的行为，但不要过度使用，以免导致系统的复杂性增加。\n   3. 避免过度继承：模板方法模式依赖于继承关系，因此在设计时要避免过度继承，可以考虑使用组合和聚合等方式来减轻子类的负担。\n   4. 保持抽象类的稳定性：抽象类定义了算法的骨架，对其的修改可能会影响到所有子类。因此，在设计时要确保抽象类的稳定性，尽量避免对其进行修改。\n\n总之，模板方法模式通过定义算法的骨架，将具体实现延迟到子类中，提高了代码的复用性和封装性。在实际开发中，应根据具体需求和场景选择合适的模板方法模式实现方式，并注意避免可能存在的问题。\n\n\n\n### 谈谈你对迭代器模式的理解\n\n\n\n### 谈谈你对状态模式的理解\n\n状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为。状态模式将对象的状态封装为独立的类，使得状态转换和行为的实现变得更加清晰。状态模式可以消除大量的条件判断语句，提高代码的可读性和可维护性。\n\n状态模式主要包含以下几个部分：\n\n1. 抽象状态类（State）：定义了一个接口，用于封装与特定状态相关的行为。通常包含一个或多个抽象方法，如 `handle()`。\n2. 具体状态类（Concrete State）：实现抽象状态类的接口，提供具体状态对应的行为实现。每个具体状态类通常只表示对象的一种状态。\n3. 上下文类（Context）：维护一个当前状态的引用，并提供一个接口来改变当前状态。上下文类通常会将行为委托给当前状态对象来执行。\n\n状态模式的优点：\n\n1. 封装性：将状态和与状态相关的行为封装在一起，使得代码结构更加清晰。\n2. 易于扩展：通过添加新的状态类，可以方便地扩展系统的功能，而无需修改现有代码。\n3. 消除条件判断：状态模式通过委托给状态对象来执行行为，避免了大量的条件判断语句，提高了代码的可读性和可维护性。\n4. 符合开闭原则：状态模式对扩展开放，对修改封闭，增加新的状态类不会影响现有代码。\n\n状态模式的缺点：\n\n1. 类数量增加：对于每个具体状态，都需要定义一个状态类，这可能导致类数量的增加，增加了系统的复杂性。\n2. 状态切换逻辑分散：状态切换的逻辑可能分散在状态类和上下文类中，这可能导致状态切换逻辑的复杂性增加。\n\n总之，状态模式是一种实用且灵活的设计模式，它通过将对象的状态封装为独立的类，实现了状态转换和行为的清晰表示。在实际开发中，状态模式适用于以下场景：\n\n1. 当一个对象的行为依赖于其状态，且状态数量较多时。\n2. 当需要在运行时改变对象的行为，且这些行为依赖于对象的状态时。\n3. 当系统中存在大量的与状态相关的条件判断语句，导致代码难以维护和扩展时。\n\n在使用状态模式时，需要注意合理划分状态类，并关注状态切换逻辑的实现。\n\n\n\n### 谈谈你对装饰者模式的理解\n\n装饰者模式（Decorator Pattern）是一种结构型设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新的功能。装饰者模式使用一种组合的方式，将新功能附加到原始对象上，从而遵循了开闭原则，使得系统具有较好的可扩展性。\n\n装饰者模式主要包含以下几个部分：\n\n1. 抽象组件类（Component）：定义一个抽象接口，用于规范需要被装饰的对象的行为。\n2. 具体组件类（Concrete Component）：实现抽象组件类的接口，表示需要被装饰的对象。\n3. 抽象装饰者类（Decorator）：继承自抽象组件类，并持有一个抽象组件类的引用。抽象装饰者类的主要作用是为子类提供统一的接口，并将请求转发给持有的抽象组件对象。\n4. 具体装饰者类（Concrete Decorator）：继承自抽象装饰者类，实现具体的装饰功能。具体装饰者类可以在原有功能的基础上，添加新的功能。\n\n装饰者模式的优点：\n\n1. 灵活性：装饰者模式可以动态地为对象添加新功能，而不需要修改原始类的代码，使得系统更具灵活性。\n2. 可扩展性：通过添加新的具体装饰者类，可以方便地扩展系统的功能，符合开闭原则。\n3. 组合灵活：装饰者模式可以通过组合不同的装饰者类，实现多种不同的功能组合。\n4. 易于维护：装饰者模式将不同的功能分离到不同的装饰者类中，有利于代码的维护和修改。\n\n装饰者模式的缺点：\n\n1. 类数量增加：对于每个装饰功能，都需要定义一个具体装饰者类，这可能导致类数量的增加，增加了系统的复杂性。\n2. 增加了系统的复杂性：由于装饰者模式使用了组合关系，这可能导致系统的结构变得更加复杂。\n\n总之，装饰者模式是一种实用且灵活的设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新功能。在实际开发中，装饰者模式适用于以下场景：\n\n1. 当需要为一个现有类添加新功能，但又不想修改原始类的代码时。\n2. 当需要通过组合多个功能，实现不同的功能组合时。\n3. 当需要在运行时动态地为对象添加功能，且这些功能可以相互独立地叠加时。\n\n在使用装饰者模式时，需要注意以下几点：\n\n1. 合理设计抽象组件类和抽象装饰者类：为了保持代码的清晰和易于维护，应合理地设计抽象组件类和抽象装饰者类，确保它们具有清晰的职责和良好的封装性。\n2. 注意装饰者类的创建和组合：装饰者模式依赖于装饰者类的创建和组合，因此在设计时要关注这些方面，确保装饰者类可以灵活地创建和组合。\n3. 避免过度使用装饰者模式：虽然装饰者模式具有很好的灵活性和可扩展性，但是过度使用可能导致系统变得过于复杂。在实际开发中，应根据具体需求和场景选择合适的设计模式。\n4. 考虑性能影响：由于装饰者模式使用了多层的组合关系，这可能导致性能损失。在设计和实现时，应关注性能影响，避免因为过多的嵌套而导致性能下降。\n\n总之，装饰者模式是一种实用且灵活的设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新功能。在实际开发中，应根据具体需求和场景选择合适的装饰者模式实现方式，并注意避免可能存在的问题。\n\n\n\n### 谈谈你对适配器模式的理解\n\n适配器模式是一种结构型设计模式，它的主要目标是使得那些原本不兼容的接口能够一起工作。简单来说，适配器可以作为两个不同对象之间的桥梁，这两个对象可能由于接口不同而无法直接进行交互。\n\n在软件设计中，适配器模式常用于以下场景：\n\n1. 旧代码与新代码交互：如果你在开发过程中引入了新的类，这个新的类的接口与现有代码不兼容，但你又不希望更改现有代码，那么你可以创建一个适配器。这个适配器能够同时与新的类和现有代码进行交互，确保它们能够顺利地协同工作。\n\n2. 外部系统或库：当你的应用需要与外部系统或者第三方库进行交互，而这些系统或者库的接口并不符合你的预期，这个时候适配器模式也能发挥作用。\n\n3. 统一接口：如果你的系统中有多个类，它们执行相似的功能但接口不同，使用适配器可以使得这些类有统一的接口，这将使你的代码更加易于管理和维护。\n\n在适配器模式中，通常会有以下几个角色：\n\n1. 目标（Target）：这是你期望得到的接口，你的系统需要通过这个接口与服务进行交互。\n\n2. 适配器（Adapter）：这是实现了目标接口的类。适配器会把调用请求转发给适配者。\n\n3. 适配者（Adaptee）：这是需要被适配的类或系统。它的接口与目标接口不同，因此不能直接与你的系统交互。\n\n4. 客户（Client）：这是使用目标接口的类。客户通过目标接口与适配器进行交互，而无需知道适配器和适配者的存在。\n\n适配器模式是一种非常实用的设计模式，它提供了一种灵活的方式来创建、组合和复用对象，特别是那些不直接兼容的对象。\n\n\n\n### 谈谈你对外观模式的理解\n\n外观模式（Facade Pattern）是一种结构型设计模式，它为一组复杂的子系统提供一个统一的接口，使得这些子系统更容易被客户端使用。外观模式通过定义一个高层接口，将复杂的子系统实现隐藏起来，从而简化了客户端与子系统之间的交互。\n\n外观模式主要包含以下几个部分：\n\n1. 外观类（Facade）：提供一个简单的接口，用于与客户端进行交互。外观类将客户端的请求委托给相应的子系统，处理子系统间的依赖关系，使得客户端与子系统之间的交互变得更加简单。\n2. 子系统类（Subsystem）：表示系统内部的各个子系统，实现具体的业务逻辑。子系统类可以独立工作，且不依赖于外观类。子系统类通常具有复杂的接口和实现。\n\n外观模式的优点：\n\n1. 简化接口：外观模式为复杂的子系统提供了一个简化的接口，使得客户端与子系统的交互变得更加简单。\n2. 降低耦合：外观模式将客户端与子系统之间的依赖关系降低到最小，有利于系统的解耦和维护。\n3. 提高可维护性：外观模式将子系统的实现细节隐藏起来，使得客户端无需关心这些细节，有利于提高系统的可维护性。\n4. 符合迪米特原则：外观模式使得客户端只需要与外观类进行交互，而无需直接与子系统类交互，从而遵循了迪米特原则。\n\n外观模式的缺点：\n\n1. 有限的封装：外观模式可能无法完全封装所有子系统的功能，有时客户端可能需要直接访问子系统类，以实现一些特定的功能。\n2. 过多的依赖：如果系统中的外观类数量过多，可能导致客户端与外观类之间的依赖过多，从而影响系统的解耦。\n\n总之，外观模式是一种实用且简单的设计模式，它通过定义一个统一的接口，简化了客户端与复杂子系统之间的交互。在实际开发中，外观模式适用于以下场景：\n\n1. 当需要为一个复杂的子系统提供一个简化的接口时。\n2. 当需要将客户端与子系统之间的依赖降低到最小时。\n3. 当需要将多个子系统组合使用，以实现更复杂的功能时。\n\n在使用外观模式时，需要注意以下几点：\n\n1. 合理划分子系统：为了保持代码的清晰和易于维护，应合理地划分子系统，确保子系统具有清晰的职责和良好的封装性。\n2. 设计简单易用的外观接口：外观类的主要目的是简化客户端与子系统的交互，因此在设计外观类时，应该关注接口的简单性和易用性。\n3. 不要过度封装：虽然外观模式可以将子系统的实现细节隐藏起来，但在实际开发中，有时客户端可能需要直接访问子系统类。因此，在设计外观模式时，应避免过度封装。\n4. 注意外观类与子系统的解耦：外观类应尽量减少对子系统的直接依赖，以保持系统的解耦。如果子系统需要进行修改或升级，应尽量避免影响到外观类和客户端。\n\n通过合理地使用外观模式，可以简化复杂子系统与客户端之间的交互，降低系统的耦合度，提高系统的可维护性。在实际开发中，应根据具体需求和场景选择合适的外观模式实现方式，并注意避免可能存在的问题。\n\n\n\n### 谈谈你对代理模式的理解\n\n代理模式是一种常用的结构型设计模式，其主要目标是通过引入一个新的对象（即代理对象）来控制对原对象的访问。代理对象可以在客户端和目标对象之间起到中介的作用。\n\n代理模式主要有三种常见的形式：\n\n1. 虚拟代理：如果一个对象的加载或初始化非常消耗资源，虚拟代理可以延迟这个对象的创建直到真正需要的时候。例如，网页中的图片加载就可以使用虚拟代理，只有当图片在屏幕上滚动到可视范围内时，才开始加载真正的图片。\n\n2. 保护代理：如果一个对象有权限控制需求，保护代理可以决定哪些客户端可以访问该对象。例如，一些对象可能只允许管理员角色进行访问和操作。\n\n3. 远程代理：如果一个对象在不同的地址空间（例如，另一台机器上），远程代理可以隐藏这个对象存在于不同地址空间的事实。例如，在分布式系统或网络通信中，客户端对象通常会与一个本地的代理对象通信，这个代理对象负责通过网络与远程对象通信。\n\n在代理模式中，通常涉及以下几个角色：\n\n1. 抽象主题（Subject）：定义了 RealSubject 和 Proxy 的公共接口，这样在任何使用 RealSubject 的地方都可以使用 Proxy。\n\n2. 真实主题（RealSubject）：定义了 Proxy 所代表的真实实体。\n\n3. 代理（Proxy）：保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口。\n\n4. 客户（Client）：通过 Proxy 访问 RealSubject。\n\n使用代理模式的好处在于，客户端可以透明地使用代理，而不需要知道代理背后的复杂机制。这种设计模式特别适用于那些需要分离关注点的情况，从而使得我们可以聚焦于我们真正关心的业务逻辑，而不是其他辅助性的工作，比如访问控制、负载、网络通信等。\n\n\n\n### 谈谈你对组合模式的理解\n\n组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示“部分-整体”的层次关系，使得客户端可以以一致的方式处理单个对象和组合对象。组合模式适用于处理具有层次结构的数据，例如文件系统、组织结构等。\n\n组合模式主要包含以下几个部分：\n\n1. 抽象组件（Component）：定义一个接口，用于规范组合对象和叶子对象的公共行为。抽象组件通常包含一些基本操作，如添加子组件、删除子组件、获取子组件等。\n2. 叶子组件（Leaf）：表示树形结构中的叶子节点，实现抽象组件接口。叶子组件没有子组件，它负责实现具体的业务逻辑。\n3. 组合组件（Composite）：表示树形结构中的非叶子节点，实现抽象组件接口。组合组件包含一个子组件列表，用于存储其子组件。组合组件负责实现基本操作，如添加子组件、删除子组件、获取子组件等。同时，组合组件还可以实现其他与业务逻辑相关的操作。\n\n组合模式的优点：\n\n1. 统一操作：组合模式使得客户端可以以一致的方式处理单个对象和组合对象，简化了客户端的操作。\n2. 易于扩展：组合模式允许添加新的组件类型，只需实现抽象组件接口即可，不需要修改现有的代码。\n3. 更好地表示层次结构：组合模式可以很好地表示具有层次关系的数据结构，如文件系统、组织结构等。\n\n组合模式的缺点：\n\n1. 过度泛化：由于抽象组件接口定义了所有可能的操作，这可能导致叶子组件和组合组件之间的界限变得模糊，增加了实现的复杂性。\n2. 违反接口隔离原则：抽象组件接口可能包含一些对叶子组件和组合组件来说并不适用的方法，这违反了接口隔离原则。\n\n总之，组合模式是一种实用且简单的设计模式，它通过定义一个统一的抽象组件接口，使得客户端可以以一致的方式处理单个对象和组合对象。在实际开发中，组合模式适用于处理具有层次结构的数据，如文件系统、组织结构等。在使用组合模式时，应注意避免过度泛化和违反接口隔离原则的问题。\n\n\n\n<hr>\n\n## 操作系统\n\n### 什么是操作系统？\n\n操作系统（Operating System，简称 OS）是计算机硬件与用户之间的接口，负责管理和协调计算机硬件资源，为应用程序和用户提供一个友好的运行环境。操作系统具有多种功能，包括进程管理、内存管理、文件系统管理和设备管理等。\n\n操作系统使得程序员和用户不必关心底层硬件的具体细节，可以更高效地开发和使用计算机。常见的操作系统有 Microsoft Windows、macOS、Linux 等。\n\n\n\n### 软链接和硬链接的区别是什么？\n\n软链接（符号链接，Symbolic Link）和硬链接（Hard Link）是两种不同类型的文件链接，通常用于在 Unix 和类 Unix 的文件系统中创建文件或目录的引用。它们之间的主要区别如下：\n\n1. 存储方式：硬链接是在文件系统中创建一个与原始文件具有相同的 i-node（索引节点）号的新条目。这意味着硬链接与原始文件共享相同的数据块和属性。因此，它们是同一个文件的不同引用。相反，软链接则是一个独立的文件，它的 i-node 不同于原始文件。软链接包含了指向原始文件的路径信息。\n2. 删除操作：当删除原始文件时，硬链接仍然可以访问文件的内容，因为它们共享相同的数据块。然而，当删除原始文件时，软链接将失效，因为它仅包含指向原始文件的路径信息。这时，软链接就成了一个悬空的（或者说失效的）链接。\n3. 跨文件系统：硬链接只能在同一个文件系统中创建，因为它们共享相同的 i-node。而软链接可以跨文件系统创建，因为它们只是指向原始文件的路径，而不是具体的数据块。\n4. 链接类型：硬链接只能针对文件创建，不能针对目录。软链接则可以针对文件和目录创建。\n\n总之，硬链接是对原始文件内容的直接引用，而软链接是对原始文件路径的引用。硬链接共享与原始文件相同的 i-node 和数据块，而软链接具有独立的 i-node。\n\n\n\n### 并发和并行有什么区别？\n\n并发（Concurrency）和并行（Parallelism）是计算机科学中两个相关但不同的概念。它们都涉及到多任务处理，但执行方式和目标有所不同。\n\n1. 并发（Concurrency）：并发是指多个任务在同一时间段内交替执行，但在某个特定时刻，仅有一个任务在运行。这通常是通过任务之间快速切换来实现的，以便在一个任务等待资源（如 I/O 操作）时执行另一个任务。并发主要出现在单核处理器或者多核处理器但核心数量少于任务数量的情况下。并发的目标是充分利用处理器资源，提高资源的使用效率。\n2. 并行（Parallelism）：并行是指多个任务在同一时刻同时执行。这通常是通过多核处理器或多处理器系统来实现的，每个处理器或核心负责处理一个或多个任务。并行的目标是利用多个处理器或核心加速任务的完成，提高性能。\n\n总之，区别在于执行方式和目标：并发关注在同一时间段内多任务的交替执行，以提高资源利用率；而并行关注在同一时刻同时执行多个任务，以提高处理速度。在现实场景中，这两个概念可能同时存在，例如在多核处理器系统中执行多个并发任务。\n\n\n\n### 协程与线程的区别\n\n协程（Coroutine）和线程（Thread）都是用于实现并发执行的概念，但它们之间存在一些关键区别：\n\n1. 调度方式：线程的调度由操作系统内核管理，通常是抢占式调度。操作系统根据线程优先级和运行时间等因素在不同线程之间进行切换。相比之下，协程的调度是由程序自身控制的，通常采用协作式调度。协程之间的切换由协程自身决定，例如在某个协程遇到 I/O 操作或显式让出执行权时切换到另一个协程。\n2. 并发模型：线程是基于多任务并发执行的，每个线程在单独的执行上下文中运行。协程是基于单任务或多任务的并发执行，可以看作是轻量级的线程。在协程模型中，多个协程在同一个线程内共享执行上下文，通过协作式调度来实现并发。\n3. 资源消耗：线程通常比协程消耗更多的系统资源，因为每个线程都有自己的栈和内核资源。协程由于在用户态运行并共享同一个线程的执行上下文，通常具有更低的内存和系统资源消耗。\n4. 上下文切换开销：线程间的上下文切换涉及到内核态和用户态的切换，通常具有较大的开销。而协程间的上下文切换仅发生在用户态，不需要内核参与，因此开销较小。\n\n总之，协程和线程都是实现并发执行的方法，但它们在调度方式、并发模型、资源消耗和上下文切换开销等方面存在区别。协程是一种轻量级的并发机制，适用于 I/O 密集型任务和需要大量并发执行的场景。线程则适用于 CPU 密集型任务和多核处理器系统。\n\n\n\n### 进程与线程的区别\n\n进程（Process）和线程（Thread）是计算机科学中与并发和并行执行相关的两个基本概念。它们之间的主要区别如下：\n\n1. 定义和独立性：进程是一个独立的运行环境，包含了一个程序在运行过程中所需要的所有资源，如代码、数据、内存空间和系统资源等。每个进程在操作系统中都有独立的内存空间和地址空间。线程是进程内的一个执行单元，可以共享进程的资源。一个进程可以包含多个线程，它们共享进程的内存空间和系统资源，但每个线程都有自己独立的运行栈和局部变量。\n2. 上下文切换开销：线程间的上下文切换通常比进程间的上下文切换要快得多。因为线程共享进程的内存空间，所以在切换时不需要切换整个内存空间，只需要切换线程运行栈和寄存器状态等少量信息。而进程间的上下文切换需要更多的开销，因为它们具有独立的地址空间。\n3. 通信和同步：线程之间的通信和同步通常比进程之间的通信和同步更简单，因为线程共享进程的内存空间，可以直接访问其他线程的数据。进程之间的通信需要通过操作系统提供的进程间通信（IPC）机制，如管道、信号量、共享内存等。\n4. 容错性：由于进程具有独立的地址空间，一个进程的崩溃不太可能影响到其他进程。然而，线程共享进程的内存空间，一个线程的崩溃可能导致整个进程的崩溃，从而影响到进程中的其他线程。\n\n总之，进程是一个独立的执行环境，拥有独立的内存空间，而线程是进程内的执行单元，共享进程的资源。线程之间的上下文切换和通信开销相对较小，但容错性较差。\n\n\n\n### 什么是死锁？死锁产生的条件？\n\n死锁（Deadlock）是指在多任务环境中，一组或多组任务相互等待对方释放资源的一种状态。在这种情况下，任务之间互相阻塞，无法继续执行。死锁可能导致系统性能下降或完全停止工作。\n\n产生死锁的四个必要条件如下：\n\n1. 互斥条件（Mutual Exclusion）：资源不能被多个任务同时占用。也就是说，一旦一个任务获得某资源，其他任务必须等待该资源被释放。\n2. 占有并等待条件（Hold and Wait）：任务持有至少一个资源，同时等待其他任务释放的资源。这意味着任务既占有资源，又在等待其他资源。\n3. 非抢占条件（No Preemption）：资源不能被强制从任务中抢占。换句话说，在任务完成之前，它持有的资源不能被其他任务抢占。\n4. 循环等待条件（Circular Wait）：存在一组任务，它们构成了一个循环等待资源的链，即每个任务都在等待下一个任务持有的资源。\n\n要避免死锁，必须破坏产生死锁的这四个条件中的至少一个。常见的死锁预防和解决方法包括资源分配策略（如银行家算法）、资源有序分配、死锁检测与恢复等。\n\n\n\n### 进程调度策略有哪几种？\n\n进程调度策略是操作系统用于管理进程执行顺序和分配 CPU 时间的方法。以下是一些常见的进程调度策略：\n\n1. 先来先服务（First-Come, First-Served，FCFS）：按照进程到达的顺序进行调度。一旦一个进程开始执行，它将一直占用 CPU，直到完成。这种策略简单易实现，但可能导致较长的平均等待时间。\n2. 短作业优先（Shortest Job First，SJF）：根据进程的预计运行时间进行调度。具有较短运行时间的进程优先执行。这种策略可以降低平均等待时间，但需要预先知道进程的运行时间，实际中很难实现。\n3. 优先级调度（Priority Scheduling）：根据进程的优先级进行调度。优先级高的进程先执行。这种策略允许更重要的进程优先执行，但可能导致低优先级进程长时间得不到调度（饥饿现象）。\n4. 时间片轮转（Round Robin，RR）：为每个进程分配一个固定长度的时间片（或称为时间量子），然后按顺序执行。当一个进程的时间片用完时，调度器将其放到就绪队列的末尾，然后开始执行下一个进程。这种策略实现简单，公平性较好，适用于交互式系统。\n5. 多级反馈队列（Multilevel Feedback Queue）：将进程分配到不同优先级的队列中，并根据队列优先级和时间片轮转策略进行调度。这种策略可以在保证系统响应性的同时兼顾 CPU 利用率。\n\n这些进程调度策略各有优缺点，适用于不同的场景。在实际操作系统中，可能会采用混合或改进的调度策略，以满足不同需求。\n\n\n\n### 什么是虚拟内存？\n\n虚拟内存（Virtual Memory）是一种内存管理技术，它使得计算机能够为程序提供比实际物理内存更大的地址空间。通过虚拟内存技术，操作系统能够将程序和数据分割成多个独立的内存块（称为页面或页），并将这些内存块在需要时分别加载到物理内存中。同时，操作系统可以将不常用的内存块交换到磁盘上的一个专门区域（称为交换区或页面文件），从而腾出物理内存空间。\n\n虚拟内存的主要优点如下：\n\n1. 内存抽象：虚拟内存为每个进程提供了独立的地址空间，使进程可以在隔离的环境中运行，不需要关心其他进程的内存分配情况。\n2. 内存保护：由于每个进程拥有独立的地址空间，因此一个进程无法直接访问其他进程的内存，保证了内存安全。\n3. 空间扩展：虚拟内存允许程序使用比实际物理内存更大的地址空间，从而使得程序能够在物理内存有限的情况下正常运行。\n4. 内存共享：虚拟内存技术可以实现不同进程间的内存共享，例如共享库和内存映射文件等。\n5. 内存利用率提高：虚拟内存通过按需分配页面、将不常用的页面交换到磁盘等方式，提高了物理内存的利用率。\n\n虚拟内存的实现依赖于硬件支持，如内存管理单元（Memory Management Unit，MMU）等。MMU 负责将虚拟地址转换为物理地址，并在访问权限检查和页面错误处理等方面与操作系统协同工作。\n\n\n\n<hr>\n\n## 编码题\n\n### 用setTimeout实现setInterval\n\n```typescript\nfunction customSetInterval(callback: () => void, delay: number): () => void {\n    let timer;\n\n    const interval = () => {\n        callback();\n        timer = setTimeout(interval, delay)\n    }\n\n    timer = setTimeout(interval, delay)\n\n    // 返回清除定时器的函数\n    return () => {\n        clearTimeout(timer)\n    }\n}\n\n// 示例用法\nconst callback = () => console.log(\"Hello, world!\");\nconst delay = 1000; // 每隔1000毫秒执行一次\nconst clearIntervalFunc = customSetInterval(callback, delay);\n\n// 用法：在需要的时候清除定时器\n// clearIntervalFunc();\n```\n\n\n\n### var实现let\n\n```typescript\nfunction demo() {\n    (function() {\n        var x = \"Hello, world!\";\n        console.log(x); // 输出 \"Hello, world!\"\n    })();\n\n    try {\n        console.log(x); // 抛出 ReferenceError，因为x在这个作用域内未定义\n    } catch (error) {\n        console.error(error); // 输出错误信息\n    }\n}\n\ndemo();\n```\n\n\n\n### 实现所有的TypeScript Utility Types\n\n```typescript\n// 1. Partial<T>\ntype Partial<T> = { [P in keyof T]?: T[P] };\n\n// 2. Required<T>\ntype Required<T> = { [P in keyof T]-?: T[P] };\n\n// 3. Readonly<T>\ntype Readonly<T> = { readonly [P in keyof T]: T[P] };\n\n// 4. Pick<T, K>\ntype Pick<T, K extends keyof T> = { [P in K]: T[P] };\n\n// 5. Omit<T, K>\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n// 6. Exclude<T, U>\ntype Exclude<T, U> = T extends U ? never : T;\n\n// 7. Extract<T, U>\ntype Extract<T, U> = T extends U ? T : never;\n\n// 8. NonNullable<T>\ntype NonNullable<T> = Exclude<T, null | undefined>;\n\n// 9. ReturnType<T>\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n\n// 10. InstanceType<T>\ntype InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\n\n// 11. ThisParameterType<T>\ntype ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown;\n\n// 12. OmitThisParameter<T>\ntype OmitThisParameter<T> = T extends (this: any, ...args: infer A) => infer R ? (...args: A) => R : T;\n\n// 13. ThisType<T>\n// `ThisType` is a marker utility type and can\'t be implemented like other utility types.\n```\n\n\n\n### 防抖debounce\n\n```typescript\nfunction debounce(func: (...args: any[]) => void, wait: number): (...args: any[]) => void {\n    let timeout: ReturnType<typeof setTimeout> | null = null;\n\n    return (...args: any[]) => {\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n\n        timeout = setTimeout(() => {\n            func.apply(null, args);\n        }, wait);\n    };\n}\n```\n\n\n\n### 节流throttle\n\n```typescript\nfunction throttle(func: (...args: any[]) => void, limit: number): (...args: any[]) => void {\n    let lastCall = 0; // 记录上次调用的时间戳\n\n    return (...args: any[]) => {\n        const now = Date.now(); // 获取当前时间戳\n\n        // 如果当前时间与上次调用的时间差大于等于设定的限制时间，执行函数并更新上次调用时间\n        if (now - lastCall >= limit) {\n            func.apply(null, args);\n            lastCall = now;\n        }\n    };\n}\n\n```\n\n\n\n### New\n\n```typescript\nfunction customNew(constructorFn: Function, ...args: any[]): object {\n    const obj = Object.create(constructorFn.prototype); // 创建一个新对象，并将其原型链设置为构造函数的prototype\n    const result = constructorFn.apply(obj, args); // 调用构造函数并将this绑定到新创建的对象\n\n    // 如果构造函数返回了一个对象，那么返回这个对象，否则返回创建的新对象\n    return (typeof result === \"object\" && result !== null) ? result : obj;\n}\n\n// 示例用法\nfunction Person(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n}\n\nconst alice = customNew(Person, \"Alice\", 30) as Person;\nconsole.log(alice.name); // 输出 \"Alice\"\nconsole.log(alice.age);  // 输出 30\n```\n\n\n\n### 数组去重\n\n```typescript\n// First\nconst uniqueArray = (arr: any[]) => {\n    return [...new Set(arr)]\n}\n\n// Second\nconst uniqueArray = (arr: any[]) => {\n	const result = [];\n  for (const item of arr) {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  }\n  return result;\n}\n\n// Third\nconst uniqueArray = (arr: any[]) => {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) === index\n  })\n}\n\nconsole.log(uniqueArray([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5])); // [1, 2, 3, 4, 5, 6]\n```\n\n\n\n### 实现正则切分千分位\n\n```typescript\nfunction formatThousands(n: number): string {\n  const reg = /\\d{1,3}(?=(\\d{3})+$)/g;\n  const num = n.toString();\n  const formattedNum = num.replace(reg, \'$&,\');\n  return formattedNum;\n}\n\n// 测试\nconsole.log(formatThousands(123456789)); // 输出: 123,456,789\nconsole.log(formatThousands(1000000)); // 输出: 1,000,000\nconsole.log(formatThousands(9876543210)); // 输出: 9,876,543,210\n```\n\n\n\n### call\n\n```typescript\n// 实现自定义call方法\nFunction.prototype.myCall = function (thisArg: any, ...args: any[]): any {\n    const fn = this;\n    const uniqueKey = Symbol(\"uniqueKey\");\n    thisArg[uniqueKey] = fn;\n\n    const result = thisArg[uniqueKey](...args);\n    delete thisArg[uniqueKey];\n\n    return result;\n};\n\nconst obj = {\n    name: \'Alice\'\n}\n\n// 示例用法\nfunction greet(greeting: string, punctuation: string) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n}\n\ngreet.myCall(obj, \"Hello\", \"!\"); // 输出 \"Hello, Alice!\"\n```\n\n\n\n### apply\n\n```typescript\n// 实现自定义apply方法\nFunction.prototype.myApply = function (thisArg: any, args: any[]): any {\n    const fn = this;\n    const uniqueKey = Symbol(\"uniqueKey\");\n    thisArg[uniqueKey] = fn;\n\n    const result = thisArg[uniqueKey](...args);\n    delete thisArg[uniqueKey];\n\n    return result;\n};\n\nconst obj = {\n    name: \'Alice\'\n}\n\n// 示例用法\nfunction greet(greeting: string, punctuation: string) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n}\n\ngreet.myApply(obj, [\"Hi\", \"!\"]); // 输出 \"Hi, Alice!\"\n```\n\n\n\n### bind\n\n```typescript\n// 实现自定义bind方法\nFunction.prototype.myBind = function (thisArg: any, ...args1: any[]): (...args2: any[]) => any {\n    const fn = this;\n\n    return function (...args2: any[]) {\n        return fn.myApply(thisArg, args1.concat(args2));\n    };\n};\n\nconst obj = {\n    name: \'Alice\'\n}\n\n// 示例用法\nfunction greet(greeting: string, punctuation: string) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n}\n\nconst boundGreet = greet.myBind(obj, \"Hey\");\nboundGreet(\"?\"); // 输出 \"Hey, Alice?\"\n```\n\n\n\n### 深拷贝\n\n```typescript\nfunction deepClone(obj: any, cache = new WeakMap()): any {\n    if (obj === null || typeof obj !== \"object\") {\n        return obj;\n    }\n\n    if (cache.has(obj)) {\n        return cache.get(obj);\n    }\n\n    if (obj instanceof Date) {\n        return new Date(obj.getTime());\n    }\n\n    if (obj instanceof Function) {\n        return function(...args: any[]) {\n            obj.apply(this, args)\n        }\n    }\n\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n\n    if (obj instanceof Array) {\n        const clonedArr: any[] = [];\n        cache.set(obj, clonedArr);\n        for (let i = 0; i < obj.length; ++i) {\n            clonedArr[i] = deepClone(obj[i], cache);\n        }\n        return clonedArr;\n    }\n\n    const clonedObj: { [key: string]: any } = {};\n    cache.set(obj, clonedObj);\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone(obj[key], cache);\n        }\n    }\n\n    return clonedObj;\n}\n\n// 示例用法\nconst original: { [key: string]: any } = {\n    name: \"Alice\",\n    age: 30,\n    dateOfBirth: new Date(\"1993-01-01\"),\n    preferences: {\n        color: \"blue\",\n        food: \"pizza\"\n    },\n    sum() {\n        console.log(this.name + \'-\' + this.age);\n    }\n};\noriginal.original = original\noriginal.originalArr = [original, original]\n\nconst cloned = deepClone(original);\nconsole.log(cloned); // 输出与 original 相同但不是同一个引用的对象\n```\n\n\n\n### 柯里化\n\n```typescript\nfunction curry(fn: (...args: any[]) => any): (...args: any[]) => any {\n    const arity = fn.length; // 获取原函数的参数个数\n\n    function curried(...args: any[]): any {\n        if (args.length >= arity) {\n            return fn.apply(null, args);\n        }\n\n        return (...restArgs: any[]) => curried.apply(null, args.concat(restArgs));\n    }\n\n    return curried;\n}\n\n// 示例用法\nfunction add(a: number, b: number, c: number): number {\n    return a + b + c;\n}\n\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3)); // 输出 6\n```\n\n\n\n### es5和es6继承\n\n```js\n// ES5继承（构造函数 + 原型链）\nfunction AnimalES5(name: string) {\n  this.name = name;\n}\n\nAnimalES5.prototype.sayName = function () {\n  console.log(\"My name is \" + this.name);\n};\n\nfunction DogES5(name: string, breed: string) {\n  AnimalES5.call(this, name); // 调用父类构造函数\n  this.breed = breed;\n}\n\nDogES5.prototype = Object.create(AnimalES5.prototype); // 设置原型链\nDogES5.prototype.constructor = DogES5; // 修复构造函数\n\nDogES5.prototype.sayBreed = function () {\n  console.log(\"My breed is \" + this.breed);\n};\n\n// 示例用法\nconst dogES5 = new DogES5(\"Max\", \"Golden Retriever\");\ndogES5.sayName(); // 输出 \"My name is Max\"\ndogES5.sayBreed(); // 输出 \"My breed is Golden Retriever\"\n\n// ES6继承（使用class和extends关键字）\nclass AnimalES6 {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayName() {\n    console.log(\"My name is \" + this.name);\n  }\n}\n\nclass DogES6 extends AnimalES6 {\n  breed: string;\n  constructor(name: string, breed: string) {\n    super(name); // 调用父类构造函数\n    this.breed = breed;\n  }\n  sayBreed() {\n    console.log(\"My breed is \" + this.breed);\n  }\n}\n// 示例用法\nconst dogES6 = new DogES6(\"Max\", \"Golden Retriever\");\ndogES6.sayName(); // 输出 \"My name is Max\"\ndogES6.sayBreed(); // 输出 \"My breed is Golden Retriever\"\n```\n\n\n\n### instanceof\n\n```typescript\n// 自定义实现 instanceof\nfunction myInstanceOf(target: any, constructorFunc: Function): boolean {\n  // 参数校验\n  if (typeof target !== \'object\' || target === null || typeof constructorFunc !== \'function\') {\n    return false;\n  }\n\n  // 获取目标对象的原型\n  let targetProto = Object.getPrototypeOf(target);\n\n  // 获取构造函数的原型\n  const constructorProto = constructorFunc.prototype;\n\n  // 遍历原型链，查找目标对象是否是构造函数的实例\n  while (targetProto !== null) {\n    if (targetProto === constructorProto) {\n      return true;\n    }\n    targetProto = Object.getPrototypeOf(targetProto);\n  }\n\n  return false;\n}\n\n// 测试用例\nclass Animal {}\nclass Dog extends Animal {}\nclass Cat extends Animal {}\n\nconst dog = new Dog();\nconst cat = new Cat();\n\nconsole.log(myInstanceOf(dog, Dog)); // true\nconsole.log(myInstanceOf(dog, Animal)); // true\nconsole.log(myInstanceOf(cat, Dog)); // false\nconsole.log(myInstanceOf(cat, Animal)); // true\nconsole.log(myInstanceOf(123, Number)); // false\n```\n\n\n\n### 数组扁平化\n\n```typescript\n// 自定义实现数组扁平化\nfunction flattenArray(arr: any[]): any[] {\n  const result: any[] = [];\n\n  // 递归处理每个元素\n  function processItem(item: any) {\n    // 如果元素是数组，则递归处理\n    if (Array.isArray(item)) {\n      item.forEach(processItem);\n    } else {\n      // 如果元素不是数组，直接添加到结果数组中\n      result.push(item);\n    }\n  }\n\n  arr.forEach(processItem);\n  return result;\n}\n\n// 测试用例\nconst nestedArray = [1, [2, [3, 4], 5, [6, [7, 8]]], 9, 10];\n\nconsole.log(flattenArray(nestedArray)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nconst nestedArray2 = [1, [2, 3], 4, [[5], 6, [7, [8, 9, [10]]]]];\n\nconsole.log(flattenArray(nestedArray2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n\n\n### 对象扁平化\n\n```typescript\nfunction flattenObject(obj: { [key: string]: any }, prefix = \"\"): { [key: string]: any } {\n    const flattened: { [key: string]: any } = {};\n\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            const newKey = prefix ? `${prefix}.${key}` : key;\n\n            if (typeof obj[key] === \"object\" && obj[key] !== null && !Array.isArray(obj[key])) {\n                Object.assign(flattened, flattenObject(obj[key], newKey));\n            } else {\n                flattened[newKey] = obj[key];\n            }\n        }\n    }\n\n    return flattened;\n}\n\n// 示例用法\nconst nestedObj = {\n    a: {\n        b: {\n            c: 1,\n            d: {\n                e: 2\n            }\n        },\n        f: 3\n    },\n    g: {\n        h: 4\n    }\n};\n\nconst flattenedObj = flattenObject(nestedObj);\nconsole.log(flattenedObj);\n// 输出 { \'a.b.c\': 1, \'a.b.d.e\': 2, \'a.f\': 3, \'g.h\': 4 }\n```\n\n\n\n### JSON.parse\n\n```typescript\nconst myJSONParse = (target) => {\n  return eval(`(${target})`);\n};\n\n// 测试用例\nconst jsonString = \'{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\';\nconst parsedObject = myJSONParse(jsonString);\nconsole.log(parsedObject); // { name: \'JOHN\', age: 30, city: \'NEW YORK\' }\n```\n\n\n\n### EventEmitter事件触发器\n\n```typescript\nclass EventEmitter {\n    private events: Map<string, Array<(...args: any[]) => void>>;\n\n    constructor() {\n        this.events = new Map(); // 存储事件名和对应的回调函数列表\n    }\n\n    // 添加事件监听\n    on(event: string, listener: (...args: any[]) => void): void {\n        if (!this.events.has(event)) {\n            this.events.set(event, []);\n        }\n        this.events.get(event)!.push(listener);\n    }\n\n    // 移除事件监听\n    off(event: string, listener: (...args: any[]) => void): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n\n    // 触发事件\n    emit(event: string, ...args: any[]): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            listeners.forEach(listener => listener.apply(null, args));\n        }\n    }\n\n    // 添加只执行一次的事件监听\n    once(event: string, listener: (...args: any[]) => void): void {\n        const wrappedListener = (...args: any[]) => {\n            listener.apply(null, args);\n            this.off(event, wrappedListener);\n        };\n        this.on(event, wrappedListener);\n    }\n}\n\n// 示例用法\nconst eventEmitter = new EventEmitter();\n\nfunction hello(name: string) {\n    console.log(`Hello, ${name}!`);\n}\n\neventEmitter.on(\"greet\", hello);\neventEmitter.emit(\"greet\", \"Alice\"); // 输出 \"Hello, Alice!\"\n\neventEmitter.off(\"greet\", hello);\neventEmitter.emit(\"greet\", \"Bob\"); // 不会输出，因为监听器已被移除\n\neventEmitter.once(\"welcome\", hello);\neventEmitter.emit(\"welcome\", \"Carol\"); // 输出 \"Hello, Carol!\"\neventEmitter.emit(\"welcome\", \"David\"); // 不会输出，因为监听器只执行一次\n```\n\n\n\n### async/await\n\n```typescript\nfunction customAsync(generatorFn: (...args: any[]) => Generator) {\n    return function (...args: any[]) {\n        const generator = generatorFn.apply(null, args);\n\n        function handle(result: IteratorResult<any>): Promise<any> {\n            if (result.done) {\n                return Promise.resolve(result.value);\n            }\n\n            return Promise.resolve(result.value)\n                .then(value => handle(generator.next(value)))\n                .catch(error => handle(generator.throw!(error)));\n        }\n\n        return handle(generator.next());\n    };\n}\n\n// 示例用法\nfunction* myGenerator() {\n    const result1 = yield new Promise(resolve => setTimeout(() => resolve(\"First result\"), 1000));\n    console.log(result1);\n\n    const result2 = yield new Promise(resolve => setTimeout(() => resolve(\"Second result\"), 1000));\n    console.log(result2);\n\n    return \"Done\";\n}\n\nconst myAsyncFunction = customAsync(myGenerator);\nmyAsyncFunction().then(result => console.log(result)); // 依次输出 \"First result\", \"Second result\", \"Done\"\n```\n\n\n\n### 正则获取url params\n\n```typescript\n// 自定义实现获取 URL 参数\nfunction getUrlParams(url: string): Record<string, string> {\n  const params: Record<string, string> = {};\n  const regex = /[?&]([^=&#]+)=([^&#]*)/g;\n  let match: RegExpExecArray | null;\n\n  // 使用正则表达式匹配 URL 参数\n  while ((match = regex.exec(url)) !== null) {\n    // 将匹配到的参数名称和值添加到结果对象中\n    params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  }\n\n  return params;\n}\n\n// 测试用例\nconst testUrl1 = \'https://www.example.com/test?name=John&age=30&city=New%20York\';\nconst result1 = getUrlParams(testUrl1);\nconsole.log(result1); // { name: \'John\', age: \'30\', city: \'New York\' }\n\nconst testUrl2 = \'https://www.example.com/test?query=test&page=1&filter=active\';\nconst result2 = getUrlParams(testUrl2);\nconsole.log(result2); // { query: \'test\', page: \'1\', filter: \'active\' }\n```\n\n\n\n### jsonp\n\n```typescript\nfunction jsonp(url: string, params: { [key: string]: any }, callbackName: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n        // 创建一个全局回调函数，用于接收请求返回的数据\n        (window as any)[callbackName] = (data: any) => {\n            delete (window as any)[callbackName]; // 请求完成后删除全局回调函数\n            document.body.removeChild(script); // 移除script标签\n            resolve(data); // 解析Promise，返回数据\n        };\n\n        // 将请求参数和回调函数名添加到URL\n        const queryString = Object.entries(params)\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n            .join(\"&\");\n        const finalUrl = `${url}?${queryString}&callback=${callbackName}`;\n\n        // 创建并插入一个script标签，用于发起JSONP请求\n        const script = document.createElement(\"script\");\n        script.src = finalUrl;\n        script.onerror = () => reject(new Error(\"JSONP request failed\")); // 监听错误事件以处理请求失败的情况\n        document.body.appendChild(script);\n    });\n}\n\n// 示例用法\nconst url = \"https://api.example.com/data\";\nconst params = {\n    userId: 123,\n    accessToken: \"abcdefgh\"\n};\nconst callbackName = \"jsonpCallback\";\n\njsonp(url, params, callbackName)\n    .then(data => console.log(data))\n    .catch(error => console.error(error));\n```\n\n\n\n### JSON.stringify\n\n```typescript\nfunction customJSONStringify(obj: any): string | undefined {\n    const seenObjects: any[] = [];\n\n    function stringify(value: any): string | undefined {\n        if (typeof value === \"number\" || typeof value === \"boolean\" || value === null) {\n            return String(value);\n        }\n\n        if (typeof value === \"string\") {\n            return `\"${value}\"`;\n        }\n\n        if (typeof value === \"undefined\" || typeof value === \"function\" || value instanceof Symbol) {\n            return undefined;\n        }\n\n        if (seenObjects.indexOf(value) !== -1) {\n            throw new TypeError(\"Converting circular structure to JSON\");\n        }\n        seenObjects.push(value);\n\n        if (Array.isArray(value)) {\n            const arr = value.map(item => stringify(item) ?? \"null\");\n            return `[${arr.join(\",\")}]`;\n        }\n\n        const keys = Object.keys(value).filter(key => typeof value[key] !== \"function\" && typeof value[key] !== \"undefined\");\n        const keyValuePairs = keys.map(key => `\"${key}\":${stringify(value[key]) ?? \"null\"}`);\n        return `{${keyValuePairs.join(\",\")}}`;\n    }\n\n    return stringify(obj);\n}\n\n// 示例用法\nconst obj = {\n    name: \"Alice\",\n    age: 30,\n    sayHello: function() {\n        console.log(\"Hello\");\n    },\n    preferences: {\n        color: \"blue\",\n        food: \"pizza\"\n    }\n};\n\nconsole.log(customJSONStringify(obj)); // 输出 \'{\"name\":\"Alice\",\"age\":30,\"preferences\":{\"color\":\"blue\",\"food\":\"pizza\"}}\'\n```\n\n\n\n### Promise\n\n```typescript\n// 定义Promise的三种状态常量\nenum PromiseStatus {\n    Pending = \"PENDING\",\n    Fulfilled = \"FULFILLED\",\n    Rejected = \"REJECTED\"\n}\n\nclass CustomPromise {\n    status: PromiseStatus;\n    value: any;\n    reason: any;\n    onFulfilledCallbacks: Array<(...args: any[]) => void>;\n    onRejectedCallbacks: Array<(...args: any[]) => void>;\n\n    constructor(executor: (resolve: (value?: any) => void, reject: (reason?: any) => void) => void) {\n        this.status = PromiseStatus.Pending; // 初始状态为Pending\n        this.value = null; // 存储成功时的值\n        this.reason = null; // 存储失败时的原因\n        this.onFulfilledCallbacks = []; // 存储成功时的回调函数\n        this.onRejectedCallbacks = []; // 存储失败时的回调函数\n\n        const resolve = (value?: any) => {\n            if (this.status === PromiseStatus.Pending) {\n                this.status = PromiseStatus.Fulfilled;\n                this.value = value;\n                this.onFulfilledCallbacks.forEach(callback => callback());\n            }\n        };\n\n        const reject = (reason?: any) => {\n            if (this.status === PromiseStatus.Pending) {\n                this.status = PromiseStatus.Rejected;\n                this.reason = reason;\n                this.onRejectedCallbacks.forEach(callback => callback());\n            }\n        };\n\n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            reject(error);\n        }\n    }\n\n    then(onFulfilled?: (value: any) => any, onRejected?: (reason: any) => any): CustomPromise {\n        onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value;\n        onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason; };\n\n        const promise = new CustomPromise((resolve, reject) => {\n            const handleFulfilled = () => {\n                try {\n                    const result = onFulfilled!(this.value);\n                    if (result === promise) {\n                        throw new TypeError(\"Chaining cycle detected for promise\");\n                    }\n                    if (result instanceof CustomPromise) {\n                        result.then(resolve, reject);\n                    } else {\n                        resolve(result);\n                    }\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            const handleRejected = () => {\n                try {\n                    const result = onRejected!(this.reason);\n                    if (result === promise) {\n                        throw new TypeError(\"Chaining cycle detected for promise\");\n                    }\n                    if (result instanceof CustomPromise) {\n                        result.then(resolve, reject);\n                    } else {\n                        resolve(result);\n                    }\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            if (this.status === PromiseStatus.Fulfilled) {\n                queueMicrotask(handleFulfilled);\n            } else if (this.status === PromiseStatus.Rejected) {\n                queueMicrotask(handleRejected);\n            } else {\n                this.onFulfilledCallbacks.push(() => queueMicrotask(handleFulfilled));\n                this.onRejectedCallbacks.push(() => queueMicrotask(handleRejected));\n            }\n        });\n\n        return promise;\n    }\n\n    catch(onRejected?: (reason: any) => any): CustomPromise {\n        return this.then(undefined, onRejected);\n    }\n}\n```\n\n\n\n### 写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式\n\n```javascript\n// 方法一\nfunction getQueryParam(paramName) {\n  const urlParams = new URLSearchParams(window.location.search);\n  return urlParams.get(paramName);\n}\n\n// 使用示例\nconst myParamValue = getQueryParam(\'myParam\');\nconsole.log(myParamValue); // 输出myParam参数的值\n```\n\n```javascript\n// 方法二\nfunction getQueryParam(paramName) {\n  var params = window.location.search.substr(1).split(\'&\');\n  for (let i = 0; i < params.length; i++) {\n    let keyValuePair = params[i].split(\'=\');=\n    if (keyValuePair[0] === paramName) {\n      return decodeURIComponent(keyValuePair[1]);\n    }\n  }\n  return null;\n}\n\n// 使用示例\nconst myParamValue = getQueryParam(\'myParam\');\nconsole.log(myParamValue); // 输出myParam参数的值\n\n```\n');

-- ----------------------------
-- Table structure for t_article_tag_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag_rel`;
CREATE TABLE `t_article_tag_rel`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` bigint(20) UNSIGNED NOT NULL COMMENT '文章id',
  `tag_id` bigint(20) UNSIGNED NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id`) USING BTREE,
  INDEX `idx_tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 171 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章对应标签关联表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag_rel
-- ----------------------------
INSERT INTO `t_article_tag_rel` VALUES (63, 2, 10);
INSERT INTO `t_article_tag_rel` VALUES (64, 2, 11);
INSERT INTO `t_article_tag_rel` VALUES (73, 7, 10);
INSERT INTO `t_article_tag_rel` VALUES (74, 7, 9);
INSERT INTO `t_article_tag_rel` VALUES (75, 7, 11);
INSERT INTO `t_article_tag_rel` VALUES (93, 11, 1);
INSERT INTO `t_article_tag_rel` VALUES (94, 11, 30);
INSERT INTO `t_article_tag_rel` VALUES (95, 11, 24);
INSERT INTO `t_article_tag_rel` VALUES (96, 10, 1);
INSERT INTO `t_article_tag_rel` VALUES (97, 10, 17);
INSERT INTO `t_article_tag_rel` VALUES (107, 12, 1);
INSERT INTO `t_article_tag_rel` VALUES (108, 12, 31);
INSERT INTO `t_article_tag_rel` VALUES (109, 12, 32);
INSERT INTO `t_article_tag_rel` VALUES (110, 12, 33);
INSERT INTO `t_article_tag_rel` VALUES (117, 13, 1);
INSERT INTO `t_article_tag_rel` VALUES (118, 13, 33);
INSERT INTO `t_article_tag_rel` VALUES (119, 13, 32);
INSERT INTO `t_article_tag_rel` VALUES (121, 15, 17);
INSERT INTO `t_article_tag_rel` VALUES (122, 15, 9);
INSERT INTO `t_article_tag_rel` VALUES (126, 16, 1);
INSERT INTO `t_article_tag_rel` VALUES (127, 16, 25);
INSERT INTO `t_article_tag_rel` VALUES (128, 16, 32);
INSERT INTO `t_article_tag_rel` VALUES (130, 14, 9);
INSERT INTO `t_article_tag_rel` VALUES (131, 17, 2);
INSERT INTO `t_article_tag_rel` VALUES (132, 17, 11);
INSERT INTO `t_article_tag_rel` VALUES (133, 17, 12);
INSERT INTO `t_article_tag_rel` VALUES (134, 17, 22);
INSERT INTO `t_article_tag_rel` VALUES (135, 18, 1);
INSERT INTO `t_article_tag_rel` VALUES (136, 18, 9);
INSERT INTO `t_article_tag_rel` VALUES (137, 18, 24);
INSERT INTO `t_article_tag_rel` VALUES (138, 18, 30);
INSERT INTO `t_article_tag_rel` VALUES (139, 19, 11);
INSERT INTO `t_article_tag_rel` VALUES (140, 19, 34);
INSERT INTO `t_article_tag_rel` VALUES (153, 20, 2);
INSERT INTO `t_article_tag_rel` VALUES (154, 20, 9);
INSERT INTO `t_article_tag_rel` VALUES (155, 20, 39);
INSERT INTO `t_article_tag_rel` VALUES (158, 21, 40);
INSERT INTO `t_article_tag_rel` VALUES (159, 21, 2);
INSERT INTO `t_article_tag_rel` VALUES (160, 21, 11);
INSERT INTO `t_article_tag_rel` VALUES (161, 21, 12);
INSERT INTO `t_article_tag_rel` VALUES (162, 21, 21);
INSERT INTO `t_article_tag_rel` VALUES (163, 21, 22);
INSERT INTO `t_article_tag_rel` VALUES (164, 21, 23);
INSERT INTO `t_article_tag_rel` VALUES (165, 21, 34);
INSERT INTO `t_article_tag_rel` VALUES (166, 21, 35);
INSERT INTO `t_article_tag_rel` VALUES (167, 21, 36);
INSERT INTO `t_article_tag_rel` VALUES (168, 21, 37);
INSERT INTO `t_article_tag_rel` VALUES (169, 21, 38);
INSERT INTO `t_article_tag_rel` VALUES (170, 21, 39);

-- ----------------------------
-- Table structure for t_blog_settings
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_settings`;
CREATE TABLE `t_blog_settings`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `logo` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '博客Logo',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '博客名称',
  `author` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '作者名',
  `introduction` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '介绍语',
  `avatar` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '作者头像',
  `github_homepage` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'GitHub 主页访问地址',
  `csdn_homepage` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'CSDN 主页访问地址',
  `gitee_homepage` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'Gitee 主页访问地址',
  `zhihu_homepage` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '知乎主页访问地址',
  `mail` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '博主邮箱地址',
  `is_comment_sensi_word_open` tinyint(2) NOT NULL DEFAULT 1 COMMENT '是否开启评论敏感词过滤, 0:不开启；1：开启',
  `is_comment_examine_open` tinyint(2) NOT NULL DEFAULT 0 COMMENT '是否开启评论审核, 0: 未开启；1：开启',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客设置表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog_settings
-- ----------------------------
INSERT INTO `t_blog_settings` VALUES (1, 'https://img.arnasoft.site/weblog/6e8232c354434ef5995563c30a200df7.jpg', '程序猿小萨', '程序猿小萨', '学的不仅是技术，更是梦想', 'https://img.arnasoft.site/weblog/b07c0cacc7e24ab29d820819f5fba49d.jpg', 'https://github.com/programmer-xiaosa', 'https://space.bilibili.com/1562860055/favlist?fid=1592147955&ftype=create', 'https://gitee.com/qarabala', 'https://qarabala.gitee.io/blog/', 'qarabala@126.com', 1, 1);

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '分类名称',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除标志位：0：未删除 1：已删除',
  `articles_total` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_name`(`name`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章分类表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (2, '后端开发', '2024-03-21 17:32:04', '2024-03-21 17:32:04', 0, 3);
INSERT INTO `t_category` VALUES (3, 'Flutter', '2024-03-21 17:54:51', '2024-03-21 17:54:51', 0, 0);
INSERT INTO `t_category` VALUES (7, 'Nodejs', '2024-03-21 17:55:11', '2024-03-21 17:55:11', 0, 1);
INSERT INTO `t_category` VALUES (9, '前端开发', '2024-03-21 19:39:38', '2024-03-21 19:39:38', 0, 6);
INSERT INTO `t_category` VALUES (10, 'App开发', '2024-03-21 20:56:46', '2024-03-21 20:56:46', 0, 0);
INSERT INTO `t_category` VALUES (11, '人工智能', '2024-03-21 20:56:58', '2024-03-21 20:56:58', 0, 0);
INSERT INTO `t_category` VALUES (17, '生活知识', '2024-03-26 08:00:16', '2024-03-26 08:00:16', 0, 0);
INSERT INTO `t_category` VALUES (18, '软件安装', '2024-03-26 08:01:19', '2024-03-26 08:01:19', 0, 4);
INSERT INTO `t_category` VALUES (19, 'Git', '2024-04-17 11:16:04', '2024-04-17 11:16:04', 0, 0);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `content` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '评论内容',
  `avatar` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `nickname` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '昵称',
  `mail` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '邮箱',
  `website` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站地址',
  `router_url` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '评论所属的路由',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '删除标志位：0：未删除 1：已删除',
  `reply_comment_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '回复的评论 ID',
  `parent_comment_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '父评论 ID',
  `reason` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '原因描述',
  `status` tinyint(2) NOT NULL DEFAULT 1 COMMENT '1: 待审核；2：正常；3：审核未通过;',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_router_url`(`router_url`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE,
  INDEX `idx_reply_comment_id`(`reply_comment_id`) USING BTREE,
  INDEX `idx_parent_comment_id`(`parent_comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------

-- ----------------------------
-- Table structure for t_statistics_article_pv
-- ----------------------------
DROP TABLE IF EXISTS `t_statistics_article_pv`;
CREATE TABLE `t_statistics_article_pv`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `pv_date` date NOT NULL COMMENT '被统计的日期',
  `pv_count` bigint(20) UNSIGNED NOT NULL COMMENT 'pv访问量',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_pv_date`(`pv_date`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '统计表 - 文章 PV (访问量)' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_statistics_article_pv
-- ----------------------------
INSERT INTO `t_statistics_article_pv` VALUES (1, '2024-03-27', 13, '2024-03-26 23:00:00', '2024-03-26 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (2, '2024-03-28', 64, '2024-03-27 23:00:00', '2024-03-27 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (3, '2024-04-04', 0, '2024-04-03 23:00:00', '2024-04-03 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (4, '2024-04-05', 3, '2024-04-04 23:00:00', '2024-04-04 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (5, '2024-04-06', 15, '2024-04-05 23:00:00', '2024-04-05 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (6, '2024-04-07', 5, '2024-04-06 23:00:00', '2024-04-06 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (8, '2024-04-08', 17, '2024-04-07 23:00:00', '2024-04-07 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (9, '2024-04-09', 1, '2024-04-08 23:00:00', '2024-04-08 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (10, '2024-04-10', 4, '2024-04-09 23:00:00', '2024-04-09 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (11, '2024-04-11', 7, '2024-04-10 23:00:00', '2024-04-10 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (12, '2024-04-12', 3, '2024-04-11 23:00:00', '2024-04-11 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (13, '2024-04-13', 1, '2024-04-12 23:00:00', '2024-04-12 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (14, '2024-04-14', 2, '2024-04-13 23:00:00', '2024-04-13 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (15, '2024-04-15', 11, '2024-04-14 23:00:00', '2024-04-14 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (16, '2024-04-16', 0, '2024-04-15 23:00:00', '2024-04-15 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (17, '2024-04-17', 64, '2024-04-16 23:00:00', '2024-04-16 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (18, '2024-04-18', 10, '2024-04-17 23:00:00', '2024-04-17 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (19, '2024-04-19', 2, '2024-04-18 23:00:00', '2024-04-18 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (20, '2024-04-20', 1, '2024-04-19 23:00:00', '2024-04-19 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (21, '2024-04-21', 0, '2024-04-20 23:00:00', '2024-04-20 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (22, '2024-04-22', 0, '2024-04-21 23:00:00', '2024-04-21 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (23, '2024-04-23', 6, '2024-04-22 23:00:00', '2024-04-22 23:00:00');
INSERT INTO `t_statistics_article_pv` VALUES (24, '2024-04-24', 16, '2024-04-23 23:00:00', '2024-04-23 23:00:00');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '标签名称',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除标志位：0：未删除 1：已删除',
  `articles_total` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_name`(`name`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章标签表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (1, 'java', '2024-03-21 23:44:27', '2024-03-21 23:44:27', 0, 6);
INSERT INTO `t_tag` VALUES (2, 'javascript', '2024-03-21 23:44:44', '2024-03-21 23:44:44', 0, 3);
INSERT INTO `t_tag` VALUES (3, 'Python', '2024-03-21 23:44:49', '2024-03-21 23:44:49', 0, 0);
INSERT INTO `t_tag` VALUES (9, '工具', '2024-03-22 16:34:10', '2024-03-22 16:34:10', 0, 5);
INSERT INTO `t_tag` VALUES (10, 'Flutter', '2024-03-22 16:36:30', '2024-03-22 16:36:30', 0, 2);
INSERT INTO `t_tag` VALUES (11, 'Vue3', '2024-03-22 17:16:24', '2024-03-22 17:16:24', 0, 5);
INSERT INTO `t_tag` VALUES (12, 'Vite', '2024-03-22 17:16:24', '2024-03-22 17:16:24', 0, 2);
INSERT INTO `t_tag` VALUES (13, 'Element', '2024-03-22 17:16:24', '2024-03-22 17:16:24', 0, 0);
INSERT INTO `t_tag` VALUES (14, '生活知识', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (15, '健康', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (16, '跑步', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (17, 'Mac', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 2);
INSERT INTO `t_tag` VALUES (18, 'Windows', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (19, 'iPhone', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (20, '安卓', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 0);
INSERT INTO `t_tag` VALUES (21, 'UniApp', '2024-03-26 16:02:48', '2024-03-26 16:02:48', 0, 1);
INSERT INTO `t_tag` VALUES (22, 'Vue2', '2024-03-26 16:03:30', '2024-03-26 16:03:30', 0, 2);
INSERT INTO `t_tag` VALUES (23, '微信小程序', '2024-03-26 16:03:30', '2024-03-26 16:03:30', 0, 1);
INSERT INTO `t_tag` VALUES (24, 'SpringBoot', '2024-03-26 16:03:30', '2024-03-26 16:03:30', 0, 2);
INSERT INTO `t_tag` VALUES (25, 'Redis', '2024-03-26 16:03:30', '2024-03-26 16:03:30', 0, 1);
INSERT INTO `t_tag` VALUES (26, '心理学', '2024-03-26 16:04:21', '2024-03-26 16:04:21', 0, 0);
INSERT INTO `t_tag` VALUES (27, '孩子教育', '2024-03-26 16:04:21', '2024-03-26 16:04:21', 0, 0);
INSERT INTO `t_tag` VALUES (28, '自我提升', '2024-03-26 16:04:21', '2024-03-26 16:04:21', 0, 0);
INSERT INTO `t_tag` VALUES (29, '经济管理', '2024-03-26 16:04:21', '2024-03-26 16:04:21', 0, 0);
INSERT INTO `t_tag` VALUES (30, 'IDE', '2024-03-26 17:53:00', '2024-03-26 17:53:00', 0, 2);
INSERT INTO `t_tag` VALUES (31, 'MySql', '2024-04-03 10:45:31', '2024-04-03 10:45:31', 0, 1);
INSERT INTO `t_tag` VALUES (32, 'Docker', '2024-04-03 10:45:31', '2024-04-03 10:45:31', 0, 3);
INSERT INTO `t_tag` VALUES (33, 'Jenkins', '2024-04-03 10:45:31', '2024-04-03 10:45:31', 0, 2);
INSERT INTO `t_tag` VALUES (34, 'VueUse', '2024-04-17 00:33:03', '2024-04-17 00:33:03', 0, 2);
INSERT INTO `t_tag` VALUES (35, 'Git', '2024-04-17 19:16:25', '2024-04-17 19:16:25', 0, 1);
INSERT INTO `t_tag` VALUES (36, 'Npm', '2024-04-17 19:19:48', '2024-04-17 19:19:48', 0, 1);
INSERT INTO `t_tag` VALUES (37, 'Vant', '2024-04-17 19:19:48', '2024-04-17 19:19:48', 0, 1);
INSERT INTO `t_tag` VALUES (38, 'ElementUI', '2024-04-17 19:19:48', '2024-04-17 19:19:48', 0, 1);
INSERT INTO `t_tag` VALUES (39, '字体图标', '2024-04-19 18:46:32', '2024-04-19 18:46:32', 0, 2);
INSERT INTO `t_tag` VALUES (40, '面试题', '2024-04-23 18:58:17', '2024-04-23 18:58:17', 0, 1);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除：0：未删除 1：已删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (4, 'admin', '$2a$10$531JxSQvMdHpG619AL.b1uQsQhr9UgL1xo.6FbW.J5JJnv6wmwuGC', '2024-03-20 12:36:43', '2024-04-16 23:32:43', 0);
INSERT INTO `t_user` VALUES (5, 'test', '$2a$10$n7RJ1q.RnXx5M3O6B0i0he04fZOPjIJpyWcKuicW1bFyFHWhlGose', '2024-03-20 12:36:43', '2024-03-20 12:36:43', 0);

-- ----------------------------
-- Table structure for t_user_role
-- ----------------------------
DROP TABLE IF EXISTS `t_user_role`;
CREATE TABLE `t_user_role`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `role` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '角色',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户角色表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_role
-- ----------------------------
INSERT INTO `t_user_role` VALUES (1, 'admin', 'ROLE_ADMIN', '2023-07-07 01:21:15');
INSERT INTO `t_user_role` VALUES (2, 'test', 'ROLE_VISITOR', '2023-07-07 01:23:33');

-- ----------------------------
-- Table structure for t_wiki
-- ----------------------------
DROP TABLE IF EXISTS `t_wiki`;
CREATE TABLE `t_wiki`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '标题',
  `cover` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '封面',
  `summary` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '摘要',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '删除标志位：0：未删除 1：已删除',
  `weight` int(6) UNSIGNED NOT NULL DEFAULT 0 COMMENT '权重，用于是否置顶（0: 未置顶；>0: 参与置顶，权重值越高越靠前）',
  `is_publish` tinyint(2) NOT NULL DEFAULT 1 COMMENT '是否发布：0：未发布 1：已发布',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '知识库表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_wiki
-- ----------------------------
INSERT INTO `t_wiki` VALUES (2, '后端知识库', 'https://img.arnasoft.site/weblog/b832eedf60df4a65aa76aebadbc239e7.png', 'Springboot / MyBatis / MySql', '2024-04-01 12:21:28', '2024-04-01 12:21:28', 0, 3, 1);
INSERT INTO `t_wiki` VALUES (4, '前端知识库', 'https://img.arnasoft.site/weblog/8e0adc2704154e848512f540867a9072.jpeg', 'HTML / CSS / JavaScript / Vue2 / Vue3 / React / Bootstrap', '2024-04-01 16:38:53', '2024-04-01 16:38:53', 0, 4, 1);
INSERT INTO `t_wiki` VALUES (5, 'App开发', 'https://img.arnasoft.site/weblog/ed5ab469e72f4ec8a93bb2df787b0eea.jpg', 'Flutter / UniApp / RN', '2024-04-17 11:42:00', '2024-04-17 11:42:00', 0, 0, 1);
INSERT INTO `t_wiki` VALUES (6, '微信小程序开发', 'https://img.arnasoft.site/weblog/ae1d3e9c86c94dfb94a9d64cc00fd801.jpg', '原生开发 / UniApp', '2024-04-17 11:44:51', '2024-04-17 11:44:51', 0, 0, 1);
INSERT INTO `t_wiki` VALUES (7, '桌面端开发（Electron）', 'https://img.arnasoft.site/weblog/b75a66015c624be99c8999d27e777e3c.jpg', 'Electron 是一个基于 Chrominum 和 Node.js 的跨平台桌面应用框架', '2024-04-17 11:51:38', '2024-04-17 11:51:38', 0, 0, 1);

-- ----------------------------
-- Table structure for t_wiki_catalog
-- ----------------------------
DROP TABLE IF EXISTS `t_wiki_catalog`;
CREATE TABLE `t_wiki_catalog`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `wiki_id` bigint(20) UNSIGNED NOT NULL COMMENT '知识库id',
  `article_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '文章id',
  `title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `level` tinyint(2) NOT NULL DEFAULT 1 COMMENT '目录层级',
  `parent_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '父目录id',
  `sort` tinyint(2) UNSIGNED NOT NULL DEFAULT 1 COMMENT '排序',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '删除标志位：0：未删除 1：已删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_article_id`(`article_id`) USING BTREE,
  INDEX `idx_sort`(`sort`) USING BTREE,
  INDEX `idx_wiki_id`(`wiki_id`) USING BTREE,
  INDEX `idx_parent_id`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 210 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '知识库目录表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_wiki_catalog
-- ----------------------------
INSERT INTO `t_wiki_catalog` VALUES (182, 2, NULL, '软件安装', 1, NULL, 1, '2024-04-16 17:04:39', '2024-04-16 17:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (183, 2, 18, 'IDEA 创建SpringBoot项目没办法选择jdk8', 2, 182, 1, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (184, 2, 16, 'Linux docker redis 设置密码并启动登录', 2, 182, 2, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (185, 2, 11, 'idea Server URL 配置修改', 2, 182, 3, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (186, 2, 10, 'Mac 多版本jdk安装与切换', 2, 182, 4, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (187, 2, NULL, 'Docker', 1, NULL, 2, '2024-04-16 17:04:39', '2024-04-16 17:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (188, 2, 13, 'Docker 安装 Jenkins（图文教程）', 2, 187, 1, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (189, 2, 12, '修改Docker容器内的MySQL服务密码，并成功完成可视化工具登录', 2, 187, 2, '2024-04-17 01:04:39', '2024-04-17 01:04:39', 0);
INSERT INTO `t_wiki_catalog` VALUES (196, 4, NULL, 'Vue', 1, NULL, 1, '2024-04-16 17:05:04', '2024-04-16 17:05:04', 0);
INSERT INTO `t_wiki_catalog` VALUES (197, 4, 19, '使用 useDark(), 发现 transition 动画失效?', 2, 196, 1, '2024-04-17 01:05:05', '2024-04-17 01:05:05', 0);
INSERT INTO `t_wiki_catalog` VALUES (198, 4, 17, 'Vue 项目中 Vconsole 的使用', 2, 196, 2, '2024-04-17 01:05:05', '2024-04-17 01:05:05', 0);
INSERT INTO `t_wiki_catalog` VALUES (199, 4, NULL, 'Nodejs', 1, NULL, 2, '2024-04-16 17:05:04', '2024-04-16 17:05:04', 0);
INSERT INTO `t_wiki_catalog` VALUES (200, 4, 15, 'mac 安装n进行node版本管理', 2, 199, 1, '2024-04-17 01:05:05', '2024-04-17 01:05:05', 0);
INSERT INTO `t_wiki_catalog` VALUES (201, 4, NULL, '文档库', 1, NULL, 3, '2024-04-16 17:05:04', '2024-04-16 17:05:04', 0);
INSERT INTO `t_wiki_catalog` VALUES (202, 4, 7, '极客园PC', 2, 201, 1, '2024-04-17 01:05:05', '2024-04-17 01:05:05', 0);
INSERT INTO `t_wiki_catalog` VALUES (203, 4, 2, 'TypeScript文档', 2, 201, 2, '2024-04-17 01:05:05', '2024-04-17 01:05:05', 0);
INSERT INTO `t_wiki_catalog` VALUES (204, 5, NULL, '概述', 1, NULL, 1, '2024-04-17 03:41:59', '2024-04-17 03:41:59', 0);
INSERT INTO `t_wiki_catalog` VALUES (205, 5, NULL, '基础', 1, NULL, 2, '2024-04-17 03:41:59', '2024-04-17 03:41:59', 0);
INSERT INTO `t_wiki_catalog` VALUES (206, 6, NULL, '概述', 1, NULL, 1, '2024-04-17 03:44:50', '2024-04-17 03:44:50', 0);
INSERT INTO `t_wiki_catalog` VALUES (207, 6, NULL, '基础', 1, NULL, 2, '2024-04-17 03:44:50', '2024-04-17 03:44:50', 0);
INSERT INTO `t_wiki_catalog` VALUES (208, 7, NULL, '概述', 1, NULL, 1, '2024-04-17 03:51:38', '2024-04-17 03:51:38', 0);
INSERT INTO `t_wiki_catalog` VALUES (209, 7, NULL, '基础', 1, NULL, 2, '2024-04-17 03:51:38', '2024-04-17 03:51:38', 0);

SET FOREIGN_KEY_CHECKS = 1;
